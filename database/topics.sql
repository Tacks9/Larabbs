-- MySQL dump 10.13  Distrib 5.7.24, for Linux (x86_64)
--
-- Host: localhost    Database: nyistbbs
-- ------------------------------------------------------
-- Server version	5.7.24-0ubuntu0.18.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Dumping data for table `topics`
--

LOCK TABLES `topics` WRITE;
/*!40000 ALTER TABLE `topics` DISABLE KEYS */;
INSERT INTO `topics` VALUES (1,'TCP是怎样运行的？','       TCP是传输控制协议的缩写，这里的控制，就是流量控制、拥塞控制和差错控制。TCP是可靠的传输协议，它用了很多机制，来保证传输的可靠性。本文将详解TCP的机制，纯手工原创，文中若有错误，欢迎指出。 点此移...','how-does-tcp-work','<p>       TCP是传输控制协议的缩写，这里的控制，就是流量控制、拥塞控制和差错控制。TCP是可靠的传输协议，它用了很多机制，来保证传输的可靠性。本文将详解TCP的机制，纯手工原创，文中若有错误，欢迎指出。</p>\n\n<p>点此移步我的原创博客：<a href=\"https://hackeryard.github.io/2020/04/29/network-tcp/\">https://hackeryard.github.io/2020/04/29/network-tcp/</a></p>',2,1,0,4,0,0,1,'2020-05-03 12:48:58','2020-05-13 18:56:26'),(2,'Java并发编程问答题','  Q1：线程越多程序是否就运行得越快？答：并发编程的目的是为了让程序运行得更快，但是并不是启动得线程越多就能让程序最大限度地并发执行。在并发编程时，如果希望通过多线程执行任务让程序运行得更快会面临很多挑...','java-concurrent-programming-q-a','<p> </p>\n\n<p>Q1：线程越多程序是否就运行得越快？<br />答：并发编程的目的是为了让程序运行得更快，但是并不是启动得线程越多就能让程序最大限度地并发执行。在并发编程时，如果希望通过多线程执行任务让程序运行得更快会面临很多挑战，比如上下文切换的问题、死锁的问题，以及受限于硬件和软件的资源限制问题。</p>\n\n<p>Q2：多线程并发是怎么实现的，必须要用多核处理器实现吗？<br />答：即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短（一般是几十毫秒），所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的。</p>\n\n<p>Q3：什么是上下文切换？<br />答:CPU是通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是在切换前会保存上一个任务的状态，以便下次再切换回这个任务时可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>\n\n<p>Q4：如何减少上下文切换？<br />答：①无锁并发编程：多线程竞争锁时会引起上下文切换，所以多线程处理数据时，可以通过一些方法来避免使用锁，例如将数据的id按照hash算法取模分段，不同的线程处理不同数据段的数据。②CAS算法：Java的atomic包使用CAS算法来更新数据而不需要加锁。③使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。④协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</p>\n\n<p>Q5：多线程避免死锁的方法？<br />答：①避免一个线程同时获得多个锁。②避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。③尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制。④对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的问题。</p>',2,1,0,4,0,0,1,'2020-05-03 13:26:15','2020-05-13 18:56:11'),(3,'计算机网络常见面试题','计算机网络常见面试题 浏览器输入网址之后发生了什么 DNS域名解析 HTTP协议生成请求报文 TCP协议将请求报文分割成报文段，进行可靠传输 IP协议进行分组转发 TCP协议重组请求报文 HTTP协议对请求进行处理 TCP/IP协议...','common-interview-questions-on-computer-network','<p><span style=\"color:rgb(51,51,51);\"><b>计算机网络常见面试题</b></span><br /></p>\n\n<p><br /></p>\n\n<ul><li>浏览器输入网址之后发生了什么</li></ul>\n\n<pre><code class=\"lang-bash\">DNS域名解析\nHTTP协议生成请求报文\nTCP协议将请求报文分割成报文段，进行可靠传输\nIP协议进行分组转发\nTCP协议重组请求报文\nHTTP协议对请求进行处理</code></pre>\n\n<ul><li>TCP/IP协议各层的作用</li></ul>\n\n<pre><code>应用层：\n    应用层的任务是通过应用进程之间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。这里的进程是指主机中正在与运行的程序。对于不同的网络应用需要有不同的应用层协议。在互联网中的应用层协议有很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，等等。\n\n传输层：\n    传输层的任务是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要有TCP协议和UDP协议。\n\n网络层：\n    网络层的任务是为分组交换网上的不同主机提供通信服务。在发送数据的时候，网络层把运输层产生的报文段或者用户数据报封装成分组或包进行传送。主要使用IP协议。\n\n网络接口层：\n    操作系统中的设备驱动和计算机对应的网络接口，它们一起处理与传输媒介的物理接口细节。主要有ARP协议和RARP协议。<br /></code></pre>\n\n<ul><li>HTTP和HTTPS的区别<br /></li></ul>\n\n<pre><code>端口：\n    HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的UR由“https://”起始且默认使用端口443。\n\n安全性和资源消耗： \n    HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。\n\n对称加密：\n    密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；\n\n非对称加密：\n    密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。<br /></code></pre>\n\n<ul><li>HTTPS的加密过程<br /></li></ul>\n\n<pre><code>证书验证，客户端发送一个证书请求个服务器端，服务器端返回证书，客户端对证书进行验证。\n\n交换密钥，使用非对称加密，客户端使用公钥进行加密，服务器端使用密钥解密。\n\n交换数据，使用对称加密的方式对数据进行加密，然后进行传输。<br /></code></pre>\n\n<ul><li>HTTP1.0和HTPP1.1的区别<br /></li></ul>\n\n<pre><code>缓存处理：\n    在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n\n带宽优化及网络连接的使用：\n    HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n错误通知的管理：\n    在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n\nHost头处理：\n    在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。\n\n长连接：\n    HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。<br /></code></pre>\n\n<ul><li>HTTP2.0与HTTP1.x的区别<br /></li></ul>\n\n<pre><code>新的二进制格式（Binary Format）：\n    HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮\n\n多路复用（MultiPlexing）：\n    即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n\nheader压缩：\n    HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n\n服务端推送（server push）：\n    同SPDY一样，HTTP2.0也具有server push功能。<br /></code></pre>\n\n<ul><li>HTTP和WebSocket的联系和区别，什么情况下用WebSocket</li></ul>\n\n<pre><code>    HTTP1.x是半双工通信，客户端请求服务器响应，是无状态的，如果要实现实时通讯需要长轮询或者长连接的方式，这两种方式带来资源浪费。WebSocket是HTML5以后基于TCP协议应用层的一种全双工实时通讯协议。客户端和服务端可以进行信息的相互传递。它是借Http请求产生握手，在Http的头部会包含WebSocket协议的请求，所以握手之后，协议进行一个升级，转成TCP协议进行交流。WebSocket可以应用于聊天和即时信息<br /></code></pre>\n\n<ul><li>WebSocket通信流程<br /></li></ul>\n\n<pre><code>    建立socket通信,包括客户端和服务器端创建套接字（socket方法），服务器端绑定端口（bind方法），建立监听（listen方法），客户端创建连接（connect方法）。\n\n    TCP三次握手建立连接\n\n    客户端服务器端收发数据（send方法、recv方法），读写数据（read方法、write方法）。\n\n    TCP四次挥手关闭连接\n\n    关闭socket（close方法）<br /></code></pre>\n\n<ul><li>Socket编程主要大的步骤<br /></li></ul>\n\n<pre><code>创建套接字（socket方法）\n\n客户端建立连接（connect方法），服务器端绑定端口（bind），建立监听（listen方法）\n\n写入数据（write方法），发送数据（send方法），接收数据（recv方法）读取数据（read方法）\n\n关闭连接（close方法）<br /></code></pre>\n\n<ul><li>HTTP协议中的GET和POST方式的区别<br /></li></ul>\n\n<pre><code>参数位置：GET方法参数位置包含在URL，POST方法参数包含在请求主体\n\n参数长度：GET方法的URL长度有限度，POST长度没有限制\n\n参数编码：GET方法参数编码是ASCII码，POST没有限制\n\nTCP数据包：GET方法产生一个TCP数据包，把首部和数据一起发送，POST方法产生两个TCP数据包，先发首部，服务器响应后再发数据<br /></code></pre>\n\n<ul><li>Session和Cookie的区别<br /></li></ul>\n\n<pre><code>储存位置：Cookie是客户端会话技术，数据保存在客户端，Session是服务器端会话技术，数据保存在服务器端。\n\n存储容量：Cookie一般&lt;=4KB，Session无限制。\n\n跨域支持：Cookie支持跨域，Session不支持。<br /></code></pre>\n\n<ul><li>Cookie的特点和作用</li></ul>\n\n<pre><code>特点：\n    Cookie储存数据在客户端浏览器\n    浏览器对于单个Cookie的大小有限制（4KB）以及对于同一域名下的总Cookie数量也有限制（20个）\n\n作用：\n    Cookie一般用于存储少量的不太敏感的数据\n    在不登陆的情况下，完成服务器对客户端的身份识别<br /></code></pre>\n\n<ul><li>如何设计API的安全性<br /></li></ul>\n\n<pre><code>Token授权机制\n时间戳超时机制\n签名机制\n拒绝重复调用<br /></code></pre>\n\n<ul><li>HTTP攻击有哪些<br /></li></ul>\n\n<pre><code>跨站脚本攻击（XSS）\nDos攻击\nSQL注入攻击\nOS命令注入攻击\nHTTP头部攻击\n目录攻击\n开放重定向攻击<br /></code></pre>\n\n<ul><li>TCP和UDP的区别<br /></li></ul>\n\n<pre><code>连接：\n    UDP是无连接的，发送数据之前无需建立连接，发送数据结束后也无需释放连接。TCP是面向连接的，在发送数据之前需要通过三次握手建立连接，发送数据结束后需要通过四次挥手释放连接。\n\n交付：\n    UDP使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表。TCP提供可靠交付，即通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。\n\n数据：\n    UDP是面向报文的，UDP对于应用层交下来的报文，添加首部后就向下交给IP层，既不合并，也不拆分，一次交付一个完整的报文。TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据看出成一连串无结构的字节流。TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小关系。\n\n通信双方：\n    UDP支持一对一、一对多、多对一、多对多的交互通信。TCP连接是点对点（一对一），每一条TCP连接只能有两个端点。\n\n拥塞：\n    UDP没有拥塞控制，网络的拥塞不会使源主机的发送速率降低。TCP通过慢开始、拥塞避免、快重传、快恢复等算法进行拥塞控制。\n\n首部：\n    UDP首开销小，只有8个字节。TCP首部是20个字节。<br /></code></pre>\n\n<ul><li>交换机和路由器的区别<br /></li></ul>\n\n<pre><code>工作层次：\n    交换机主要工作在数据链路层，路由器主要工作在网络层\n\n转发依据：\n    交换机转发依据的对象是MAC地址，路由器转发依据的对象是IP地址\n\n功能：\n    交换机功能较简单，只是将主机连接起来组件局域网，路由器可以将局域网连接起来，还能分割广播域，还能提供防火墙<br /></code></pre>\n\n<ul><li>ARP协议的工作原理<br /></li></ul>\n\n<pre><code>将IP地址转换为物理地址 广播发送ARP请求，单播发送ARP响应。\n  \n首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。\n\n当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。\n\n当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。\n\n源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。\n<br /></code></pre>\n\n<ul><li>路由选择协议<br /></li></ul>\n\n<pre><code>内部网关协议RIP（Routing Information Protocol）：RIP是一种分布式的基于距离向量的路由选择协议。\n\n内部网关协议OPSF（Open Shortest Path First）：OSPF是使用分布式的链路状态协议。\n\n外部网关协议BGP（Border Gateway Protocol）：边界网关协议。<br /></code></pre>',2,2,0,3,0,0,1,'2020-05-03 13:50:26','2020-05-13 18:56:07'),(4,'epoll内核源码详解+自己总结的流程','epoll使用了copy_from_user跟__put_user进行内核跟用户虚拟空间数据交互,没有使用共享内存的任何api。下面是源码解析 /*  *  fs/eventpoll.c (Efficient event retrieval implementation)  *  Copyright (C) 2001,.....','detailed-explanation-of-epoll-kernel-source-code-self-summarized-process','<blockquote><p><span style=\"color:rgb(51,51,51);\"><span style=\"color:rgb(51,51,51);\">epoll</span>使用了copy_from_user跟__put_user进行内核跟用户虚拟空间数据交互,没有使用共享内存的任何api。下面是源码解析</span></p></blockquote>\n\n<pre><code>/*\n *  fs/eventpoll.c (Efficient event retrieval implementation)\n *  Copyright (C) 2001,...,2009  Davide Libenzi\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  Davide Libenzi &lt;davidel@xmailserver.org&gt;\n *\n */\n/*\n * 在深入了解epoll的实现之前, 先来了解内核的3个方面.\n * 1. 等待队列 waitqueue\n * 我们简单解释一下等待队列:\n * 队列头(wait_queue_head_t)往往是资源生产者,\n * 队列成员(wait_queue_t)往往是资源消费者,\n * 当头的资源ready后, 会逐个执行每个成员指定的回调函数,\n * 来通知它们资源已经ready了, 等待队列大致就这个意思.\n * 2. 内核的poll机制\n * 被Poll的fd, 必须在实现上支持内核的Poll技术,\n * 比如fd是某个字符设备,或者是个socket, 它必须实现\n * file_operations中的poll操作, 给自己分配有一个等待队列头.\n * 主动poll fd的某个进程必须分配一个等待队列成员, 添加到\n * fd的对待队列里面去, 并指定资源ready时的回调函数.\n * 用socket做例子, 它必须有实现一个poll操作, 这个Poll是\n * 发起轮询的代码必须主动调用的, 该函数中必须调用poll_wait(),\n * poll_wait会将发起者作为等待队列成员加入到socket的等待队列中去.\n * 这样socket发生状态变化时可以通过队列头逐个通知所有关心它的进程.\n * 这一点必须很清楚的理解, 否则会想不明白epoll是如何\n * 得知fd的状态发生变化的.\n * 3. epollfd本身也是个fd, 所以它本身也可以被epoll,\n * 可以猜测一下它是不是可以无限嵌套epoll下去... \n *\n * epoll基本上就是使用了上面的1,2点来完成.\n * 可见epoll本身并没有给内核引入什么特别复杂或者高深的技术,\n * 只不过是已有功能的重新组合, 达到了超过select的效果.\n */\n/* \n * 相关的其它内核知识:\n * 1. fd我们知道是文件描述符, 在内核态, 与之对应的是struct file结构,\n * 可以看作是内核态的文件描述符.\n * 2. spinlock, 自旋锁, 必须要非常小心使用的锁,\n * 尤其是调用spin_lock_irqsave()的时候, 中断关闭, 不会发生进程调度,\n * 被保护的资源其它CPU也无法访问. 这个锁是很强力的, 所以只能锁一些\n * 非常轻量级的操作.\n * 3. 引用计数在内核中是非常重要的概念,\n * 内核代码里面经常有些release, free释放资源的函数几乎不加任何锁,\n * 这是因为这些函数往往是在对象的引用计数变成0时被调用,\n * 既然没有进程在使用在这些对象, 自然也不需要加锁.\n * struct file 是持有引用计数的.\n */\n/* --- epoll相关的数据结构 --- */\n/*\n * This structure is stored inside the \"private_data\" member of the file\n * structure and rapresent the main data sructure for the eventpoll\n * interface.\n */\n/* 每创建一个epollfd, 内核就会分配一个eventpoll与之对应, 可以说是\n * 内核态的epollfd. */\nstruct eventpoll {\n    /* Protect the this structure access */\n    spinlock_t lock;\n    /*\n     * This mutex is used to ensure that files are not removed\n     * while epoll is using them. This is held during the event\n     * collection loop, the file cleanup path, the epoll file exit\n     * code and the ctl operations.\n     */\n    /* 添加, 修改或者删除监听fd的时候, 以及epoll_wait返回, 向用户空间\n     * 传递数据时都会持有这个互斥锁, 所以在用户空间可以放心的在多个线程\n     * 中同时执行epoll相关的操作, 内核级已经做了保护. */\n    struct mutex mtx;\n    /* Wait queue used by sys_epoll_wait() */\n    /* 调用epoll_wait()时, 我们就是\"睡\"在了这个等待队列上... */\n    wait_queue_head_t wq;\n    /* Wait queue used by file-&gt;poll() */\n    /* 这个用于epollfd本事被poll的时候... */\n    wait_queue_head_t poll_wait;\n    /* List of ready file descriptors */\n    /* 所有已经ready的epitem都在这个链表里面 */\n    struct list_head rdllist;\n    /* RB tree root used to store monitored fd structs */\n    /* 所有要监听的epitem都在这里 */\n    struct rb_root rbr;\n    /*\n        这是一个单链表链接着所有的struct epitem当event转移到用户空间时\n     */\n     * This is a single linked list that chains all the \"struct epitem\" that\n     * happened while transfering ready events to userspace w/out\n     * holding -&gt;lock.\n     */\n    struct epitem *ovflist;\n    /* The user that created the eventpoll descriptor */\n    /* 这里保存了一些用户变量, 比如fd监听数量的最大值等等 */\n    struct user_struct *user;\n};\n/*\n * Each file descriptor added to the eventpoll interface will\n * have an entry of this type linked to the \"rbr\" RB tree.\n */\n/* epitem 表示一个被监听的fd */\nstruct epitem {\n    /* RB tree node used to link this structure to the eventpoll RB tree */\n    /* rb_node, 当使用epoll_ctl()将一批fds加入到某个epollfd时, 内核会分配\n     * 一批的epitem与fds们对应, 而且它们以rb_tree的形式组织起来, tree的root\n     * 保存在epollfd, 也就是struct eventpoll中. \n     * 在这里使用rb_tree的原因我认为是提高查找,插入以及删除的速度.\n     * rb_tree对以上3个操作都具有O(lgN)的时间复杂度 */\n    struct rb_node rbn;\n    /* List header used to link this structure to the eventpoll ready list */\n    /* 链表节点, 所有已经ready的epitem都会被链到eventpoll的rdllist中 */\n    struct list_head rdllink;\n    /*\n     * Works together \"struct eventpoll\"-&gt;ovflist in keeping the\n     * single linked chain of items.\n     */\n    /* 这个在代码中再解释... */\n    struct epitem *next;\n    /* The file descriptor information this item refers to */\n    /* epitem对应的fd和struct file */\n    struct epoll_filefd ffd;\n    /* Number of active wait queue attached to poll operations */\n    int nwait;\n    /* List containing poll wait queues */\n    struct list_head pwqlist;\n    /* The \"container\" of this item */\n    /* 当前epitem属于哪个eventpoll */\n    struct eventpoll *ep;\n    /* List header used to link this item to the \"struct file\" items list */\n    struct list_head fllink;\n    /* The structure that describe the interested events and the source fd */\n    /* 当前的epitem关系哪些events, 这个数据是调用epoll_ctl时从用户态传递过来 */\n    struct epoll_event event;\n};\nstruct epoll_filefd {\n    struct file *file;\n    int fd;\n};\n/* poll所用到的钩子Wait structure used by the poll hooks */\nstruct eppoll_entry {\n    /* List header used to link this structure to the \"struct epitem\" */\n    struct list_head llink;\n    /* The \"base\" pointer is set to the container \"struct epitem\" */\n    struct epitem *base;\n    /*\n     * Wait queue item that will be linked to the target file wait\n     * queue head.\n     */\n    wait_queue_t wait;\n    /* The wait queue head that linked the \"wait\" wait queue item */\n    wait_queue_head_t *whead;\n};\n/* Wrapper struct used by poll queueing */\nstruct ep_pqueue {\n    poll_table pt;\n    struct epitem *epi;\n};\n/* Used by the ep_send_events() function as callback private data */\nstruct ep_send_events_data {\n    int maxevents;\n    struct epoll_event __user *events;\n};\n \n/* --- 代码注释 --- */\n/* 你没看错, 这就是epoll_create()的真身, 基本啥也不干直接调用epoll_create1了,\n * 另外你也可以发现, size这个参数其实是没有任何用处的... */\nSYSCALL_DEFINE1(epoll_create, int, size)\n{\n        if (size &lt;= 0)\n                return -EINVAL;\n        return sys_epoll_create1(0);\n}\n/* 这才是真正的epoll_create啊~~ */\nSYSCALL_DEFINE1(epoll_create1, int, flags)\n{\n    int error;\n    struct eventpoll *ep = NULL;//主描述符\n    /* Check the EPOLL_* constant for consistency.  */\n    /* 这句没啥用处... */\n    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);\n    /* 对于epoll来讲, 目前唯一有效的FLAG就是CLOEXEC */\n    if (flags &amp; ~EPOLL_CLOEXEC)\n        return -EINVAL;\n    /*\n     * Create the internal data structure (\"struct eventpoll\").\n     */\n    /* 分配一个struct eventpoll, 分配和初始化细节我们随后深聊~ */\n    error = ep_alloc(&amp;ep);\n    if (error &lt; 0)\n        return error;\n    /*\n     * Creates all the items needed to setup an eventpoll file. That is,\n     * a file structure and a free file descriptor.\n     */\n    /* 这里是创建一个匿名fd, 说起来就话长了...长话短说:\n     * epollfd本身并不存在一个真正的文件与之对应, 所以内核需要创建一个\n     * \"虚拟\"的文件, 并为之分配真正的struct file结构, 而且有真正的fd.\n     * 这里2个参数比较关键:\n     * eventpoll_fops, fops就是file operations, 就是当你对这个文件(这里是虚拟的)进行操作(比如读)时,\n     * fops里面的函数指针指向真正的操作实现, 类似C++里面虚函数和子类的概念.\n     * epoll只实现了poll和release(就是close)操作, 其它文件系统操作都有VFS全权处理了.\n     * ep, ep就是struct epollevent, 它会作为一个私有数据保存在struct file的private指针里面.\n     * 其实说白了, 就是为了能通过fd找到struct file, 通过struct file能找到eventpoll结构.\n     * 如果懂一点Linux下字符设备驱动开发, 这里应该是很好理解的,\n     * 推荐阅读 &lt;Linux device driver 3rd&gt;\n     */\n    error = anon_inode_getfd(\"[eventpoll]\", &amp;eventpoll_fops, ep,\n                 O_RDWR | (flags &amp; O_CLOEXEC));\n    if (error &lt; 0)\n        ep_free(ep);\n    return error;\n}\n/* \n* 创建好epollfd后, 接下来我们要往里面添加fd咯\n* 来看epoll_ctl\n* epfd 就是epollfd\n* op ADD,MOD,DEL\n* fd 需要监听的描述符\n* event 我们关心的events\n*/\nSYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n        struct epoll_event __user *, event)\n{\n    int error;\n    struct file *file, *tfile;\n    struct eventpoll *ep;\n    struct epitem *epi;\n    struct epoll_event epds;\n    error = -EFAULT;\n    /* \n     * 错误处理以及从用户空间将epoll_event结构copy到内核空间.\n     */\n    if (ep_op_has_event(op) &amp;&amp;\n        copy_from_user(&amp;epds, event, sizeof(struct epoll_event)))\n        goto error_return;\n    /* Get the \"struct file *\" for the eventpoll file */\n    /* 取得struct file结构, epfd既然是真正的fd, 那么内核空间\n     * 就会有与之对于的一个struct file结构\n     * 这个结构在epoll_create1()中, 由函数anon_inode_getfd()分配 */\n    error = -EBADF;\n    file = fget(epfd);\n    if (!file)\n        goto error_return;\n    /* Get the \"struct file *\" for the target file */\n    /* 我们需要监听的fd, 它当然也有个struct file结构, 上下2个不要搞混了哦 */\n    tfile = fget(fd);\n    if (!tfile)\n        goto error_fput;\n    /* The target file descriptor must support poll */\n    error = -EPERM;\n    /* 如果监听的文件不支持poll, 那就没辙了.\n     * 你知道什么情况下, 文件会不支持poll吗?\n     */\n    if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)\n        goto error_tgt_fput;\n    /*\n     * We have to check that the file structure underneath the file descriptor\n     * the user passed to us _is_ an eventpoll file. And also we do not permit\n     * adding an epoll file descriptor inside itself.\n     */\n    error = -EINVAL;\n    /* epoll不能自己监听自己... */\n    if (file == tfile || !is_file_epoll(file))\n        goto error_tgt_fput;\n    /*\n     * At this point it is safe to assume that the \"private_data\" contains\n     * our own data structure.\n     */\n    /* 取到我们的eventpoll结构, 来自与epoll_create1()中的分配 */\n    ep = file-&gt;private_data;\n    /* 接下来的操作有可能修改数据结构内容, 锁之~ */\n    mutex_lock(&amp;ep-&gt;mtx);\n    /*\n     * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n     * above, we can be sure to be able to use the item looked up by\n     * ep_find() till we release the mutex.\n     */\n    /* 对于每一个监听的fd, 内核都有分配一个epitem结构,\n     * 而且我们也知道, epoll是不允许重复添加fd的,\n     * 所以我们首先查找该fd是不是已经存在了.\n     * ep_find()其实就是RBTREE查找, 跟C++STL的map差不多一回事, O(lgn)的时间复杂度.\n     */\n    epi = ep_find(ep, tfile, fd);\n    error = -EINVAL;\n    switch (op) {\n        /* 首先我们关心添加 */\n    case EPOLL_CTL_ADD:\n        if (!epi) {\n            /* 之前的find没有找到有效的epitem, 证明是第一次插入, 接受!\n             * 这里我们可以知道, POLLERR和POLLHUP事件内核总是会关心的\n             * */\n            epds.events |= POLLERR | POLLHUP;\n            /* rbtree插入, 详情见ep_insert()的分析\n             * 其实我觉得这里有insert的话, 之前的find应该\n             * 是可以省掉的... */\n            error = ep_insert(ep, &amp;epds, tfile, fd);\n        } else\n            /* 找到了!? 重复添加! */\n            error = -EEXIST;\n        break;\n        /* 删除和修改操作都比较简单 */\n    case EPOLL_CTL_DEL:\n        if (epi)\n            error = ep_remove(ep, epi);\n        else\n            error = -ENOENT;\n        break;\n    case EPOLL_CTL_MOD:\n        if (epi) {\n            epds.events |= POLLERR | POLLHUP;\n            error = ep_modify(ep, epi, &amp;epds);\n        } else\n            error = -ENOENT;\n        break;\n    }\n    mutex_unlock(&amp;ep-&gt;mtx);\nerror_tgt_fput:\n    fput(tfile);\nerror_fput:\n    fput(file);\nerror_return:\n    return error;\n}\n/* 分配一个eventpoll结构 */\nstatic int ep_alloc(struct eventpoll **pep)\n{\n    int error;\n    struct user_struct *user;\n    struct eventpoll *ep;\n    /* 获取当前用户的一些信息, 比如是不是root啦, 最大监听fd数目啦 */\n    user = get_current_user();\n    error = -ENOMEM;\n    ep = kzalloc(sizeof(*ep), GFP_KERNEL);\n    if (unlikely(!ep))\n        goto free_uid;\n    /* 这些都是初始化啦 */\n    spin_lock_init(&amp;ep-&gt;lock);\n    mutex_init(&amp;ep-&gt;mtx);\n    init_waitqueue_head(&amp;ep-&gt;wq);//初始化自己睡在的等待队列\n    init_waitqueue_head(&amp;ep-&gt;poll_wait);//初始化\n    INIT_LIST_HEAD(&amp;ep-&gt;rdllist);//初始化就绪链表\n    ep-&gt;rbr = RB_ROOT;\n    ep-&gt;ovflist = EP_UNACTIVE_PTR;\n    ep-&gt;user = user;\n    *pep = ep;\n    return 0;\nfree_uid:\n    free_uid(user);\n    return error;\n}\n/*\n * Must be called with \"mtx\" held.\n */\n/* \n * ep_insert()在epoll_ctl()中被调用, 完成往epollfd里面添加一个监听fd的工作\n * tfile是fd在内核态的struct file结构\n */\nstatic int ep_insert(struct eventpoll *ep, struct epoll_event *event,\n             struct file *tfile, int fd)\n{\n    int error, revents, pwake = 0;\n    unsigned long flags;\n    struct epitem *epi;\n    struct ep_pqueue epq;\n    /* 查看是否达到当前用户的最大监听数 */\n    if (unlikely(atomic_read(&amp;ep-&gt;user-&gt;epoll_watches) &gt;=\n             max_user_watches))\n        return -ENOSPC;\n    /* 从著名的slab中分配一个epitem */\n    if (!(epi = kmem_***_alloc(epi_***, GFP_KERNEL)))\n        return -ENOMEM;\n    /* Item initialization follow here ... */\n    /* 这些都是相关成员的初始化... */\n    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);\n    INIT_LIST_HEAD(&amp;epi-&gt;fllink);\n    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);\n    epi-&gt;ep = ep;\n    /* 这里保存了我们需要监听的文件fd和它的file结构 */\n    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);\n    epi-&gt;event = *event;\n    epi-&gt;nwait = 0;\n    /* 这个指针的初值不是NULL哦... */\n    epi-&gt;next = EP_UNACTIVE_PTR;\n    /* Initialize the poll table using the queue callback */\n    /* 好, 我们终于要进入到poll的正题了 */\n    epq.epi = epi;\n    /* 初始化一个poll_table\n     * 其实就是指定调用poll_wait(注意不是epoll_wait!!!)时的回调函数,和我们关心哪些events,\n     * ep_ptable_queue_proc()就是我们的回调啦, 初值是所有event都关心 */\n    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);\n    /*\n     * Attach the item to the poll hooks and get current event bits.\n     * We can safely use the file* here because its usage count has\n     * been increased by the caller of this function. Note that after\n     * this operation completes, the poll callback can start hitting\n     * the new item.\n     */\n    /* 这一部很关键, 也比较难懂, 完全是内核的poll机制导致的...\n     * 首先, f_op-&gt;poll()一般来说只是个wrapper, 它会调用真正的poll实现,\n     * 拿UDP的socket来举例, 这里就是这样的调用流程: f_op-&gt;poll(), sock_poll(),\n     * udp_poll(), datagram_poll(), sock_poll_wait(), 最后调用到我们上面指定的\n     * ep_ptable_queue_proc()这个回调函数...(好深的调用路径...).\n     * 完成这一步, 我们的epitem就跟这个socket关联起来了, 当它有状态变化时,\n     * 会通过ep_poll_callback()来通知.\n     * 最后, 这个函数还会查询当前的fd是不是已经有啥event已经ready了, 有的话\n     * 会将event返回. */\n    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);\n    /*\n     * We have to check if something went wrong during the poll wait queue\n     * install process. Namely an allocation for a wait queue failed due\n     * high memory pressure.\n     */\n    error = -ENOMEM;\n    if (epi-&gt;nwait &lt; 0)\n        goto error_unregister;\n    /* Add the current item to the list of active epoll hook for this file */\n    /* 这个就是每个文件会将所有监听自己的epitem链起来 */\n    spin_lock(&amp;tfile-&gt;f_lock);\n    list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);\n    spin_unlock(&amp;tfile-&gt;f_lock);\n    /*\n     * Add the current item to the RB tree. All RB tree operations are\n     * protected by \"mtx\", and ep_insert() is called with \"mtx\" held.\n     */\n    /* 都搞定后, 将epitem插入到对应的eventpoll中去 */\n    ep_rbtree_insert(ep, epi);\n    /* We have to drop the new item inside our item list to keep track of it */\n    spin_lock_irqsave(&amp;ep-&gt;lock, flags);\n    /* If the file is already \"ready\" we drop it inside the ready list */\n    /* 到达这里后, 如果我们监听的fd已经有事件发生, 那就要处理一下 */\n    if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) {\n        /* 将当前的epitem加入到ready list中去 */\n        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);\n        /* Notify waiting tasks that events are available */\n        /* 谁在epoll_wait, 就唤醒它... */\n        if (waitqueue_active(&amp;ep-&gt;wq))\n            wake_up_locked(&amp;ep-&gt;wq);\n        /* 谁在epoll当前的epollfd, 也唤醒它... */\n        if (waitqueue_active(&amp;ep-&gt;poll_wait))\n            pwake++;\n    }\n    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n    atomic_inc(&amp;ep-&gt;user-&gt;epoll_watches);\n    /* We have to call this outside the lock */\n    if (pwake)\n        ep_poll_safewake(&amp;ep-&gt;poll_wait);\n    return 0;\nerror_unregister:\n    ep_unregister_pollwait(ep, epi);\n    /*\n     * We need to do this because an event could have been arrived on some\n     * allocated wait queue. Note that we don\'t care about the ep-&gt;ovflist\n     * list, since that is used/cleaned only inside a section bound by \"mtx\".\n     * And ep_insert() is called with \"mtx\" held.\n     */\n    spin_lock_irqsave(&amp;ep-&gt;lock, flags);\n    if (ep_is_linked(&amp;epi-&gt;rdllink))\n        list_del_init(&amp;epi-&gt;rdllink);\n    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n    kmem_***_free(epi_***, epi);\n    return error;\n}\n/*\n * This is the callback that is used to add our wait queue to the\n * target file wakeup lists.\n */\n/* \n * 该函数在调用f_op-&gt;poll()时会被调用.\n * 也就是epoll主动poll某个fd时, 用来将epitem与指定的fd关联起来的.\n * 关联的办法就是使用等待队列(waitqueue)\n */\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n                 poll_table *pt)\n{\n    struct epitem *epi = ep_item_from_epqueue(pt);\n    struct eppoll_entry *pwq;\n    if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_***_alloc(pwq_***, GFP_KERNEL))) {\n        /* 初始化等待队列, 指定ep_poll_callback为唤醒时的回调函数,\n         * 当我们监听的fd发生状态改变时, 也就是队列头被唤醒时,\n         * 指定的回调函数将会被调用. */\n        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);\n        pwq-&gt;whead = whead;\n        pwq-&gt;base = epi;\n        /* 将刚分配的等待队列成员加入到头中, 头是由fd持有的 */\n        add_wait_queue(whead, &amp;pwq-&gt;wait);\n        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);\n        /* nwait记录了当前epitem加入到了多少个等待队列中,\n         * 我认为这个值最大也只会是1... */\n        epi-&gt;nwait++;\n    } else {\n        /* We have to signal that an error occurred */\n        epi-&gt;nwait = -1;\n    }\n}\n/*\n * This is the callback that is passed to the wait queue wakeup\n * machanism. It is called by the stored file descriptors when they\n * have events to report.\n */\n/* \n * 这个是关键性的回调函数, 当我们监听的fd发生状态改变时, 它会被调用.\n * 参数key被当作一个unsigned long整数使用, 携带的是events.\n */\nstatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n    int pwake = 0;\n    unsigned long flags;\n    struct epitem *epi = ep_item_from_wait(wait);//从等待队列获取epitem.需要知道哪个进程挂载到这个设备\n    struct eventpoll *ep = epi-&gt;ep;//获取\n    spin_lock_irqsave(&amp;ep-&gt;lock, flags);\n    /*\n     * If the event mask does not contain any poll(2) event, we consider the\n     * descriptor to be disabled. This condition is likely the effect of the\n     * EPOLLONESHOT bit that disables the descriptor when an event is received,\n     * until the next EPOLL_CTL_MOD will be issued.\n     */\n    if (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))\n        goto out_unlock;\n    /*\n     * Check the events coming with the callback. At this stage, not\n     * every device reports the events in the \"key\" parameter of the\n     * callback. We need to be able to handle both cases here, hence the\n     * test for \"key\" != NULL before the event match test.\n     */\n    /* 没有我们关心的event... */\n    if (key &amp;&amp; !((unsigned long) key &amp; epi-&gt;event.events))\n        goto out_unlock;\n    /*\n     * If we are trasfering events to userspace, we can hold no locks\n     * (because we\'re accessing user memory, and because of linux f_op-&gt;poll()\n     * semantics). All the events that happens during that period of time are\n     * chained in ep-&gt;ovflist and requeued later on.\n     */\n    /* \n     * 这里看起来可能有点费解, 其实干的事情比较简单:\n     * 如果该callback被调用的同时, epoll_wait()已经返回了,\n     * 也就是说, 此刻应用程序有可能已经在循环获取events,\n     * 这种情况下, 内核将此刻发生event的epitem用一个单独的链表\n     * 链起来, 不发给应用程序, 也不丢弃, 而是在下一次epoll_wait\n     * 时返回给用户.\n     */\n    if (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) {\n        if (epi-&gt;next == EP_UNACTIVE_PTR) {\n            epi-&gt;next = ep-&gt;ovflist;\n            ep-&gt;ovflist = epi;\n        }\n        goto out_unlock;\n    }\n    /* If this file is already in the ready list we exit soon */\n    /* 将当前的epitem放入ready list */\n    if (!ep_is_linked(&amp;epi-&gt;rdllink))\n        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);\n    /*\n     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()\n     * wait list.\n     */\n    /* 唤醒epoll_wait... */\n    if (waitqueue_active(&amp;ep-&gt;wq))\n        wake_up_locked(&amp;ep-&gt;wq);\n    /* 如果epollfd也在被poll, 那就唤醒队列里面的所有成员. */\n    if (waitqueue_active(&amp;ep-&gt;poll_wait))\n        pwake++;\nout_unlock:\n    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n    /* We have to call this outside the lock */\n    if (pwake)\n        ep_poll_safewake(&amp;ep-&gt;poll_wait);\n    return 1;\n}\n/*\n * Implement the event wait interface for the eventpoll file. It is the kernel\n * part of the user space epoll_wait(2).\n */\nSYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,\n        int, maxevents, int, timeout)\n{\n    int error;\n    struct file *file;\n    struct eventpoll *ep;\n    /* The maximum number of event must be greater than zero */\n    if (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS)\n        return -EINVAL;\n    /* Verify that the area passed by the user is writeable */\n    /* 这个地方有必要说明一下:\n     * 内核对应用程序采取的策略是\"绝对不信任\",\n     * 所以内核跟应用程序之间的数据交互大都是copy, 不允许(也时候也是不能...)指针引用.\n     * epoll_wait()需要内核返回数据给用户空间, 内存由用户程序提供,\n     * 所以内核会用一些手段来验证这一段内存空间是不是有效的.\n     */\n    if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) {\n        error = -EFAULT;\n        goto error_return;\n    }\n    /* Get the \"struct file *\" for the eventpoll file */\n    error = -EBADF;\n    /* 获取epollfd的struct file, epollfd也是文件嘛 */\n    file = fget(epfd);\n    if (!file)\n        goto error_return;\n    /*\n     * We have to check that the file structure underneath the fd\n     * the user passed to us _is_ an eventpoll file.\n     */\n    error = -EINVAL;\n    /* 检查一下它是不是一个真正的epollfd... */\n    if (!is_file_epoll(file))\n        goto error_fput;\n    /*\n     * At this point it is safe to assume that the \"private_data\" contains\n     * our own data structure.\n     */\n    /* 获取eventpoll结构 */\n    ep = file-&gt;private_data;\n    /* Time to fish for events ... */\n    /* OK, 睡觉, 等待事件到来~~ */\n    error = ep_poll(ep, events, maxevents, timeout);\nerror_fput:\n    fput(file);\nerror_return:\n    return error;\n}\n/* 这个函数真正将执行epoll_wait的进程带入睡眠状态... */\nstatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n           int maxevents, long timeout)\n{\n    int res, eavail;\n    unsigned long flags;\n    long jtimeout;\n    wait_queue_t wait;//等待队列\n    /*\n     * Calculate the timeout by checking for the \"infinite\" value (-1)\n     * and the overflow condition. The passed timeout is in milliseconds,\n     * that why (t * HZ) / 1000.\n     */\n    /* 计算睡觉时间, 毫秒要转换为HZ */\n    jtimeout = (timeout &lt; 0 || timeout &gt;= EP_MAX_MSTIMEO) ?\n        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;\nretry:\n    spin_lock_irqsave(&amp;ep-&gt;lock, flags);\n    res = 0;\n    /* 如果ready list不为空, 就不睡了, 直接干活... */\n    if (list_empty(&amp;ep-&gt;rdllist)) {\n        /*\n         * We don\'t have any available event to return to the caller.\n         * We need to sleep here, and we will be wake up by\n         * ep_poll_callback() when events will become available.\n         */\n        /* OK, 初始化一个等待队列, 准备直接把自己挂起,\n         * 注意current是一个宏, 代表当前进程 */\n        init_waitqueue_entry(&amp;wait, current);//初始化等待队列,wait表示当前进程\n        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);//挂载到ep结构的等待队列\n        for (;;) {\n            /*\n             * We don\'t want to sleep if the ep_poll_callback() sends us\n             * a wakeup in between. That\'s why we set the task state\n             * to TASK_INTERRUPTIBLE before doing the checks.\n             */\n            /* 将当前进程设置位睡眠, 但是可以被信号唤醒的状态,\n             * 注意这个设置是\"将来时\", 我们此刻还没睡! */\n            set_current_state(TASK_INTERRUPTIBLE);\n            /* 如果这个时候, ready list里面有成员了,\n             * 或者睡眠时间已经过了, 就直接不睡了... */\n            if (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)\n                break;\n            /* 如果有信号产生, 也起床... */\n            if (signal_pending(current)) {\n                res = -EINTR;\n                break;\n            }\n            /* 啥事都没有,解锁, 睡觉... */\n            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n            /* jtimeout这个时间后, 会被唤醒,\n             * ep_poll_callback()如果此时被调用,\n             * 那么我们就会直接被唤醒, 不用等时间了... \n             * 再次强调一下ep_poll_callback()的调用时机是由被监听的fd\n             * 的具体实现, 比如socket或者某个设备驱动来决定的,\n             * 因为等待队列头是他们持有的, epoll和当前进程\n             * 只是单纯的等待...\n             **/\n            jtimeout = schedule_timeout(jtimeout);//睡觉\n            spin_lock_irqsave(&amp;ep-&gt;lock, flags);\n        }\n        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);\n        /* OK 我们醒来了... */\n        set_current_state(TASK_RUNNING);\n    }\n    /* Is it worth to try to dig for events ? */\n    eavail = !list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;\n    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n    /*\n     * Try to transfer events to user space. In case we get 0 events and\n     * there\'s still timeout left over, we go trying again in search of\n     * more luck.\n     */\n    /* 如果一切正常, 有event发生, 就开始准备数据copy给用户空间了... */\n    if (!res &amp;&amp; eavail &amp;&amp;\n        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)\n        goto retry;\n    return res;\n}\n/* 这个简单, 我们直奔下一个... */\nstatic int ep_send_events(struct eventpoll *ep,\n              struct epoll_event __user *events, int maxevents)\n{\n    struct ep_send_events_data esed;\n    esed.maxevents = maxevents;\n    esed.events = events;\n    return ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed);\n}\n/**\n * ep_scan_ready_list - Scans the ready list in a way that makes possible for\n *                      the scan code, to call f_op-&gt;poll(). Also allows for\n *                      O(NumReady) performance.\n *\n * @ep: Pointer to the epoll private data structure.\n * @sproc: Pointer to the scan callback.\n * @priv: Private opaque data passed to the @sproc callback.\n *\n * Returns: The same integer error code returned by the @sproc callback.\n */\nstatic int ep_scan_ready_list(struct eventpoll *ep,\n                  int (*sproc)(struct eventpoll *,\n                       struct list_head *, void *),\n                  void *priv)\n{\n    int error, pwake = 0;\n    unsigned long flags;\n    struct epitem *epi, *nepi;\n    LIST_HEAD(txlist);\n    /*\n     * We need to lock this because we could be hit by\n     * eventpoll_release_file() and epoll_ctl().\n     */\n    mutex_lock(&amp;ep-&gt;mtx);\n    /*\n     * Steal the ready list, and re-init the original one to the\n     * empty list. Also, set ep-&gt;ovflist to NULL so that events\n     * happening while looping w/out locks, are not lost. We cannot\n     * have the poll callback to queue directly on ep-&gt;rdllist,\n     * because we want the \"sproc\" callback to be able to do it\n     * in a lockless way.\n     */\n    spin_lock_irqsave(&amp;ep-&gt;lock, flags);\n    /* 这一步要注意, 首先, 所有监听到events的epitem都链到rdllist上了,\n     * 但是这一步之后, 所有的epitem都转移到了txlist上, 而rdllist被清空了,\n     * 要注意哦, rdllist已经被清空了! */\n    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);\n    /* ovflist, 在ep_poll_callback()里面我解释过, 此时此刻我们不希望\n     * 有新的event加入到ready list中了, 保存后下次再处理... */\n    ep-&gt;ovflist = NULL;\n    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n    /*\n     * Now call the callback function.\n     */\n    /* 在这个回调函数里面处理每个epitem\n     * sproc 就是 ep_send_events_proc, 下面会注释到. */\n    error = (*sproc)(ep, &amp;txlist, priv);\n    spin_lock_irqsave(&amp;ep-&gt;lock, flags);\n    /*\n     * During the time we spent inside the \"sproc\" callback, some\n     * other events might have been queued by the poll callback.\n     * We re-insert them inside the main ready-list here.\n     */\n    /* 现在我们来处理ovflist, 这些epitem都是我们在传递数据给用户空间时\n     * 监听到了事件. */\n    for (nepi = ep-&gt;ovflist; (epi = nepi) != NULL;\n         nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) {\n        /*\n         * We need to check if the item is already in the list.\n         * During the \"sproc\" callback execution time, items are\n         * queued into -&gt;ovflist but the \"txlist\" might already\n         * contain them, and the list_splice() below takes care of them.\n         */\n        /* 将这些直接放入readylist */\n        if (!ep_is_linked(&amp;epi-&gt;rdllink))\n            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);\n    }\n    /*\n     * We need to set back ep-&gt;ovflist to EP_UNACTIVE_PTR, so that after\n     * releasing the lock, events will be queued in the normal way inside\n     * ep-&gt;rdllist.\n     */\n    ep-&gt;ovflist = EP_UNACTIVE_PTR;\n    /*\n     * Quickly re-inject items left on \"txlist\".\n     */\n    /* 上一次没有处理完的epitem, 重新插入到ready list */\n    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);\n    /* ready list不为空, 直接唤醒... */\n    if (!list_empty(&amp;ep-&gt;rdllist)) {\n        /*\n         * Wake up (if active) both the eventpoll wait list and\n         * the -&gt;poll() wait list (delayed after we release the lock).\n         */\n        if (waitqueue_active(&amp;ep-&gt;wq))\n            wake_up_locked(&amp;ep-&gt;wq);\n        if (waitqueue_active(&amp;ep-&gt;poll_wait))\n            pwake++;\n    }\n    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);\n    mutex_unlock(&amp;ep-&gt;mtx);\n    /* We have to call this outside the lock */\n    if (pwake)\n        ep_poll_safewake(&amp;ep-&gt;poll_wait);\n    return error;\n}\n/* 该函数作为callbakc在ep_scan_ready_list()中被调用\n * head是一个链表, 包含了已经ready的epitem,\n * 这个不是eventpoll里面的ready list, 而是上面函数中的txlist.\n */\nstatic int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,\n                   void *priv)\n{\n    struct ep_send_events_data *esed = priv;\n    int eventcnt;\n    unsigned int revents;\n    struct epitem *epi;\n    struct epoll_event __user *uevent;\n    /*\n     * We can loop without lock because we are passed a task private list.\n     * Items cannot vanish during the loop because ep_scan_ready_list() is\n     * holding \"mtx\" during this call.\n     */\n    /* 扫描整个链表... */\n    for (eventcnt = 0, uevent = esed-&gt;events;\n         !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) {\n        /* 取出第一个成员 */\n        epi = list_first_entry(head, struct epitem, rdllink);\n        /* 然后从链表里面移除 */\n        list_del_init(&amp;epi-&gt;rdllink);\n        /* 读取events, \n         * 注意events我们ep_poll_callback()里面已经取过一次了, 为啥还要再取?\n         * 1. 我们当然希望能拿到此刻的最新数据, events是会变的~\n         * 2. 不是所有的poll实现, 都通过等待队列传递了events, 有可能某些驱动压根没传\n         * 必须主动去读取. */\n        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL) &amp;\n            epi-&gt;event.events;\n        if (revents) {\n            /* 将当前的事件和用户传入的数据都copy给用户空间,\n             * 就是epoll_wait()后应用程序能读到的那一堆数据. */\n            if (__put_user(revents, &amp;uevent-&gt;events) ||\n                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) {\n                list_add(&amp;epi-&gt;rdllink, head);\n                return eventcnt ? eventcnt : -EFAULT;\n            }\n            eventcnt++;\n            uevent++;\n            if (epi-&gt;event.events &amp; EPOLLONESHOT)\n                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;\n            else if (!(epi-&gt;event.events &amp; EPOLLET)) {\n                /* 嘿嘿, EPOLLET和非ET的区别就在这一步之差呀~\n                 * 如果是ET, epitem是不会再进入到readly list,\n                 * 除非fd再次发生了状态改变, ep_poll_callback被调用.\n                 * 如果是非ET, 不管你还有没有有效的事件或者数据,\n                 * 都会被重新插入到ready list, 再下一次epoll_wait\n                 * 时, 会立即返回, 并通知给用户空间. 当然如果这个\n                 * 被监听的fds确实没事件也没数据了, epoll_wait会返回一个0,\n                 * 空转一次.\n                 */\n                list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);\n            }\n        }\n    }\n    return eventcnt;\n}\n/* ep_free在epollfd被close时调用,\n * 释放一些资源而已, 比较简单 */\nstatic void ep_free(struct eventpoll *ep)\n{\n    struct rb_node *rbp;\n    struct epitem *epi;\n    /* We need to release all tasks waiting for these file */\n    if (waitqueue_active(&amp;ep-&gt;poll_wait))\n        ep_poll_safewake(&amp;ep-&gt;poll_wait);\n    /*\n     * We need to lock this because we could be hit by\n     * eventpoll_release_file() while we\'re freeing the \"struct eventpoll\".\n     * We do not need to hold \"ep-&gt;mtx\" here because the epoll file\n     * is on the way to be removed and no one has references to it\n     * anymore. The only hit might come from eventpoll_release_file() but\n     * holding \"epmutex\" is sufficent here.\n     */\n    mutex_lock(&amp;epmutex);\n    /*\n     * Walks through the whole tree by unregistering poll callbacks.\n     */\n    for (rbp = rb_first(&amp;ep-&gt;rbr); rbp; rbp = rb_next(rbp)) {\n        epi = rb_entry(rbp, struct epitem, rbn);\n        ep_unregister_pollwait(ep, epi);\n    }\n    /*\n     * Walks through the whole tree by freeing each \"struct epitem\". At this\n     * point we are sure no poll callbacks will be lingering around, and also by\n     * holding \"epmutex\" we can be sure that no file cleanup code will hit\n     * us during this operation. So we can avoid the lock on \"ep-&gt;lock\".\n     */\n    /* 之所以在关闭epollfd之前不需要调用epoll_ctl移除已经添加的fd,\n     * 是因为这里已经做了... */\n    while ((rbp = rb_first(&amp;ep-&gt;rbr)) != NULL) {\n        epi = rb_entry(rbp, struct epitem, rbn);\n        ep_remove(ep, epi);\n    }\n    mutex_unlock(&amp;epmutex);\n    mutex_destroy(&amp;ep-&gt;mtx);\n    free_uid(ep-&gt;user);\n    kfree(ep);\n}\n/* File callbacks that implement the eventpoll file behaviour */\nstatic const struct file_operations eventpoll_fops = {\n    .release    = ep_eventpoll_release,\n    .poll       = ep_eventpoll_poll\n};\n/* Fast test to see if the file is an evenpoll file */\nstatic inline int is_file_epoll(struct file *f)\n{\n    return f-&gt;f_op == &amp;eventpoll_fops;\n}\n/* OK, eventpoll我认为比较重要的函数都注释完了... */<br /></code></pre>\n\n<p>epoll_create<br /></p>\n\n<p>从slab缓存中创建一个eventpoll对象,并且创建一个匿名的fd跟fd对应的file对象,</p>\n\n<p>而eventpoll对象保存在struct file结构的private指针中,并且返回,</p>\n\n<p>该fd对应的file operations只是实现了poll跟release操作</p>\n\n<p><br /><br /></p>\n\n<p>创建eventpoll对象的初始化操作</p>\n\n<p>获取当前用户信息,是不是root,最大监听fd数目等并且保存到eventpoll对象中</p>\n\n<p>初始化等待队列,初始化就绪链表,初始化红黑树的头结点</p>\n\n<p><br /><br /></p>\n\n<p>epoll_ctl操作</p>\n\n<p>将epoll_event结构拷贝到内核空间中</p>\n\n<p>并且判断加入的fd是否支持poll结构(epoll,poll,selectI/O多路复用必须支持poll操作).</p>\n\n<p>并且从epfd-&gt;file-&gt;privatedata获取event_poll对象,根据op区分是添加删除还是修改,</p>\n\n<p>首先在eventpoll结构中的红黑树查找是否已经存在了相对应的fd,没找到就支持插入操作,否则报重复的错误.</p>\n\n<p>相对应的修改,删除比较简单就不啰嗦了</p>\n\n<p><br /><br /></p>\n\n<p>插入操作时,会创建一个与fd对应的epitem结构,并且初始化相关成员,比如保存监听的fd跟file结构之类的</p>\n\n<p>重要的是指定了调用poll_wait时的回调函数用于数据就绪时唤醒进程,(其内部,初始化设备的等待队列,将该进程注册到等待队列)完成这一步, 我们的epitem就跟这个socket关联起来了, 当它有状态变化时,</p>\n\n<p>会通过ep_poll_callback()来通知.</p>\n\n<p>最后调用加入的fd的file operation-&gt;poll函数(最后会调用poll_wait操作)用于完成注册操作.</p>\n\n<p>最后将epitem结构添加到红黑树中</p>\n\n<p><br /><br /></p>\n\n<p>epoll_wait操作</p>\n\n<p>计算睡眠时间(如果有),判断eventpoll对象的链表是否为空,不为空那就干活不睡明.并且初始化一个等待队列,把自己挂上去,设置自己的进程状态</p>\n\n<p>为可睡眠状态.判断是否有信号到来(有的话直接被中断醒来,),如果啥事都没有那就调用schedule_timeout进行睡眠,如果超时或者被唤醒,首先从自己初始化的等待队列删除</p>\n\n<p>,然后开始拷贝资源给用户空间了</p>\n\n<p>拷贝资源则是先把就绪事件链表转移到中间链表,然后挨个遍历拷贝到用户空间,</p>\n\n<p>并且挨个判断其是否为水平触发,是的话再次插入到就绪链表</p>',2,2,0,1,0,0,1,'2020-05-03 14:22:09','2020-05-13 18:54:43'),(5,'技术道路分享｜前端方向','岗位方向：前端 学习经验分享： 1、为什么选择了这个方向？ 机缘巧合开始做web开发，最后发现是兴趣所在。大二的时候开始跟着老师做一个Java Web的项目，技术栈非常老，就是传统的jsp那一套，做的不亦乐乎，也让我走...','technology-road-sharing-front-end-direction','<p>岗位方向：前端<br /></p>\n\n<h3>学习经验分享：</h3>\n\n<h4>1、为什么选择了这个方向？</h4>\n\n<p>机缘巧合开始做web开发，最后发现是兴趣所在。<br />大二的时候开始跟着老师做一个Java Web的项目，技术栈非常老，就是传统的jsp那一套，做的不亦乐乎，也让我走进了web开发的大门，那个时候既要用jQ和Bootstrap写前端，还要用Java写后台实现，后来两个方向都有所深入，前端开始用nodejs构建前端react项目，后端也有用Spring全家桶写一些东西，在大二暑假的时候思考了很多，最后选择了前端方向，选择的理由主要还是兴趣，发现自己写js比较开心。</p>\n\n<h4>2、做了哪些准备，具体是如何学习的？</h4>\n\n<p>学习的过程那就根据时间来吧~</p>\n\n<h5>第一阶段 大二暑假7月8月和9月 前端基础</h5>\n\n<p>这一阶段是我觉得我前端学习过程中最重要的一段时间，到现在还在从中受益。<br />重要的学习工具：有道云笔记。每天学习的知识都会通过电脑记录在上面，零碎的时间就通过手机端进行复习<br />暑假我留校，一个人在寝室每天刷基础，具体的做法有：</p>\n\n<ul><li>牛客网HTML/CSS和JS两个专题反复刷，每个题必定做到知其然还知其所以然(给牛客的错题组卷功能一个五星好评)</li> <li>菜鸟教程的HTML,HTML5,CSS,CSS3这4个专题全部过了一遍，常用的能做到不看文档就写出来</li> <li>JS的基础知识我不看网上的资料，通过看《JavaScript高级程序设计》即著名的红宝书来学习，我之前做项目已经写了很长一段时间JS，但是知识点都是散的，通过看红宝书系统的学习把知识点串联了起来。（当然红宝书并没有看完，而且看的时候也跳了很多，很多知识直接看是看不懂的，很多我都是后来回来看才看懂的）</li> <li>Node.js的学习：跟着一本书来的，书名忘了，直接上手框架的应用，跟着写了一个nodejs的后台管理系统demo，因为有之前JAVA写后台的基础和前端js语言的熟悉，所以这个过程并不是特别难，就是熟悉框架express的使用</li> <li>前端框架React的学习：书名《深入React技术栈》这本书现在来看也是非常老了，尤其应用方面和代码实现方面，但是前2章对React的基础知识和概念以及后面Flux和Redux的概念讲解我个人觉得非常好，非常有助于新手入门。<br />到了9月，基础知识学习的差不多了我开始跟着网上的各种教程做一些小demo了，然后自己做了一个基于nodejs爬虫的信息汇总网站。<h5>第二阶段 10-12月 实践&amp;广度</h5> 这一阶段的学习最主要是两个：实践和广度。<br />10月我进入成都知道创宇开始实习，在一个大数据部门的前端可视化小组，小组技术栈是React.js+Hapi.js的js全栈。<br />实践自然就是实际的代码编写能力了，这个就是参与到公司实际的项目里，多写多思考就会慢慢提高了。<br />广度主要是前端领域发展很快，有很多新东西，刚入门有很多需要学习和了解的，这个的具体做法有：</li> <li>微信公众号：前端早读课和前端大全两个公众号每天的文章我会在每天坐公交车去公司的路上认真读的，如果有必要或者有兴趣，到公司之后会深一步的学习，并写一篇相关的技术博文</li> <li>知乎：虽然现在知乎装逼气息太浓对新人不太友好，但是多看看大佬的回答总是能有收货的，至少能了解很多东西</li> <li>看书：JS看了《你不知道的JavaScript》系列，node看了《深入浅出nodejs》<h5>第三阶段 1月2月 计算机基础</h5> 这一阶段主要是计算机的基础（算法/计算机网络/数据库/操作系统），因为要准备春招了。<br />主要有：</li> <li>回顾暑假学习的基础知识</li> <li>算法：刷《剑指offer》</li> <li>计网：这方面前端岗比较偏http，所以重点看了http，《http权威指南》没看完，太多了</li> <li>数据库：刚好大三上那个学期有数据库课，所以知识点学习的很系统，就是额外看了一下B树，B+树，红黑树相关（这些现在都忘完了……）</li> <li>操作系统：重点看了进程线程一块<h5>第四阶段 3月4月 面试</h5> 这阶段就是刷面经……<h5>第五阶段 5月6月7月8月 深度</h5> 这阶段已经去阿里实习了，自己学习的时间比较少，空闲时间就是进行知识点的深入以及回顾<h4>3、遇到困难时，如何解决？</h4> </li> <li>第一阶段刷基础的时候基本任何问题都能在网上找到答案</li> <li>第二阶段之后在创宇实习之后，就主要是leader，同事和网络了<h4>4、其他你想介绍的</h4> 啊……在上面已经说的差不多了<h4>看过的书籍：</h4> 列一下春招之前看的书：</li> <li>《深入React技术栈》</li> <li>《深入浅出nodejs》</li> <li>《Node.js实战》</li> <li>《http权威指南》（没看完）</li> <li>《JavaScript高级程序设计》</li> <li>《JavaScript权威指南》（这个当然没看完……那么厚）</li> <li>《你不知道的JavaSctipt》</li> <li>《JavaScript函数式编程》</li> <li>《高性能JavaScript》</li> <li>《HTML5与CSS3基础教程》</li> <li>《深入浅出Mysql》（没看完）</li> <li>《深入剖析nginx》（没看完）</li> <li>《剑指offer》<h4>学过的课程：</h4> 无<h4>做过的项目：</h4> 只列前端相关以及春招之前的：</li> <li>刚开始的：基于nodejs爬虫的信息汇总平台</li> <li>在实习时做的项目：<ul><li>周报系统</li> <li>统一登录与权限配置系统</li> <li>大数据可视化相关的</li> </ul></li> <li>校内的一个项目：物联网数据监控管理系统<h3>对零基础入门的学弟学妹们说一句话：基础很很很很很重要！</h3></li></ul>',2,4,0,1,0,0,1,'2020-05-03 14:25:06','2020-05-13 18:54:05'),(6,'面试题之数据库锁',' mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决? MySQL有三种锁的级别：页级、表级、行级。表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 行级锁：开销大，加锁...','database-lock-of-interview-questions','<p> <span style=\"color:rgb(0,0,0);font-size:24px;\">mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</span><br /></p>\n\n<blockquote><p><strong style=\"font-size:inherit;\">MySQL有三种锁的级别：</strong><span style=\"font-size:inherit;\">页级、表级、行级。</span><br /></p><ul><li><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 </li><li><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 </li><li><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul></blockquote>\n\n<p><span style=\"color:rgb(0,0,0);\">死锁</span><br /></p>\n\n<blockquote><p><strong style=\"font-size:inherit;\">死锁:</strong><span style=\"font-size:inherit;\"> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</span><br /></p><p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><p><strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p><p><strong style=\"font-size:inherit;\">死锁的解决办法?</strong><br /></p><p>1.查出的线程杀死 kill<br />SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p><p>2.设置锁的超时时间<br />Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br />该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br />set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p>3.指定获取锁的顺序</p></blockquote>\n\n<p><span style=\"color:rgb(0,0,0);\">有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</span></p>\n\n<blockquote><p> <strong style=\"font-size:inherit;\">悲观锁（Pessimistic Lock）:</strong></p><p><strong>悲观锁特点:</strong>先获取锁，再进行业务操作。</p><p>       即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的<strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>补充：</strong><br />不同的数据库对select for update的实现和支持都是有所区别的，</p><ul><li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。 </li><li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。 </li></ul><p><strong>乐观锁（Optimistic Lock）:</strong></p><p><strong>1.</strong>乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p><strong>2.**</strong>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。**即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br />乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p><strong>3.</strong>一般的做法是<strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p><p><strong>实现方式举例如下：</strong></p><p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p><ol><li>SELECT data AS old_data, version AS old_version FROM …; </li><li>根据获取的数据进行业务操作，得到new_data和new_version </li><li>UPDATE SET data = new_data, version = new_version WHERE version = old_version </li></ol><p>if (updated row &gt; 0) {</p><p>// 乐观锁获取成功，操作完成</p><p>} else {</p><p>// 乐观锁获取失败，回滚并重试</p><p>}</p><p><strong>注意：</strong></p><ul><li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能 </li><li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li></ul><p> </p><p><strong>总结：</strong><br />悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select ... for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><ul><li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。\' </li></ul><ul><li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。 </li></ul><ul><li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li></ul><p><br /></p></blockquote>',2,2,0,1,0,0,1,'2020-05-03 15:07:53','2020-05-13 18:53:41'),(7,'工作之后的那点事情','一、关于那些小社会 第一个工作的公司，有点小社会的风气。    当然，我也不是说反对成群结队，或者在公司有说有笑地工作。     而是某种社会的气氛会比较浓厚。     你品一品。     领导是有领导的样子的，出外你得...','what-happened-after-work','<p><span style=\"color:rgb(0,0,0);\">一、关于那些小社会</span><br /></p>\n\n<p>第一个工作的公司，有点小社会的风气。<br /></p>\n\n<p>   当然，我也不是说反对成群结队，或者在公司有说有笑地工作。 </p>\n\n<p>   而是某种社会的气氛会比较浓厚。 </p>\n\n<p>   你品一品。 </p>\n\n<p>   领导是有领导的样子的，出外你得喝酒玩得起，玩得动，虽说明面上没有人有那种溜须拍马的劲儿，但是你可以感觉到，领导至上、老员工次之。 </p>\n\n<p>   其他人也有点入乡随俗的样子，自然是跟着比划。 </p>\n\n<p>   夜宵是要有的，猜拳喝酒也是要有的。 </p>\n\n<p>   当然了，有些老员工还是值得尊敬的。比如其实跟我没有直接上下层关系的一位大佬，反而对我的疑问亲力亲为地过来指点。当然了，他自己也是比较另类的程序员，是属于独乐乐，不掺和太多事情类型的。 </p>\n\n<p>   这里的“事情”，是还有分小党派。具体，就不细说了。 </p>\n\n<p>   小社会有一个比较奇怪的事情，就是不能冒尖。有些时候，我每每回想起来，就是我冒尖太多了，所以会被人盯着。后面也就发生了一些事，当然，是在我已经准备辞职的时候了…… </p>\n\n<p>   但是这些事情，也导致了我后面的工作不敢冒尖了。</p>\n\n<p><span style=\"color:rgb(0,0,0);\">二、换工作的那些事情</span><br /></p>\n\n<p>换工作是很有必要的。<br /></p>\n\n<p>不要想着你“忠心耿耿”地从待在从校招开始进的公司，上层就会给你如愿的回报。事实上，你跳不跳，就跟地球转不转一样，没有关联。但是对你自己很重要。</p>\n\n<p>如果你干得不爽，还是走吧。</p>\n\n<p>如果你的薪资拿的跟你的水平不匹配，还是走吧。</p>\n\n<p>如果你觉得你需要走了，还是走吧。</p>\n\n<p><br /><br /></p>\n\n<p>当你过了两三年再来回看你这段“跳槽”的事情，就应该觉得你的选择都是正确的。——不管你是不是后面遇到了糟心事，或者反而被炒了，之类的——都要坚信你的选择是对的。因为你留着，后面只会更糟心。</p>\n\n<p>就我自己的感受而言，换工作是因为薪资实在太少。——而且公司是不会照顾穷人的。</p>\n\n<p>第一家公司有一年的实习期。为了避免被人，或被熟悉劳动法的相关人指摘，半年“实习”，半年“见习”。</p>\n\n<p>这半年的实习，薪资少到我交完房租、生活费，和一点家用，基本就要刷信用卡了。</p>\n\n<p>是的，出门玩一趟，不是花呗，就是信用卡，然后第二个月一旦发工资了，就直接拿来填补上个月的亏空。后来实在撑不下去，钱也没再寄回家，反而要从家里拿钱。</p>\n\n<p><br /><br /></p>\n\n<p>但是其他人生活反而滋润得很，开车上班的，买房落户的，还有租带阳***卫的房子的。</p>\n\n<p>那时候我才知道，人的出身家境对工作的选择是很有影响的。如果薪资实在太少，还是跳吧。有些事没法跟别人比，就只会自己寻求新的机遇。</p>\n\n<p><br /><br /></p>\n\n<p>哦，说回来薪资这事，没有加班费。所以大家老老实实地奋斗，都是自愿加班。——更多的，是其他人加班，你也不得不加班。等九点坐公车回家，你会开始怀疑人生。钱少活多还得学人家装出奋斗X的样子。</p>\n\n<p>那还是换吧。</p>\n\n<p><span style=\"color:rgb(0,0,0);\">三、换工作之后的事情</span><br /></p>\n\n<p>不要期待换工作会让你的生活突然如鱼得水。<br /></p>\n\n<p>   一般来说，每个人的生活总是欲求不满的。 </p>\n\n<p>   就如同跳槽之后，薪资直接加倍，（租房费用也直接翻倍，但是盈余总是比之前多了），但是你总会有更高的想法。 </p>\n\n<p>   比如马云的手下不会追着我还花呗。</p>\n\n<p>   比如终于敢买一部台式机电脑，花了三千多也不心疼。 </p>\n\n<p>   比如现在终于敢奢望攒钱，期待着攒满10w。 </p>\n\n<p>   接着，你想要更多，比如更轻松的工作，更愉悦的生活。 </p>\n\n<p>   回首换工作的第一年，我住的是没有3个平的书房改装的房间，还是靠着同学给面子，舔着脸少交了几百块的房租。那时候的日子是真的穷，从深圳出去广州见一趟妹子，都只能坐最便宜的大巴（是不是黑大巴就不好定义了），我的体质是坐大巴就会犯恶心干呕的，所以每次都感觉在经历地狱之旅。 </p>\n\n<p>   现在呢，我孤孤单单一个人，住着带阳台的小区合租房，心里却想着的是攒够老家买房的首付。那时候怎么敢奢望住个大卧室，更罔论买个三线城市的小房间了。 </p>\n\n<p>   当然，你可能会说我咋就不像个钱多话少的程序员……前面不是还有帖子是年薪二十万的内推帖么。是的，我年薪是高，但是我是钱少话多的那种。 </p>\n\n<p>   ——一方面是因为生活花销，比如租房之类的翻倍。 </p>\n\n<p>   ——另一方面，前面也说了，不是每个人家境都那么好的。我总得拿点钱寄回家去。不过这个行为，后面会让我觉得倍有面子，毕竟我也能反哺父母了，倒也不是一件什么事了。 </p>\n\n<p>   所以，换工作可能会让你好受，但是不会让你特别好过。</p>\n\n<p><span style=\"color:rgb(0,0,0);\">四、换工作之后的工作</span></p>\n\n<p>你以为我换了工作生活变好了。 </p>\n\n<p>   其实并没有。 </p>\n\n<p>   因为从个人体验来说，从每个月四千的工作突然换到近一万的薪资的工作，你会有一种感觉：我真的值这么多钱吗？ </p>\n\n<p>   你会开始患得患失。万一这份工作做不好怎么办？别人也加班，我是不是也该加班？ </p>\n\n<p>   虽然从某个维度上来比，一万月薪不算什么高薪资的工作，但是那是对于那些出来就见了大世面的人来说的，对我一个刚开始薪资就被压得极其非常特别低的人而言，我会觉得豁然提升了那么多，会很吓人。 </p>\n\n<p>   （当然后来才发现其他人水平相当，甚至还有连基础的命令行、盲打都不会的人，一开始却能领那么高的薪资，全靠第一份工作找得好，自我肯定很重要。） </p>\n\n<p>   面试的时候造火箭，工作的时候拧螺丝。这句话对非高端行业的人来说，很恰如其分。 </p>\n\n<p>   但是由于自身对工作的重视程度在后面越来越高，就出现了一个很不好的情况：太把工作当回事了，以至于忽略了身边的人。 </p>\n\n<p>   是的，第一年我拿了个最低绩效。 </p>\n\n<p>   第二年重视起来之后，拿了个高的绩效。——生活上，这一年过后我就被甩了。 </p>\n\n<p>   因为我下班时间也越来越晚，后来连请假都不敢，竟然让妹子自己去旅游了。最后的导火线是岗位上埋头苦干，却忘了机场回来的女友百无聊赖，无人搭理。 </p>\n\n<p>   钱是拿到了，最爱的人却丢了。 </p>\n\n<p>   ——以至于到现在我都后悔。 </p>\n\n<p>   工作内容没什么好说的，真的就是for循环和if语句走天下。再不行就拷贝上面一行下来再循环一次。（当然代码哪里都一样，问题是这些工作基本上比不上搞算法的。这里的代码是你一眼就知道在干什么的，而算法的那些代码可能你一个一个字地看都不知道是在干嘛。） </p>\n\n<p>   但是居安思危这四个字，真的是放之四海而皆准。 </p>\n\n<p>   因为.Net的技术栈不被看好，理论上都要转型了。这个时候就会有一种被打了个措手不及的感觉。 </p>\n\n<p>   所以工作中还是偶尔关注一下其他技术栈的好处，就会在这个时候体现出来了。 </p>\n\n<p>   再没有，就多抱佛脚吧。 </p>\n\n<p><br /></p>\n\n<p><span style=\"color:rgb(0,0,0);\">五、所谓的经验</span><br /></p>\n\n<p><strong>1）多用言语沟通请教，而不是文字</strong><br /></p>\n\n<p>   有些新人害怕打电话找需求方，害怕说话，不敢表达，我觉得这一点真的是让人很掉好感。因为明明几句话的功夫就可以搞明白的，非要用文字请教，磕个大半天还不知道彼此的意思…… </p>\n\n<p>   <strong>2）不要为了加班而加班。如果必须加班，就请偷偷学习，而不是打游戏。</strong> </p>\n\n<p>   没什么好说的，现在风气已经起来了，前后左右的公司都在加班，都在比“奋斗”——但是有没有干活，大家心里都清楚。有的人只是刷加班时间，所以如果因为规定你也要刷，那最好带上你的电脑，装好IDE，学点新的东西，或者自己搞个服务器，自己远程写点自己想要的代码，看点感兴趣的书。——哪怕是闲书。 </p>\n\n<p>   <strong>3）不要玩游戏。</strong>这个很重要。上班地点不要玩游戏，不是给领导看的，而是给你自己约束用的。当你拿加班的时间来放松的时候，就说明你没有任何独立做自己事情的时间。如果你喜欢玩游戏，下班好好玩。——但是真的别忘了自己写自己的代码。 </p>\n\n<p>   <strong><br /></strong> </p>\n\n<p>   经验这种东西说出来你也就只是看看而已。 </p>\n\n<p>   但是<strong>“熟能生巧”</strong>这四个字却要警惕： </p>\n\n<p>   你现在是自觉技术有进步了呢，还是仅仅是打代码打熟了而已？ </p>\n\n<p>   你以后二十年的工作，还要这么重复下去么？ </p>\n\n<p>   与诸君共勉。</p>',2,4,0,2,0,0,1,'2020-05-03 15:25:49','2020-05-13 18:53:38'),(8,'如何计算“个人所得税”','终于找到工作，即将经济独立的你一定听过一个词——交税。依法纳税是每个公民应尽的义务，***通过税款为公民提供公共服务，城市治安，医疗等。其实在平常生活里，我们在买东西的过程中已经不知不觉就履行了纳税义务，...','how-to-calculate-personal-income-tax','<blockquote><p><span style=\"color:rgb(51,51,51);\">终于找到工作，即将经济独立的你一定听过一个词——交税。依法纳税是每个公民应尽的义务，***通过税款为公民提供公共服务，城市治安，医疗等。其实在平常生活里，我们在买东西的过程中已经不知不觉就履行了纳税义务，但正因为“不知不觉”，所以我们对交税并没有什么感觉，让我们头次感受到税的“切肤之痛”——当属个人所得税。</span><span style=\"color:rgb(51,51,51);\">对于每个月都要上交税务局的个税是什么？是如何计算的？每月自己应该交多少个税？如果你还解答不了以上疑问，请继续往下看！</span><br /></p></blockquote>\n\n<h2><b style=\"color:rgb(0,0,0);\">情景设定</b></h2>\n\n<p>为了增强阅读性，便于大家理解和消化，本文将采取情景模拟的方式，带领大家了解“个税”的计算方式~<br /></p>\n\n<p>	 </p>\n\n<p>	人物：牛可乐</p>\n\n<p>	每月应发工资：30000元</p>\n\n<p>	三险一金：3000元</p>\n\n<p>	专项附加扣除项：住房租金</p>\n\n<p>	 </p>\n\n<p>	牛可乐于2018年入职牛客，2019年每月税前应发工资为30000元，没有减免收入及减免税额等情况。现在我们来计算一下，牛可乐2019年度应该缴纳多少个人所得税。</p>\n\n<p>	 </p>\n\n<p>	接下来简要介绍一下“每月应发工资”“三险一金”“专项附加扣除项”，如果你已经了解了这部分内容，可以跳过以下部分，直接进入“计算个税”~</p>\n\n<h3><b style=\"color:rgb(0,0,0);\">每月应发工资</b></h3>\n\n<p>每月应发工资即为缴纳个人所得税、三险一金等之前的每月应发工资，其实就是你拿到offer时，offer上面写的月薪。比如牛可乐的offer上写着：30000x12，那么就是每月应发工资30000元，每年12薪。<br /></p>\n\n<h3><b style=\"color:rgb(0,0,0);\">扣除三险</b><b style=\"color:rgb(0,0,0);\">一金</b></h3>\n\n<p>五险一金是指用人单位给予劳动者的几种保障性待遇的合称，包括养老保险、医疗保险、失业保险、工伤保险和生育保险，及住房公积金，其中需要个人缴纳的只有养老保险、医疗保险和失业保险，月末发工资时由单位代扣代缴，工伤保险与生育保险只由单位缴纳，个人是不用缴纳的，所以对个人缴纳个税来说，<b>扣除的是三险一金</b></p>\n\n<p> 五险是国家为保护劳动者通过立法强制要求企业缴纳的基础保障，如果所在的单位没有给员工上保险违法了哟，在五险之外，企业也会给员工另外购买商业保险，常见的有补充医疗保险，俗称六险（例如牛客就还有一个补充医疗保险）。</p>\n\n<p>  具体你的公司都购买了哪些保险，可以向HR小姐姐/小哥哥询问一下~</p>\n\n<h3><b style=\"color:rgb(0,0,0);\">专项附加扣除项</b></h3>\n\n<p>个税专项附加扣除（全称：个人所得税专项附加扣除），是指个人所得税法规定的子女教育、继续教育、大病医疗、住房贷款利息、住房租金和赡养老人等六项专项附加扣除。是落实新修订的个人所得税法的配套措施之一。<br /></p>\n\n<p> 这是2018年个税改革新增的项目，于2019年1月1日起开始实行。一般对刚工作的牛友们来说，主要能够涉及到的就是：住房租金。</p>\n\n<p> 关于住房租金的扣除，具体规定如下：</p>\n\n<p> 1、直辖市、省会（首府）城市、计划单列市以及***确定的其他城市，扣除标准为每月1500元；</p>\n\n<p> 2、除第一项所列城市以外，市辖区户籍人口超过100万的城市，扣除标准为每月1100元；市辖区户籍人口不超过100万的城市，扣除标准为每月800元。</p>\n\n<p> 注意：纳税人的配偶在纳税人的主要工作城市有自有住房的，视同纳税人在主要工作城市有自有住房。市辖区户籍人口，以国家统计局公布的数据为准。</p>\n\n<p> 因此就单身的牛可乐而言，他在北京的住房租赁专项附加扣除项金额为：1500元。</p>\n\n<p> 其他的项目由于多数刚工作的牛友涉及不到，因此不在这里多说，具体可以参考：个税专项附加扣除</p>\n\n<p><br /></p>\n\n<h2><b style=\"color:rgb(0,0,0);\">计算个税</b></h2>\n\n<p>首先来看个税的计算公式：<br /></p>\n\n<p>本期应预扣预缴税额=（累计预扣预缴应纳税所得额×预扣率-速算扣除数)-累计减免税额-累计已预扣预缴税额<br /></p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=累计收入-累计免税收入-累计减除费用-累计专项扣除-累计专项附加扣除-累计依法确定的其他扣除</p>\n\n<p>	 </p>\n\n<p>	（1）累计减除费用，按照5000元/月乘以纳税人当年截至本月在本单位的任职受雇月份数计算。</p>\n\n<p>	（2）累计专项附加扣除，为该员工在本单位截至当前月份符合政策条件的扣除金额。上述公式中，计算居民个人工资、薪金所得预扣预缴税额的预扣率、速算扣除数，按《附1：个人所得税预扣率表》（如下图）执行。</p>\n\n<p>	 </p>\n\n<p>	<img width=\"692\" height=\"373\" src=\"https://uploadfiles.nowcoder.com/images/20190104/63_1546598437939_C80E4C61FEF08542271D108A82DABD0E\" alt=\"63_1546598437939_C80E4C61FEF08542271D108A82DABD0E\" /> </p>\n\n<p>	 </p>\n\n<p>	好的，我知道，你现在一定<b>一！脸！懵！B！</b> </p>\n\n<p>	但是没关系！接下来让我们一步一步来计算，牛可乐今年应该缴纳多少个人所得税！</p>\n\n<p> </p>\n\n<h3>	<b>1月：</b> </h3>\n\n<p>	2019年1月，牛可乐应发工资为30000元，接下来套公式：</p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=累计收入-累计免税收入-累计减除费用-累计专项扣除-累计专项附加扣除-累计依法确定的其他扣除……①</p>\n\n<p>	 </p>\n\n<p>	累计收入=30000元</p>\n\n<p>	累积免税收入=0元</p>\n\n<p>	累积减除费用=5000元 [1]</p>\n\n<p>	累积专项扣除=3000元（即三险一金）</p>\n\n<p>	累积专项附加扣除=1500元（即住房租赁）</p>\n\n<p>	累计依法确定的其他扣除=0元</p>\n\n<p>	 </p>\n\n<p>	30000-0-5000-3000-1500-0=20500(元)</p>\n\n<p>	 </p>\n\n<p>	因此，牛可乐1月累计预扣预缴应纳税所得额=20500元</p>\n\n<p>	 </p>\n\n<p>	本期应预扣预缴税额=（累计预扣预缴应纳税所得额×预扣率-速算扣除数)-累计减免税额-累计已预扣预缴税额……②</p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=20500元</p>\n\n<p>	预扣率=0.03（参考《附1：个人所得税预扣率表》）</p>\n\n<p>	速算扣除数=0（参考《附1：个人所得税预扣率表》）</p>\n\n<p>	累积减免税额=0元</p>\n\n<p>	累计已预扣预缴税额=0元</p>\n\n<p>	 </p>\n\n<p>	(20500×0.03-0)-0-0=615(元)</p>\n\n<p>	 </p>\n\n<p>	<b>因此，牛可乐1月应预扣预缴税额=615元</b> </p>\n\n<p>	 </p>\n\n<p>	用简单图示的方法复现上述过程即为：</p>\n\n<p>	 </p>\n\n<p>	<img width=\"692\" height=\"277\" src=\"https://uploadfiles.nowcoder.com/images/20190104/63_1546598448614_A6BCD5F8A02D64C8484B1DEDC84FAEF0\" alt=\"63_1546598448614_A6BCD5F8A02D64C8484B1DEDC84FAEF0\" /> </p>\n\n<p>	 </p>\n\n<p>	[1]这里解释一下为什么要减去5000元的减除费用，国家规定的起免征额为5000元，如果你每月的应发工资减去，那么按照规定是<b>不需要缴纳个人所得税的！</b> </p>\n\n<p>	 </p>\n\n<p>	再说的直白一点，就是按照公式，计算所得的<b>累计预扣预缴应纳税所得额&lt;=0</b>，那么按照规定是不需要缴纳个人所得税的！</p>\n\n<p>	 </p>\n\n<p>	举个栗子：</p>\n\n<p>	 </p>\n\n<p>	牛能每月应发工资为8000元，三险一金为2000元，专项附加扣除（住房租赁）1500元，那么按照公示：</p>\n\n<p>	 </p>\n\n<p>	累计收入=8000元</p>\n\n<p>	累积免税收入=0元</p>\n\n<p>	累积减除费用=5000元</p>\n\n<p>	累积专项扣除=2000元（即三险一金）</p>\n\n<p>	累积专项附加扣除=1500元（即住房租赁）</p>\n\n<p>	累计依法确定的其他扣除=0元</p>\n\n<p>	 </p>\n\n<p>	8000-0-5000-3000-1500-0&lt;0，则牛能是<b>不需要缴纳个人所得税的！</b> </p>\n\n<p>	 </p>\n\n<h3>	<b>2月：</b> </h3>\n\n<p>	到了2月，这时候就可以体现新个税办法中“累计”的意思了！2019年2月，牛可乐当月应发工资为：30000元。接下来继续套公式~</p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=累计收入-累计免税收入-累计减除费用-累计专项扣除-累计专项附加扣除-累计依法确定的其他扣除……①</p>\n\n<p>	 </p>\n\n<p>	因为累计本年度，牛可乐在牛客已经拿2个月的工资了，所以乘以2：</p>\n\n<p>	 </p>\n\n<p>	累计收入=30000×2=60000元</p>\n\n<p>	累积免税收入=0×2=0元</p>\n\n<p>	累积减除费用=5000×2=10000元</p>\n\n<p>	累积专项扣除=3000×2=6000元（即三险一金）</p>\n\n<p>	累积专项附加扣除=1500×2=3000元（即住房租赁）</p>\n\n<p>	累计依法确定的其他扣除=0×2=0元</p>\n\n<p>	 </p>\n\n<p>	(30000-0-5000-3000-1500-0)×2=41000(元)</p>\n\n<p>	 </p>\n\n<p>	因此，牛可乐2月累计预扣预缴应纳税所得额=41000元</p>\n\n<p>	 </p>\n\n<p>	本期应预扣预缴税额=（累计预扣预缴应纳税所得额×预扣率-速算扣除数)-累计减免税额-累计已预扣预缴税额……②</p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=41000元</p>\n\n<p>	预扣率=0.10（参考《附1：个人所得税预扣率表》）</p>\n\n<p>	速算扣除数=2520（参考《附1：个人所得税预扣率表》）</p>\n\n<p>	累积减免税额=0元</p>\n\n<p>	累计已预扣预缴税额=615元（因为1月已经交了615元）</p>\n\n<p>	 </p>\n\n<p>	(41000×0.10-2520)-0-615=965(元)</p>\n\n<p>	 </p>\n\n<p>	<b>因此，牛可乐2月应预扣预缴税额=965元</b> </p>\n\n<p>	 </p>\n\n<p>	用简单图示的方法复现上述过程即为：</p>\n\n<p>	 </p>\n\n<p>	<img width=\"692\" height=\"277\" src=\"https://uploadfiles.nowcoder.com/images/20190104/63_1546598458681_3B941ADA9B60E3D9ABB8C697BF7DAF2E\" alt=\"63_1546598458681_3B941ADA9B60E3D9ABB8C697BF7DAF2E\" /> </p>\n\n<p>	 </p>\n\n<h3>	<b>3月：</b> </h3>\n\n<p>	接下来我们继续计算牛可乐3月的个人所得税，还是套公式：</p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=累计收入-累计免税收入-累计减除费用-累计专项扣除-累计专项附加扣除-累计依法确定的其他扣除……①</p>\n\n<p>	 </p>\n\n<p>	因为累计本年度，牛可乐在牛客已经拿3个月的工资了，所以乘以3：</p>\n\n<p>	 </p>\n\n<p>	累计收入=30000×3=90000元</p>\n\n<p>	累积免税收入=0×3=0元</p>\n\n<p>	累积减除费用=5000×3=15000元</p>\n\n<p>	累积专项扣除=3000×3=9000元（即三险一金）</p>\n\n<p>	累积专项附加扣除=1500×3=4500元（即住房租赁）</p>\n\n<p>	累计依法确定的其他扣除=0×3=0元</p>\n\n<p>	 </p>\n\n<p>	(30000-0-5000-3000-1500-0)×3=61500(元)</p>\n\n<p>	 </p>\n\n<p>	因此，牛可乐3月累计预扣预缴应纳税所得额=61500元</p>\n\n<p>	 </p>\n\n<p>	本期应预扣预缴税额=（累计预扣预缴应纳税所得额×预扣率-速算扣除数)-累计减免税额-累计已预扣预缴税额……②</p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=61500元</p>\n\n<p>	预扣率=0.10（参考《附1：个人所得税预扣率表》）</p>\n\n<p>	速算扣除数=2520（参考《附1：个人所得税预扣率表》）</p>\n\n<p>	累积减免税额=0元</p>\n\n<p>	累计已预扣预缴税额=615+965=1580元（计算2019年全年在牛客已缴的税额）</p>\n\n<p>	 </p>\n\n<p>	(61500×0.10-2520)-0-1580=2050(元)</p>\n\n<p>	 </p>\n\n<p>	<b>因此，牛可乐3月应预扣预缴税额=2050元</b> </p>\n\n<p>	 </p>\n\n<p>	用简单图示的方法复现上述过程即为：</p>\n\n<p>	 </p>\n\n<p>	<img width=\"692\" height=\"277\" src=\"https://uploadfiles.nowcoder.com/images/20190104/63_1546598475188_7B8E4A1B286D2CF9AFE87AD839311496\" alt=\"63_1546598475188_7B8E4A1B286D2CF9AFE87AD839311496\" /> </p>\n\n<h3>	<b>4-12月：</b> </h3>\n\n<p>	相信经过3个月的分步仔细计算，你应该已经初步了解了个税的计算方法~接下来，请你试着计算一下，牛可乐4月的个人所得税~</p>\n\n<p>	 </p>\n\n<p>	计算完成之前不要往下翻哦~</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	。</p>\n\n<p>	计算完了吗？</p>\n\n<p>	现在让我们来对答案吧~</p>\n\n<p>	 </p>\n\n<p>	<b>4月，牛可乐应预扣预缴税额为：2050元</b> </p>\n\n<p>	计算公式如下：</p>\n\n<p>	((30000-0-5000-3000-1500-0)×4×0.10-2520)-0-(615+965+2050)=2050(元)</p>\n\n<p>	 </p>\n\n<p>	同理可得：</p>\n\n<p>	5月：((30000-0-5000-3000-1500-0)×5×0.10-2520)-0-5680=2050(元)</p>\n\n<p>	6月：((30000-0-5000-3000-1500-0)×6×0.10-2520)-0-7730=2050(元)</p>\n\n<p>	7月：((30000-0-5000-3000-1500-0)×7×0.10-2520)-0-9780=2050(元)</p>\n\n<p>	8月：((30000-0-5000-3000-1500-0)×8×0.20-16920)-0-11830=4050(元)</p>\n\n<p>	9月：((30000-0-5000-3000-1500-0)×9×0.20-16920)-0-15880=4100(元)</p>\n\n<p>	10月：((30000-0-5000-3000-1500-0)×10×0.20-16920)-0-19980=4100(元)</p>\n\n<p>	11月：((30000-0-5000-3000-1500-0)×11×0.20-16920)-0-24080=4100(元)</p>\n\n<p>	12月：((30000-0-5000-3000-1500-0)×12×0.20-16920)-0-28180=4100(元)</p>\n\n<p>	 </p>\n\n<p>	<b>因此，牛可乐2019全年缴纳个人所得税金额为：32280(元)</b> </p>\n\n<p>	<b> </b> </p>\n\n<p>	以上就是个人所得税的全部计算方法啦~</p>\n\n<p>	<b> </b> </p>\n\n<h2>	<b>附1：个人所得税预扣率表</b> </h2>\n\n<p>	<img width=\"692\" height=\"373\" src=\"https://uploadfiles.nowcoder.com/images/20190104/63_1546598485823_C80E4C61FEF08542271D108A82DABD0E\" alt=\"63_1546598485823_C80E4C61FEF08542271D108A82DABD0E\" /> </p>\n\n<p>	 </p>\n\n<h2>	<b>附2：2019新“个人所得税”缴纳办法</b> </h2>\n\n<p>	按照《国家税务总局关于发布&lt;个人所得税扣缴申报管理办法（试行）&gt;的公告》（国家税务总局公告2018年第61号）文件规定，自2019年1月1日起，工资、薪金所得需按“累计预扣法”计算预扣预缴个人所得税。</p>\n\n<p>	 </p>\n\n<p>	累计预扣法，是指扣缴义务人在一个纳税年度内预扣预缴税款时，以纳税人在本单位截至当前月份工资、薪金所得累计收入减除累计免税收入、累计减除费用、累计专项扣除、累计专项附加扣除和累计依法确定的其他扣除后的余额为累计预扣预缴应纳税所得额，适用<b>个人所得税预扣率表</b>，计算累计应预扣预缴税额，再减除累计减免税额和累计已预扣预缴税额，其余额为本期应预扣预缴税额。余额为负值时，暂不退税。纳税年度终了后余额仍为负值时，由纳税人通过办理综合所得年度汇算清缴，税款多退少补。</p>\n\n<p>	 </p>\n\n<p>	具体计算公式如下：</p>\n\n<p>	 </p>\n\n<p>	本期应预扣预缴税额=（累计预扣预缴应纳税所得额×预扣率-速算扣除数)-累计减免税额-累计已预扣预缴税额</p>\n\n<p>	 </p>\n\n<p>	累计预扣预缴应纳税所得额=累计收入-累计免税收入-累计减除费用-累计专项扣除-累计专项附加扣除-累计依法确定的其他扣除</p>\n\n<p>	 </p>\n\n<p>	（1）累计减除费用，按照5000元/月乘以纳税人当年截至本月在本单位的任职受雇月份数计算。</p>\n\n<p>	（2）累计专项附加扣除，为该员工在本单位截至当前月份符合政策条件的扣除金额。上述公式中，计算居民个人工资、薪金所得预扣预缴税额的预扣率、速算扣除数，按《个人所得税预扣率表》执行。</p>\n\n<p>   </p>',2,4,0,1,0,0,1,'2020-05-03 15:39:15','2020-05-13 18:53:10'),(9,'毕业半年老鸟回来聊聊天','  好久没回来了，好不容易熬过了试用期，想起曾经的牛客就回来串串门。先逛了一下讨论区，很棒，人已经基本都不认识了。那正好，这次的贴子就是来和大家聊聊毕业之后的社会生活吧:) 自我情况介绍：大家就翻我以前帖...','half-a-year-after-graduation-the-old-bird-will-come-back-for-a-chat','<p> </p>\n\n<p>好久没回来了，好不容易熬过了试用期，想起曾经的牛客就回来串串门。<br />先逛了一下讨论区，很棒，人已经基本都不认识了。那正好，这次的贴子就是来和大家聊聊毕业之后的社会生活吧:)</p>\n\n<p>自我情况介绍：大家就翻我以前帖子吧，应该是第一篇帖子，里面有我详细情况。<br />现状：微软工作半年（岗位太特殊，基本上如果混这个圈子的肯定知道我是谁了，就不说了）。大家都熟知微软有亚研院有工程院，我在GSMO，全球市场与服务，然后我在这个不为人知的部门里做技术岗/捂脸。</p>\n\n<p>之所以会突然想到回来溜一下，是因为当初我在牛客上度过了我的找工作时光，那阵子比较纠结挣扎的日子在我的生活中留下了不可磨灭的烙印，所以毕了业，想着回来和大家聊聊。如果知道我的老铁肯定知道，我当初找工作的目标就是俩字，养老。所以拒绝了一众互联网，一意孤行的走上了去国企和外企的道路。也就有了我来到微软这个经历。</p>\n\n<p> </p>\n\n<h2>目标</h2>\n\n<p>脱离了主题的讨论都是耍流氓，先来第一个节奏，目标是什么呢？<br />之所以讨论这个，是因为在找工作的过程中，和毕了业的生活之中，发现大家做了太多背离初心或者根本不知道自己想要啥的事情。比如有很多人根本不喜欢打代码，然后死命往开发岗奔；又或者这些年算法工资高，不知道有多少人削尖了脑袋往算法挤，很多人找到我说想做算法，我问为什么啊，回答要么是工资高要么是觉得算法不打代码或者是不加班？？？每次听到我都恨不得给孩子的脑袋揪下来，如果想做算法，请你最起码有对于数据的敏感度，能好好的学学数学再说找算法工作的事情。<br />所以这里，请大家一定好好想想自己的目标，到底是什么。</p>\n\n<ul><li>如果大家对于<strong>技术</strong>非常的执迷且热爱，那请你坚定的找技术，我觉得找工作对于你肯定不是难事。</li><li>如果大家像我一样想<strong>养老</strong>，那就别考虑互联网了，来国企或者外企，再进去之前好好打听内部情况。</li><li>如果大家家里有安排，请回家安心继承矿产，或者随意在外面玩，开心就行。</li><li>如果大家不知道自己到底想要啥，请你自己好好想想，这个我没法帮你。</li><li>如果大家不知道自己适合哪个，那绝对请你在<strong>试错成本</strong>最低的现在（没毕业之前），好好折腾折腾，到处试试，试了你就知道自己想要什么了。</li><li>也不要自己瞎意淫，觉得自己可以扛得住996/007，请你试过再说。</li></ul>\n\n<p> </p>\n\n<h2>目前环境概述</h2>\n\n<p>我相信进了社会的每一个人都很痛苦，觉得自己再来一遍的话肯定会怎样怎样。<br />我也不是例外，进了社会之后被锤了太多次，思想慢慢转变，我很感激自己能有这样的经历。<br />我所在的是大家都不知道的GSMO，全球市场与服务，顾名思义，就是将微软的各种产品进行各种花式落地，一起共事的人有市场，有销售，有产品经理，还有我这样的技术落地人员。<br />在我没有见识的毕业前的生涯，我承认我对于销售等等一直有着很大的误解，但是社会的捶打让我知道，销售们都太牛X了，他们简直是我见过情商最高的一群人，也是最能抗压的一群人，和他们共事我有了很大的进步与提升。<br />市场部门很有趣，我觉得是最适合女生的一个工作了，以后没准会考虑考虑。<br />而我这个技术role，其实算是有些小尴尬的情况，组里的人都是有着十几年经验的老法师，他们随口说一句都是当年直接搞底层布网线的先驱经历，自己在这样的组里，就是个弱鸡一直在仰望各种大佬的光环。<br />我的日常生活的话，就是正常上班，从不考勤，自己安排时间，所以只要把活干了就好。每隔一天我会去健身房私教+有氧两个小时，工作以来减了四斤，也算是有点小收获。每周末会在两个中午自己做大餐，像是做周黑鸭，蒸皮皮虾，做甜品等等，周六下午和晚上去逛街看电影，周日下午私教一下午。周而复始。<br />累的时候也有，有因为第二天要有大型演讲，晚上在酒店看deck看到两三点。也有为了赶给客户的POC，连着一个礼拜天天学习心惊胆战。<br />如果说微软给了我什么，那就是给了我太多的视界，我以前的认知中，我只能做一个前面有什么需求我做什么需求的小算法，而现在我看到了太多可能性，我开始对市场很感兴趣，我开始学着做管理，也开始在几百个人前面讲session。而这些机会和视角，是我以前的生活中绝对看不到的生活。</p>\n\n<p> </p>\n\n<h2>同学相关情况</h2>\n\n<p>由于我原来是软件工程专业，同学大多数都去了互联网公司，还有一部分去了国企，少部分像我这样的去了外企，我这里来和大家分享一下我们三种方向现在的生活。</p>\n\n<ul><li>互联网方向：同学占比很高，遍布阿里腾讯头条，大多数时间会在周内的晚上刷到他们刚下班的朋友圈，解决了怎样的Bug，上线了怎样的项目。</li><li>国企（银行/中央等等）：这是我最羡慕的一群人了。。他们基本上955，非常有生活，周内也可以去吃吃好吃的看看电影，周末了看看展，福利爆表。我北大的一个同学在某行总行，现在已经开始考虑以后的长期规划了，听久了我觉得我们已经不是一个阶层的人了，他们大部分的生活会朝向享受生活或者升级从而改变社会阶层命运等等。。希望我的同学们还能记得我，到时候提携我一下。</li><li>外企（我），大体的状况我在上面第二节写过了。</li></ul>\n\n<p>这里只是典型现象，当然也有清闲的互联网，也有我这种忙到扣脚的外企，各式各样，但是多数样本呈现比较典型的分布。供大家参考。</p>\n\n<p>这里也想说，其实回过头来，我当时找工作的角度太窄了，自己到后期也懒了一点。<br />工作了之后，如果让我重新选择，我也绝对不会回原来的实习公司了，只能说去年的时候，我的部门还是百度绝对的现金流核心，一年的时间里面天翻地覆，很多高T都走了，组里只剩了几个我去年还认识的人。人口红利吃完的局面已经这样了，大家也自然知道以后的很多走向。<br />所以如果可以的话，大家找工作的时候请一定结合自身的情况考虑。</p>\n\n<ul><li>像是你是否最后要回家乡，或者家乡临近的稍大一些的城市，如果是这样的话请你一定做好规划，我太多同学都想着在被北上赚钱然后回家，事实是故乡很大程度上成了回不去的家。因为北上的高消费，攒钱还是挺难的（对我来说挺难的。。。我税后差不多1w5+，但是每个月租房子5k，各种花费再3k，逢假期回家什么的买礼物又要好多钱，钱真的难攒的一笔），而你脱离了毕业生的身份，想再找工作是很难的，尤其是想回家的状态下，可能根本没有你能回得去的工作。</li><li>如果想要在北上，请你一定搞好户口，考虑好以后的钱，房，孩子，学业。（自己亲测，上海比北京各项难度低一些，生活质量好一些哈哈哈）</li></ul>\n\n<p>说白了，<strong>钱多，事儿少，离家近</strong>，不可能样样都有，请大家自己权衡。<br />思路也挺乱的，其实就是心血来潮了，想和大家讲讲毕业之后的一些事情供大家参考。<br />就先这样:)<br />啾咪:)</p>',2,4,0,2,0,0,1,'2020-05-03 15:46:50','2020-05-13 18:52:00'),(10,'【19届毕业生】大环境下，我的经历可能有你想要的答案！！！',' 前言 	自我介绍一下，我叫爱如潮水（花名），19届毕业生，也是和各位大佬一样出身非科班，我发现能去BAT的人大多都是非科班出身。我这个跨专业的度可能比较大，因为牛客网的知名度非常高，所以我就不多介绍自己了，...','19-graduates-under-the-general-environment-my-experience-may-have-the-answer-you-want','<p> <span style=\"color:rgb(0,0,0);font-size:22px;\">前言</span></p>\n\n<p>	自我介绍一下，我叫爱如潮水（花名），19届毕业生，也是和各位大佬一样出身非科班，我发现能去BAT的人大多都是非科班出身。我这个跨专业的度可能比较大，因为牛客网的知名度非常高，所以我就不多介绍自己了，被认出来就不好了。</p>\n\n<p>	我这个专业怎么来讲呢，我从事这个专业很多年了，从初中一直到大学没变过。此话怎讲，你们高考在每年的6月份持续三天，而我的高考在你们考试的前一年，10月份开始，持续几个月，你们叫统招，我们叫单招（我没有参加过中考与高考，也不需要参加）。我的专业与文理都不相关，对，我的专业就是这么跨（提示就到这了，专业自己猜吧...）。</p>\n\n<p><span style=\"color:rgb(0,0,0);font-size:22px;\">第一次接触计算机编程</span><br /></p>\n\n<p>	还记得在那时候的秋天，正值大三，女朋友让我陪她去上课，那节课是讲的C语言，因为有作业要交，我就帮她分担一点，一起抄上节课作业?。抄着抄着我不知道哪里来的勇气，就要弄懂它是什么意思，感觉它很奇妙，有一种黑客的感觉，如果能在电脑中熟练的打出这些奇怪的字母，真的很帅，此时我对计算机的兴趣突然就上来了。 </p>\n\n<p>	 我女朋友觉得我没必要懂这个，而且我也会听不明白，还浪费时间。在我的再三恳求下，我们俩下课后带着她的电脑走向食堂（食堂里有供学习的桌子）。然后她熟练地敲着代码，没过多久，就把我的名字显示在了屏幕中。我当时心情很澎湃，我觉得她太牛了，然后给我讲了讲实现的原理，也很容易听懂，我当时根本听不够，让她在写点。为了让她多教我点，满足我的好奇心，我请她吃了顿海底捞，另加一顿正宗日本寿司?。</p>\n\n<p><span style=\"color:rgb(0,0,0);font-size:22px;\">大三下：工作与考研的抉择</span><br /></p>\n\n<p>	现在大三下学期是开学刚回到学校，今年过年较早，大概是2月份多就开学了。春天还要过段时间才到，东北的天气非常冷，地上结满了冰，寒风刺骨，冷风打在你的脸上让你透不过气。</p>\n\n<p>	文都考研的小屋子里暖暖的，似乎让我们忘记外面刚下过雪的天气。我们俩认真仔细地听着小姐姐为我们介绍他们考研的课程、规划、教师，以及他们要吹到天上的押题。当时我们有一种感受，文都考研的老师很牛啊，年年都能押准题，有这样的老师我们能考不上研？</p>\n\n<p>	最后一听价格，3万多块钱。。。对我这种贫困家庭来讲，简直就是天价。我们在进文都前就商量好，如果报考研班超过5千的话，我就在考虑考虑（女朋友家境还挺好的，不比为报班价格担忧）。我没有接下去问其它的关于考研的事情，我现在脑子里嗡嗡的，这钱该怎么朝家里要，家里现在这情况恐怕也拿不出来，我就找了借口说：我在考虑一下，找父母商量商量。临走前还送我们关于考研的几本书，还真的挺不错，但是外面太冷了，用手拿着是真冻手啊。</p>\n\n<p>	“走吧，去食堂”。我俩来到了食堂三楼，我拿起了电话，拨通母亲的号码。我妈属于那种被情绪所支配的重度患者，情绪一上来，几乎失去理智，让你感觉似乎在和一个与别人刚发生过口角的人交谈。  “儿子，干啥，别和我谈钱，说啥都行”。 我挂掉电话，叹了口气，我这善解人意的女朋友拍拍我的肩膀说：没事，我报完班还给发网课，我白天去上完课，晚上回来给你讲。我不知道为啥我这大男人当时眼泪哗哗的。</p>\n\n<p>	因为我自身的基础不太好，所以就放弃了考研。自己念的是师范学校，但是确实对教课提不起兴趣，事业编更是不在乎这东西，我觉得个人有能力到哪里都是稳定。</p>\n\n<p>	在知乎和她导师的建议下，我去学了Java，此时，我的计算机之路就开始了。她呢，选择了考研，因为她想要稳定工作，想当老师拿个事业编稳稳的生活。</p>\n\n<p>	<b>我们俩对于未来的规划从此刻分生了分歧。</b></p>\n\n<p> </p>\n\n<h2><b>人生绝望之路 与 北京互联网公司的实习之路</b> </h2>\n\n<p>	 此时大三下快要结束了，我的Java跟随bilibili上面的网课也学的差不多了，现在是7月份，我刚刚从本专业的期末考试考场出来，一身轻松。</p>\n\n<p>	在此我要跟感谢一个人，他叫“<strong>十眠</strong>”（花名），19届毕业（非科班），现在阿里巴巴中间件部门，担任微服务开发工程师。</p>\n\n<p>	这位大佬帮助了我很多，也是让我知道了Java还要学习框架，操作系统，计算机网络，算法，并且告诉我了很多捷径和我不知道的，少走了不少弯路。现在是7月，离校招还有两个月，开始了我的疯狂学习时刻，说实话，我从来没在学习这么努力过。</p>\n\n<p>	我每天从早上6点到晚上12点，在家属楼里有个空屋子，就是学，看书，背概念，刷题，看到哪本书好，就买哪本，疯狂补习，到头来应该看了有10多本把，其中有几本书读了4遍，比如《深入理解Java虚拟机》、《Spring实战》等，算法题也刷了不少，实在不理解的就背。我这个人有个优点，觉特别少，每天睡5到6小时足矣，没有睡懒觉的习惯，可能我还是太年轻了，身体好。我记得有一次我连续学了一个星期没睡觉，后来躺在床上心脏隐隐作痛，但是嘴里却笑开了花，因为我感觉已经很有把握找到一份还算可以的工作，可能进不了大厂，但是能进一家其它公司（除了外包），我也知足，对得起我这几个月的努力（其实，我当时的目标就是要考进阿里巴巴）。</p>\n\n<p>	后来在9月份的时候，拿了一家不错的公司实习offer，在杭州，超级兴奋，以为我迎来了人生巅峰。正要我高兴地签下，学校通知要求9月和10月集中实习，不得请假（请假不发***），也代表着我不能去实习。<strong>大家都知道校招金9银10，</strong>这也代表着校招也没时间参加了，毕业工作就不能找了。。。（实习还不能去，工作还没时间去找）我当时心凉凉的。   校招我不能在本校参加，本校来的公司都很差，必须到本市的吉林大学去参加，路程很远。 <strong>什么是绝望，就是你抬头看着星星，星星很美，你却很无奈。</strong> </p>\n\n<p>	<strong>车到山前必有路。</strong> </p>\n\n<p>	我听从学校安排去实习，白天教完课到下午5点，没时间吃晚饭直接坐公交大概将近2个小时到吉林大学参加校招，每晚参加2个招聘会，答笔试题，参加面试。每天晚上回到自己学校都要10点多快11点，然后在楼下买泡面和肠对付着吃一口。现在想想那时候的苦我是怎么吃的。</p>\n\n<p>	找工作的这段时间，遭受到了无数的打击和挫折，面试官看到我的简历里的学校直接把简历还给我说：很抱歉，我没听说过你的学校！</p>\n\n<p>	每天晚上坐轻轨回来，都要看着窗外发呆，你说我想事情呢？也没有，想题呢？也没有，可能只是觉得有点绝望。  我这人有点就是自信，虽然我这几个月扎扎实实的准备了准备，但肯定还是与985的学生有差距，但是我就是觉得比他们强，我甚至与面试官宣称：别看我出身二本，我的技术不亚于吉大的这些学生，不信你找几个来比试比试。。。  后来有个做航天局的公司看我不错，面试官说可以，帮我争去争取，但是最后因为学校原因被拒，他们说211可能都得考虑考虑，你的学校无法录入公司信息库里。。。。。这都是什么奇葩理由，不过我已经习惯了。</p>\n\n<p>	每天晚上回来，都会看到一些刚从网吧，或者刚送完女朋友回来的同学们，我打心里羡慕他们，<strong>处处对象上上网它不香吗？</strong></p>\n\n<p>	在9月尾也磕磕绊绊拿到了几个offer，权衡利弊去了一家国企，就是为了图个稳定，而且还在西安，西安的房价还不是特别可怕。（我太天真了）</p>\n\n<p>	我学校实习结束之后，没什么事做，想提前接触一下Java真正的开发，顺便挣点钱。经女朋友导师介绍，去了北京一家互联网公司实习。</p>\n\n<p>	我们两个后来也和平分手了。我想去大城市，而她要考研以后留在家乡当一名人民教师。</p>\n\n<p><span style=\"color:rgb(0,0,0);font-size:22px;\"> 公司的实习经历</span><br /></p>\n\n<p>	<strong>公司情况：</strong> </p>\n\n<p>	刚来的第一天，同事帮忙安装电脑，端茶倒水，那家伙，让你觉得好像回家了一样，超级温馨。</p>\n\n<p>	技术总监耐心地给我讲业务，一点领导的架子都看不到，还以为他是你的学长呢，下班后还时不时地问问你今天工作怎么样，顺利不，哪里不会及时问。</p>\n\n<p>	我的导师是一名在读硕士，人很聪明，情商极高，经常换位思考，为其他人着想。在与他交谈的过程中真的能感觉到，情商这个东西，在他身上体现的淋漓尽致。</p>\n\n<p>	这是一家刚起步创业的互联网公司，在工作中会经常加班，11点多下班也比较常见，但是在这里是实打实的能学到知识，有一次凌晨2点下班后，我在路上突然忍不住笑了出来，心里想：这波实习来的真值。 不管我有多晚下班，心里从来没埋怨过，加班使我开心，更快的成长。</p>\n\n<p>	<strong><br /></strong> </p>\n\n<p>	<strong>住宿、室友情况：</strong> </p>\n\n<p>	我是在清华大学里家属楼里租的寝室，4个人一屋，来的都是应届生在北京实习和在清华做科研的，也是运气比较好，这三个魔鬼分别来自浙大、上海交大、哈工大的，你们想不到我一个二本菜鸡跟他们一个寝室是有多被虐。这几个人，每天晚上能学到后半夜，整的我都不好意思睡觉了?，也被影响的也下来看看书，慢慢的学习习惯就跟着他们养成了，到了现在每天不管都忙都会看看书，看点东西，学习这种事几乎没断过。</p>\n\n<p>	清华大学进进出出呆久了，慢慢感觉自己也是一名清华的学生，哈哈哈哈哈我真不要脸，后来跟门卫都混熟了，还互相加了微信。</p>\n\n<p>	<strong>收获：</strong> </p>\n\n<p>	1、除了一些实打实的技术之外，还收获了各大公司同事的友谊，我性格较开朗，经常参加社交、聚会、运动之类的，所以在北京的这几个月的日子，也算是交了不少朋友。尽管他们现在去了不同的公司，现在没事也会聊一聊，保持着联系。</p>\n\n<p>	2、这第二个收获我觉得是最大的，北京实习之旅让我知道了很多互联网相关的岗位都是做什么的，相互之间什么关系。如：运营、项目经理、产品经理、算法工程师、各种后端语言、区块链、比特币等等。来到北京真是涨见识了，同事天天跟我讲这些新鲜玩意儿。</p>\n\n<p>	在我知道这些新鲜玩意儿之后，我大概明白了这些方向的未来发展，我渐渐确定了自己未来如何发展，自己适合做什么，为人生如何做规划，这些东西在学校根本了解不到。</p>\n\n<p>	<strong>注：</strong>有很多人说北上广深有什么好的，消费高，房价高。 <strong> “这就是你我的区别，没来过北京闯荡一番，你的目光永远都是这么短浅</strong><strong>”。</strong> </p>\n\n<h3>	<strong>如果问我步入人生正轨在什么时候，北京实习之旅就是我人生的转折点。</strong></h3>\n\n<p> </p>\n\n<h2>毕业后：国企工作之旅开始</h2>\n\n<p>	毕业后的工作是一段漫长的长跑，只要你保持自己可适应的速度学习，对别人来说就已经是超速发展了。</p>\n\n<p>	以为来到国企就是人生幸福的开始，我的单纯再一次给我泼了一盆冷水。先是转到做安卓，后来又转到Java，就换了个部门，跟着做项目。我导师30多岁，是被挖来的高级工程师，是个技术大牛，他孩子不大，所以每天不怎么加班回去看孩子，平时工作也很忙基本上没怎么带过我。由于经验欠缺，业务和代码规范上面都不懂，想问都找不到人，一个推一个，我只能自己在代码上面试错。第二天做不好项目经理还要批评，我有不懂的问项目经理，他还不告诉我，用鄙视的眼神看着我。。。他可能以为这么简单的问题也不知道？大家都是从0到1走过来的，生而为人，留一线，未来大家的路都好走。 </p>\n\n<p>	 我与导师的关系应该属于：工作中我就不多照看你了，但是在领导面前我多夸奖你，我们俩互相给面子，给台阶下。</p>\n\n<p>	从此刻，我从一个性格活泼的孩子，渐渐变成了不爱说话的成年人，变得越来越看透不说透；遇事脸上渐渐没有了表情，变得越来越淡定。</p>\n\n<p>	公司有个搞测试的跟我讲：我C，C++，GO，Java，C#都会，大学编程没有对手。    我装作一个成熟人嘴上讲：你很厉害，有很多东西需要向你学习。        我心里想：傻 13，你这么牛逼去搞测试？</p>\n\n<p>	国企工作压力确实比互联网好很多，工作强度也不怎么大，还包吃住。</p>\n\n<p>	我上班时间：8：30 - 4：30，双休。</p>\n\n<p> </p>\n\n<h2>杂谈</h2>\n\n<p>	最近看到帖子里有很多19届应届生被裁、裸辞、也有在工作不顺心下痛苦的忍受。 我与你们同样，工作生活也没有好到哪里去，那些在工作生活当中顺风顺水的人，我猜当初他们也有像咱们一样有难受难熬的日子，如今他们熬过来了，变成了我们羡慕的对象。</p>\n\n<p>	 我从上个月开始有无数次想要离职的想法，但是因为我的家庭经济条件不允许，只能被迫继续上班，尝试着投简历，但是当初学的东西和实习的工作经验早就忘得一干二净。投的简历石沉大海，根本无人打捞。每天在沸腾的水中挣扎着，毕业后半年工作经验基本可以不计，加上自己不是科班出身的专业，让我的裸辞更加的难上加难，雪上加霜。后来问了一问一些有经验的朋友，大家都不同意我裸辞，现在大环境不好，裁员太严重，辞职多半找不到下家，如果去了外包，真不如回家考公务员了，没什么意思。在做完了心理建设之后，坚持工作吧，这些事都不放在心上，沉下心学习，一点一点来，努力个三年，把技术稳定沉淀下来，然后回到杭州买个房，过个舒服日子。</p>\n\n<p>	<strong>我对于加班的看法：</strong> </p>\n\n<p>	<strong> 1、如果我得到一天8小时的报酬，我就工作10个小时。<br /></strong> </p>\n\n<p>	<strong> 2、努力的人很多，我要比别人更强，就要多付出，把业余时间也利用起来工作学习。<br /></strong> </p>\n\n<p>	<strong> 3、幸福是奋斗出来的，为了以后的幸福，为了延迟满足，现在多多付出，多多加班也无所谓的。<br /></strong> </p>\n\n<p>	<strong>4、有人会问，身体怎么办，我每天都会晨跑，手机很少玩，自从放下手机后，睡觉的时间真的多出不少。</strong></p>\n\n<p> </p>\n\n<h2><strong>我的工作经验之谈（不保证全对，只是自己的观点）：</strong> </h2>\n\n<p>	1、我不建议去签了offer的公司实习，实习的话换个公司，如果这家公司不错你很满意，就留这里（你现在是脚踏两只船），不满意就去签了offer的公司。</p>\n\n<p>	如果你直接去了签offer的公司实习，工作不顺心，团队气氛不好，你离职了，那你一条船都没有了。    你可以骑驴找马，但是这样边工作边找下家会比较累。</p>\n\n<p>	<strong>血的教训：我当初因为贪图稳定和新鲜感，就辞掉了实习公司，导致现在后悔想哭都没地方哭，我就是一个小傻瓜。</strong></p>\n\n<p>	2、学习订的目标越高越好，你定的目标是阿里，即使努力后没去上，但也不会太差；如果一开始订的目标一般，没达到的话，去的公司就更一般了。这是我个人的学习策略，不知道适不适合其他人。</p>\n\n<p>	3、之前牛客开了个帖子，毕业工作后是否会交到真心朋友。我个人觉得与同事间只有同盟，没有朋友一说，同事都和你是有利益捆绑的人。你要是想交朋友，到别的社区、公司或爱好群去交友谊去。</p>\n\n<p>	4、业务比代码重要，代码只是实现方式而已。</p>\n\n<p>	5、多想想为什么，这是我那个高级工程师唯一教我的东西。</p>\n\n<p>	6、不要与同事说你的家庭，私事，你的朋友关系网，别人知道的越多，你越危险，多听听别人的秘密，自己少说话。你不仅做了一个合格的听者，而且还知道了关于他或公司内部的一些事。</p>\n\n<p>	<strong>7、你去了哪个公司真的不重要，重要的是你的团队，去BAT没人带你，团队气氛不好，也白扯。你去了团结的队伍，工作很顺心，能真真正正学到东西才是校招的胜利。我在北京的时候，加班都是开心的，晚上2点回家乐开了花，做为过来人非常重要的建议</strong><strong>。</strong></p>\n\n<p>	8、工作中特立独行（策略），生活中随大流（了解其他人）。工作高调，生活低调。</p>\n\n<p>	9、最好发展一个工作外的兴趣，比如我喜欢历史学和经济学，每次出去吃饭都会给他们讲一些与生活相关的经济学，讲讲历史中的孔子、老子、西游记（西游记原著与电视剧里演的完全不一样，其实唐僧是个感情大骗子，取经也是被逼的）之类的，吊吊大家的胃口。曾经有一次，上厕所的时候，同事说：我真羡慕你，书看得多，长得还高，哎。</p>\n\n<p>	9<strong>、给自己3年期限，坚持不懈地向着某一方面的专家目标而奋斗。</strong> </p>\n\n<h2>	在此要感谢帮助过我的人：</h2>\n\n<p>	1、十眠（阿里巴巴微服务开发工程师）</p>\n\n<p>	2、李苦李（在百度在3年之内连升3级从T4 - T7，后担任华为架构师）</p>\n\n<p>	3、冯东东（西北工业大学硕士，还未毕业，即将进入BAT实习的大佬）</p>\n\n<p>	4、CyC2018（中山大学硕士，现任字节跳动go工程师）</p>\n\n<p>	还有一些其他帮助过我的人，我就不一一列举了，你们的帮助我铭记在心里，感谢大家，此致，致敬。</p>\n\n<p>	如果大家有什么问题可以加我私聊我，或者要我的微信。</p>\n\n<p>	<b>我的言论可能对某些人的利益有冲突，或产生误解，先提出抱歉，但是最终的解释权还是归我所有。</b> </p>\n\n<h2>	牛客网就是我们的家，我们的避风港，祝牛客发展越来越好！！！！！！！！！！！！</h2>',2,4,0,2,0,0,1,'2020-05-03 15:54:01','2020-05-13 18:49:21'),(11,'入职一周年啦～','太长不看版：    1、读博更像是选择职业，而不是学历，要慎重一点     2、工作了也没那么惨，也可以像以前一样保持良好的心态     3、长大后确实不像小时候那么简单了，各有各的好处吧     4、对于一些暂时没有答案...','the-first-anniversary-of-entry','<p><strong>太长不看版</strong>：<br /></p>\n\n<p>   1、读博更像是选择职业，而不是学历，要慎重一点 </p>\n\n<p>   2、工作了也没那么惨，也可以像以前一样保持良好的心态 </p>\n\n<p>   3、长大后确实不像小时候那么简单了，各有各的好处吧 </p>\n\n<p>   4、对于一些暂时没有答案的问题，可以先放在一边，踏踏实实走好每一步，等到了某个时间，某个阶段，可能自己就有答案了</p>\n\n<p>正文：<br /></p>\n\n<p><span>去年6月7号实习生入职的，到今天刚好一周年，正式入职在4月1号，到现在两个月多一点</span></p>\n\n<p><span>实习这么久完全也是自愿的，因为学校离得近，不耽误事，毕设在公司抽时间做的，想出去玩了就直接请假，没有kpi的实习还是很开心的，效率也比我在实验室高很多....研究生两年半，更多的是在公司而不是学校，在导师公司实习、出去找实习，只有空档期是在实验室过的。大学时还觉得读博除了要花时间外其他也无所谓，毕竟上了这么多年学，还在乎多几年吗。现在越来越觉得并不是所有人都适合做科研的，以前觉得上学也还行是因为大家都在做这个，也没有别的可选。但是现在看来，我可能并不能一个人静下心来坚持那么久，而且能力确实也有限。科研就交给大佬们去做了，有你们，我很放心</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>很久以前就在想一个问题，大家都说在学校的时光是最好的，确实也不错，但工作之后真的有那么不开心吗？以我一直以来的经历来看，那些上班的人过得也还可以啊，但是脑子里一直有一种枷锁一样的想法：“或许他们背后真的很惨只是你不知道呢？” 直到有一天，一个同事跟我说，他觉得工作以后比上学更开心，因为能做的事情多了很多，而且...有钱了。那一瞬间我终于打破了以前的固执，开心就是开心，不开心就是不开心，我觉得开心就行了，不用管大家怎么说的。我上大学的时候很开心吗？现在想是挺不错的，但当时学习、社团一堆事，还天天发愁没女朋友（当然现在有了。。。），我上一段实习开心吗？包吃包住，月入过万，认识了一群大佬，学到很多技术，多棒啊。但是，我当时是很清楚我不想在这里待下去的，因为没有氛围（现在可能好很多了吧）。离开之后，带走的大都是快乐的回忆，活在当下，看到的更多的是痛苦。我在回想各种经历的时候总是很开心的，但其实我当时过得也并不是那么好吧。或者说，当时我更注意问题的细节，而不是过程中的心情。小时候烦恼小事情，长大后烦恼大事情，小时候更有耐心去等待小幸福，长大后有能力去获得更大的快乐，虽然程度不一样了，但快乐与烦恼的比例是差不多的，都是二八开。只是阶段不同而已，你还是你，没必要分开看</span></p>\n\n<p> </p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>虽然工作也没那么神秘，不会一下子改变一个人，但是还是有一些事情随着年龄增长在变化的。举个简单的例子，小时候我不管什么游戏都能玩得很开心，天天打游戏都不觉得累，现在一想到换新游戏玩就又要花很长时间去练习就经常没有心情，这时候就觉得自己老了很多...原因有很多吧，大家都很忙，没有一堆人陪我一块打游戏了，而且见到的东西多了，就会觉得一些事情也就那样吧，觉得amazing的阈值更高了，还有就是，有了一些更实在的压力，天天都有事情做，也没有多少闲时间去娱乐。想要独立自由还是要付出代价的，正式工作之后反倒觉得自己还不如实习的时候有钱，那时，想怎么花就怎么花</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>工作的时候经常会想，我做这个有什么意义？先不说改变整个行业什么的宏伟目标，就简单的，对我有什么提升，我是不是在单纯的卖时间换钱。我也是普通人，不像身边的大佬们，有些上学时就做出了一定成果，有了自己的方向。我在工作时也是像一块砖，哪里需要就往哪里搬的感觉。在当前的平台上我能做一些事情，离开了这个平台我能做什么，这段时间做这个项目，过段时间又做另一个项目，这些项目之间可能并没有什么关系，几年之后，我的竞争力在哪？去年向主管问过这个问题，主管先是让旁边的博士回答（阿里星大佬...），大佬说，他在博士低年级的时候，也是不知道自己做的事情有什么意义，一直到博五、博六的时候才感觉对这个领域有了一定的理解，形成了自己的方法论，而且道理是相通的，懂了一个领域之后再看其他问题也就比较简单。然后主管说，刚毕业考虑到这些是挺好的，但是不用想太多，先把师兄安排的工作踏实得做完，一定要做得踏实，等做了几个项目，有一定积累的时候再去看这个问题，感觉就不一样了。虽然主管这话听起来像是讲大道理，好像背后就是“老实干活就行，想那么多干嘛”。但是我觉得我还是很相信我们主管的，这个回答我就先接着，我愿意先去好好学技术先去做几年，后面再看。而且，当下这么做好像也不吃亏...</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>最后再说一些入职以后的感受。师兄师姐们人很好而且大都是校招的同龄人，大家也都喜欢玩，工作也挺开心，但是可能也是工作的原因，总感觉关系差那么一点。有些事情我会跟大学室友说，而不会跟同事说，虽然后者平时接触得更多。入职之后有各种培训，认识了很多其他部门的人，有校招的也有社招的，大家能力都很强，很靠谱，而且一起玩得很开心。感觉在培训时认识的人没有那种隔阂，可以更随意一点。在互联网公司人员流动还是很大的，实习的时候带我的师兄离职了，还是很难受的，没想到这么快。后面，就逐渐就适应了。公司不像学校，换个地方也很正常。最后，按我们老大说的，\"能进来的人，能力有高低，但是大家都不傻，千万不要耍小聪明\"。岂止是不傻，真的不敢小看任何人，我要学的还很多。先好好工作，好好学技术，以后再边走边看～</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>p.s. 今天是高考第一天，白天在知乎看到了一个衡中学生的演讲视频，讲得很不错啊，七年前我们也那么有活力，为了一件事坚持了那么久。下面有些人说内容比较空洞，生活没有那么多梦想和远方。我倒觉得，生活什么样并不需要别人告诉我，而是要自己去体会，别人的生活也不代表是我的生活。就这么简单一点，相信人间值得，未来可期，挺好</span></p>',2,4,0,1,0,0,1,'2020-05-03 15:57:24','2020-05-13 19:08:23'),(12,'工作半年程序媛的碎碎念','毕业后的时间过得飞快，不知不觉成为职场人已经七个多月了，趁着年末需求少（我开玩笑的）来和各位准程序员/媛分享下我这半年的工作和生活。 首先简单自我介绍一下，19届双非硕算法岗，18年在微信实习，后顺利转正。...','half-a-years-work','<p>毕业后的时间过得飞快，不知不觉成为职场人已经七个多月了，趁着年末需求少（我开玩笑的）来和各位准程序员/媛分享下我这半年的工作和生活。</p>\n\n<p>首先简单自我介绍一下，19届双非硕算法岗，18年在微信实习，后顺利转正。秋招时没怎么找工作，就面了一家pdd，权衡利弊后还是决定留在微信。<br /></p>\n\n<p><br /></p>\n\n<p>题外话，去年比较两个offer时还纠结了一番，咨询了许多牛友和身边的朋友们，那段时间有好几个朋友也有着相似的纠结，纠结要不要异地的，纠结要不要放弃以后社招可能进不了的大公司大平台的，最后还是选择follow my heart。</p>\n\n<p>如果选A比选B更不甘心，选相对让自己甘心的那个选项，就不会有太大问题。<br /></p>\n\n<p>我是19年5月入职的，作为组里唯一一个女生，没怎么享受到网络上广为流传的那张若干男程序员围着一个女程序员debug的图的待遇，反而越来越汉化，不怎么化妆，唯一不好的地方在于没法向组里任何一个小哥哥借头绳扎个头花。<br /></p>\n\n<p>我的工作可能和大部分算法岗同学不太一样，不是那种纯做业务的，也不是那种纯做模型的，我想我的定位大概是一名支持算法同学所做业务的开发。这半年来搞的比较杂，深度学习模型也有、聚类算法也有、树模型也有，都需要研究算法原理、学习源码再决定是修改源码还是新造一个更快的轮子。<br /></p>\n\n<p><br /></p>\n\n<p><br /></p>\n\n<p>鹅厂嘛，以C++为主要语言。而我的基础，怎么说呢，就是很差，本科学通信的，和计算机相关的是数据结构和微机原理，C++是六七年前学过一点最简单的语法，到研究生阶段早就忘得一干二净，毕竟python is enough。去年微信二面，面试官说听说你不会c++那我们用c++写一道算法题，我的内心一边一万只可爱的小羊在青青草原上欢快地奔腾，一边一点点地把queue vector从从记忆深处挖出来终于AC了，尽管过程很痛苦，但是结局还是挺美好。</p>\n\n<p><br /><br /></p>\n\n<p>上个月接了一个需求，大概内容是将优化一个开源实现以满足例行更新需求，我在组里没有人有足够经验、不知道需求是否可行、网络上没有多少资料的情况下做了三个星期差点放弃。深夜在四下无人的街道上放声大哭，哭完还是默默回宿舍，凌晨两点多默默拿起论文推导可行性。不夸张地说，那段时间，做梦都在想着这个需求，也顾不得在微博上磕小鲜肉弟弟，就在知乎上搜关键词学习一点相关知识，早上想出一个solution，白天实验，晚上否定早上的想法，每天就在希望-绝望中度过。最终在第四个星期峰回路转，写了一版满足需求的算法实现，最终优化后的实现速度是开源实现的100+倍。</p>\n\n<p> </p>\n\n<p><br /></p>\n\n<p>我不是那种非常有抱负的人，工作以后发现写代码就是图开心，特别是自己完成一个一开始觉得自己完成不了的需求，真的很容易热泪盈眶，为了这一刻，我愿意在此之前过得苦一点儿。</p>\n\n<p><br /><br /></p>\n\n<p>个人觉得，应届生/实习生基础差点没关系，重要的是向mentor/上司体现自己的靠谱。把一个需求交给我，虽然我不一定能马上找到最好的解决办法，但我能逐步能够给出优化方案，或者能够说明为什么这玩意不可行，并且给出证据证明不可行性。</p>\n\n<p><br /><br /></p>\n\n<p>要说生活和学生时代有什么不同，可能是可支配的时间变少了。我刚入职时，每个周末都会工作去公司加班（划水），后来一想呀这样和996有什么区别呢？就慢慢调节成没有非加班不可的原因（比如预估这个需求没法按期做完）才去加班，渐渐地，我就实现了双休自由，当然代价就是工作日的工作时长有所增加，加班情况看需求的完成程度，朝十晚十是常态，需求比较难时常常想起要下班时已经十二点半了。不过最近自己发起了早下班运动，争取每天十点下班，如果超过这个时间，回家路上的路边摊就一个个支起来了，点一盒水果，点一个手抓饼，再来点红薯，呀，真香。</p>\n\n<p><br /><br /></p>\n\n<p>你说我过劳肥？不存在的。经过观察，体重和需求容易程度呈负相关，如果发现我最近有长肉的迹象，那一定是我的需求不饱和，宵夜这锅绝对不背。</p>\n\n<p><br /><br /></p>\n\n<p>工作以后还是要保持运动的习惯，夏秋时我还能七点起在瑜伽垫上扑棱两下，或者傍晚去上个健身团课，又或者晚上十一点去健身房自己跑个几公里。入冬以后就很少锻炼了，常常一睁眼就九点了，偶尔去上健身团课，偶尔周末自己去徒步个20公里。一个月就四个周末，且过且珍惜。不能太贪玩，也不能只把注意力放在工作上。</p>\n\n<p><br /><br /></p>\n\n<p>每周都要元气满满吖！</p>',3,4,0,1,0,0,1,'2020-05-03 16:00:00','2020-05-13 19:09:09'),(13,'程序猿外企工作体验分享帖','有关经历，本科重大，荒废了四年，考研二战，没去到目标学校，调剂中科大软件专硕，由于学校原因，研二一年都在企业实习，到19年3月份毕业已经换过三家实习企业，包括ebay，商汤，趣头条。秋招没有更好的offer的情况...','sharing-post-of-working-experience-of-procedural-ape-foreign-enterprises','<p>有关经历，本科重大，荒废了四年，考研二战，没去到目标学校，调剂中科大软件专硕，由于学校原因，研二一年都在企业实习，到19年3月份毕业已经换过三家实习企业，包括ebay，商汤，趣头条。秋招没有更好的offer的情况下暂时签了趣头条，最后抓住了春招的尾巴，改签paypal，直至现在。<br /></p>\n\n<p>有关实习和秋招，因为很少学校会像我们学校一样，研二强制出去实习，并将实习期长短作为毕业标准之一，所以有幸能提前感受下不同企业的企业文化和工作环境，不幸的是学校规定的毕业论文提交时间和秋招时间重合，顾此失彼，秋招没有合适的offer，只能破釜沉舟等春招。这里其实不建议大家像我一样把宝都压在春招上，因为谁也不知道明天会发生什么，比如春招刚好遇到互联网低潮，企业大裁员的话真的很惨。能赶上内推就不要等正式招聘，能赶上秋招就不要等春招。尽管这样，春招那段时间仍然是进军大厂的黄金时间，因为大部分公司会在这个时候进行实习生招聘，如果成功进厂并转正，比秋招冲击大厂几率更大。</p>\n\n<p><br /></p>\n\n<p>有关工作经历和体验，因为我本身技术一般，所以履历平平，所以只说感受，给大家参考。</p>\n\n<p>首先关于工作时长，1065的外企和10106的国内互联网企业，我选择了前者。因为身体真的吃不消，打着年轻就该奋力拼搏的旗号并没有让我在重压下脱颖而出，反而耗尽了心力和时间，没时间充电，但是工作的成长空间又很有限，在极易和同学拉开差距的前几年一直处于这样的状态就会很焦虑，最后的结局就是同时熬坏了情怀和本钱。外企的工作时间和工作内容都相对灵活，工作压力不大就会组织各种趣味比赛，及各种辅助小工具搞起来，工作体验会相对愉快。以我们组为例，有几位大牛坐镇，分别负责不同的业务线，每个新人入组时会分配老员工带你熟悉业务和工作环境，因为组内氛围和谐，没有特别多的无谓竞争和推锅，工作和沟通效率就会高很多。唯一遗憾的是因为外企的性质，跨组合作的情况较多，不同组进度之间相互制约，会导致上线流程繁琐且时间较久。根据前人总结的经验就是，保持自己的节奏，保证自己的代码质量就可以，接受了这种工作形式，便会形成对应的工作方式。当然这种形式并不是完全没有好处，从大的层面来说，职场不仅要求我们的专业能力过关，同样影响了并检验了我们的软技能如沟通技巧，处事能力，和语言技能，paypal全英文的工作环境，来自新加坡，印度，美国等全球各地的同事，做好本职工作不仅意味着编程能力过关，就像我manager讲的，还要学会与人沟通。</p>\n\n<p>另外一点要讲的就是，第一份工作到底要不要选择相对轻松的外企。我的观点在于，不要让重复的工作占据你本应拿来思考的时间。能在踏入社会初期就明确的知道自己想干什么，能干什么的童鞋总是幸福的，为了喜欢的事情付出时间和精力总是不嫌多，但是大部分如我一样的普通人依旧迷茫，被动的完成下发的需求，被动的学习相关技能，最后的结果也许不会太差，但随着时间磨砺沉淀，我们终究会发现，曾经因为生活错过了什么。所以有时间思考和选择不见得是坏事，都说程序猿也是吃青春饭，在35岁之前想好自己想干什么，有时间调整，有时间充电为将来准备，有时间健身，保持良好的作息和生活习惯，或许也是幸福人生的一种方式。所以关于外企会把人呆废这种说法我本身并不赞同，倘若你知道自己欠缺的是什么，想做的是什么，又怎么会允许自己虚度时光？<br /></p>\n\n<p><br /><br /></p>\n\n<p>企业文化对每位职员的影响潜移默化，身处其中我们总是不自主的被身边的同事影响，如果你总是吐槽同事的工作方式，吐槽公司的制度，吐槽你的工作内容，那么为了适应当前的工作，你所作出的改变必定不是你本心所愿，为了避免这种被动成长，选择自己喜欢的并享受当下，才是最佳选择。</p>',4,4,0,1,0,0,1,'2020-05-03 16:02:24','2020-05-13 19:10:39'),(14,'19届bytedancer，入职感悟，欢迎回帖提问交流~','985本硕，字节跳动商业pm，19届校招生，已入职5个月 可能因为身边业务高速发展，发现从leader-&gt;leader’s leader-&gt;身边pm同事不仅background+职业履历光鲜、对业务理解广而深、一个个都是nice&amp;smart的代名...','19th-bytedancer-introduction-welcome-to-ask-questions-and-exchange','<p>985本硕，字节跳动商业pm，19届校招生，已入职5个月<br /></p>\n\n<p>可能因为身边业务高速发展，发现从leader-&gt;leader’s leader-&gt;身边pm同事不仅background+职业履历光鲜、对业务理解广而深、一个个都是nice&amp;smart的代名词（亚历山大。。但是坏处其实也有，比如因为大家太忙而对新人关注不够，</p>\n\n<p>以及入职前就有心理准备的，字节没什么系统培训。没有系统化的学习mapping，直接业务上操练也是真的，不过这些好像都能一一克服并适应hh（需要强心脏）～</p>\n\n<p><br /></p>\n\n<p>以下是几点感悟：</p>\n\n<p>1、学习什么？业务理解、专业能力、技术算法基础三者相互促进</p>\n\n<p>2、进步的正向循环就像雪球滚起来，更高的做事效率对应着更多的学习时间更深的业务理解能力，而反过来会有怀疑人生的反向循环</p>\n\n<p>3、不做不合理的事情，少做可能有坑的事情。B端PM以及RD每天要对千万流水负责，每天事故通报里各种预估错误+bug真心伤不起，一定要保持清醒的头脑去判断去思考</p>\n\n<p> </p>\n\n<p><br /><br /></p>\n\n<p>产品经理需要做什么？</p>\n\n<p>第一种是对外，主要承担的是销售和宣传的工作，这既需要对产品的深刻理解，也需要很强的沟通技巧。</p>\n\n<p>另一种则是对内，主要承担的是产品和管理的工作，这需要对行业大方向和战略有深刻的认识，知道自己的团队应该往哪个方向走，同时能组织和管理大家朝着同一个方向前进。而能够结合现有资源，有能力发起一个新产品并带领团队获胜，这中间所需的全套方法论，就是一个顶级产品经理的核心竞争力。</p>\n\n<p><br /><br /></p>\n\n<p>如何提高自己在一个公司的成长速度</p>\n\n<p>无论处在什么层级，始终保持全局思考的高度。多承担核心项目，如果没有机会，主动寻找新的突破点，将新突破点变成核心项目。</p>\n\n<p>只有核心项目才能调用核心资源，才能更好地将公司的势能转化为个人的势能。</p>\n\n<p><br /><br /></p>\n\n<p>如有问题，也欢迎大家评论，希望多多交流一起成长鸭~</p>',5,4,0,1,0,0,1,'2020-05-03 16:04:12','2020-05-13 19:12:00'),(15,'应届生应该如何谈薪？','咳咳，最近看到牛客很多牛友谈offer选offer，不知道怎么谈薪资，作为一个从业多年的HR小姐姐，想分享一些谈薪经验给大家~ 在谈薪之前，先讲讲企业的校招薪酬是如何制定出来的，如果想快速看方法论的，直接跳到分割线...','how-should-new-students-talk-about-salary','<p>咳咳，最近看到牛客很多牛友谈offer选offer，不知道怎么谈薪资，作为一个从业多年的HR小姐姐，想分享一些谈薪经验给大家~<br /></p>\n\n<p>在谈薪之前，先讲讲企业的校招薪酬是如何制定出来的，如果想快速看方法论的，直接跳到分割线之后吧。<br /></p>\n\n<p>校招薪酬的影响要素（大体按照优先级排序，特殊情况特殊分析）：</p>\n\n<p>1、过往薪酬：此为基线，基本上如果没有过大的战略规划，都会在过往的校招薪酬上面进行“修修补补”，主要是为了防止薪酬倒挂，其次也可以以过往的薪酬做为校招结果的依据；<br /></p>\n\n<p>2、校招战略：校招战略是最直接的影响要素，举一些例子：</p>\n\n<p>某些公司校招战略——雇主品牌宣传为主，招人为辅（成熟公司、HC开放较少）————校招薪酬较高、HC较少</p>\n\n<p>某些公司校招战略——大批量（规模扩展、部门新建）————薪酬有竞争力，HC较多</p>\n\n<p>某些公司校招战略——重点突破，校园挖猎（核心有价值岗位急缺）——部分岗位薪酬有竞争力，其他岗位薪酬没有太大竞争， 差异化薪酬</p>\n\n<p>但校招战略一般会结合后面的各种因素去合并考虑并得出的。</p>\n\n<p>3、市场行情：公司所在行业的情况（朝阳、成熟、夕阳），校招整体情况（寒冬、暖春、大热），竞品公司的招聘计划；</p>\n\n<p>4、公司本身的战略规划：扩张还是保守、进攻还是防守，是否需要一定程度的变革和换血；</p>\n\n<p>5、公司的自我定位：有些公司定位是科技公司，对于IT技术类就倾斜比较大，有些公司重视营销运营，对于相关岗位就会有倾斜，越优势就要求越高报酬越高；</p>\n\n<p><br /><br /></p>\n\n<p>了解定薪的策略，就知道大概如何进行薪酬谈判了，好的薪酬谈判能很快赢在起跑线上。</p>\n\n<p>对于应届生来说，谈薪要点就是知己知彼，有理有据：</p>\n\n<p><br /></p>\n\n<h2><b>知己知彼：</b></h2>\n\n<p>需要沟通的公司的校招情况：大概能出具的offer数值范围，校招是否爆满（不在乎一个两个HC），是否能够argue，是否有不同的校招线（批发、sp、ssp）；一般来说，小公司可谈的空间会更大，大公司可谈的空间相对比较固定（从一个线跳到另外一个薪酬线）渠道：牛客网、offershow、看准网；</p>\n\n<p>需要沟通的公司的内部情况：校招薪酬决策是HC还是业务部门，有无明确的argue流程，是否有过往的argue成功案例：渠道：牛客网，内推的学长学姐；</p>\n\n<p>自己当下的情况：拿到的这家公司的薪酬范围，如果是批发价，对方公司还是校招爆满的，不太建议强硬的沟通方式，因为argue总归是一个博弈的过程，博弈就涉及心理层面的输赢。</p>\n\n<h2><b>有理有据：</b></h2>\n\n<p>退一步：手头有保底offer，有同类型的公司的offer，心里有底气，能cover到沉默成本（谈崩了，给了公司不好的印象）；<br /></p>\n\n<p>进一步：能力足够强（有明确的背书-教育背景、项目背景、竞赛背景、奖项等等），至少在圈子里有一定的知名度，大佬是有薪酬谈判的权力的，也清楚自己的定位和价值。</p>\n\n<p><br /></p>\n\n<p>举几个想要谈薪的反例（没有太多理由）的：</p>\n\n<p>“我在论坛上看到硕士的白菜价是30W年薪，所以我希望我的薪酬能调整到这个薪酬”——不考虑工种学校背景的学历要价都是耍流氓；</p>\n\n<p>“某某小公司给了我25W的年薪，我希望贵公司能一定的薪酬倾斜，涨幅20%~30%”——说服力不够，有些公司的offer可以作为背书，有些公司的offer没有太大说服力；</p>\n\n<p>“身边朋友拿了20W年薪，我希望薪酬也能有这个数量”——朋友就是对标系列；</p>\n\n<p>“有人说这个岗位可以argue，所以我想试试”——还有人说这个岗位上限不确定，咋不要个年薪百万；</p>\n\n<h2><b>薪酬谈判流程（准备环节忽略）：</b><br /></h2>\n\n<p>1、寒暄环节：客套一下，感谢公司发offer，快速切入正题；<br /></p>\n\n<p>2、呈情阶段：</p>\n\n<p>（1）先提出自己的诉求：我期望薪酬大概是XX万年薪；</p>\n\n<p>（2）再称述原因：</p>\n\n<p>我现在手头拥有XX的offer，薪酬范围大概是多少，因为特别向往贵公司，所以想争取一下；</p>\n\n<p>我评估自己的能力会有更大的成长空间和价值，期望HR大大和业务部门能够满足我的诉求；</p>\n\n<p>如果能满足相应的薪酬，我会在尽快接受offer并且提前实习，提前创造价值；</p>\n\n<p>最后等待结果，并再次感谢对方给与这次机会。</p>\n\n<p>一般来说，如果第一次没有argue下来，又特别想试试，可以二次argue，但不建议事过三。</p>',2,2,0,5,0,0,1,'2020-05-03 16:09:55','2020-05-13 18:49:12'),(16,'从学生到社畜，基础研发的碎碎念','前言   2019，不知不觉已经给上海某厂搬砖一年多了。打开牛客讨论区，看着大家从投简历、跑面试、刷面经、选Offer……两年，回到更加热闹的讨论区也丝毫不感到陌生。 2018年入职某厂后，回牛客只发过几次内推帖，也推...','from-students-to-social-animals-the-idea-of-basic-research-and-development','<p><span style=\"color:rgb(0,0,0);font-size:22px;\"><b>前言</b></span><br /></p>\n\n<p>  2019，不知不觉已经给上海某厂搬砖一年多了。打开牛客讨论区，看着大家从投简历、跑面试、刷面经、选Offer……两年，回到更加热闹的讨论区也丝毫不感到陌生。<br /> 2018年入职某厂后，回牛客只发过几次内推帖，也推了不少同学?。这次回来想给即将成为社畜走向人生巅峰的大家写点东西，无奈腹中无诗书，不知从何下笔，只得拼凑一些文字，碎碎道来。 </p>\n\n<h2><b>  简介 </b></h2>\n\n<p>  本人2018年本科毕业入职上海某厂从事基础架构已逾一年，先后负责公司中间件与治理系统的开发。由于是在基础研发部门，日常的工作与一般业务部门有些出入，本文主要给大家分享一下。如果有对基础研发感兴趣的同学可以私聊我哈~<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191018/468200_1571394826673_FB5C81ED3A220004B71069645F112867\" alt=\"468200_1571394826673_FB5C81ED3A220004B71069645F112867\" /></p>\n\n<h2><b>  关于工作 </b></h2>\n\n<h3>  技术体系 </h3>\n\n<p>   在学校的开发真的很随心所欲，想用啥用啥。<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191009/63_1570614991681_E8F0F86C8708D13BAEA9E3C8B673D517\" alt=\"63_1570614991681_E8F0F86C8708D13BAEA9E3C8B673D517\" /></p>\n\n<p>   但企业里一般都有严格的规范，作为一颗螺丝钉，我们只能选择融入。 </p>\n\n<p>   比如我做SDK开发时，为了考虑兼容性，必须使用JDK7开发（大学时就用8了没想到这辈子还有机会用7。。。）。以前喜欢用开源组件换着用，现在企业开发一般有统一组件，比如消息必须用Kafaka，配置中心必须用zookeeper等。甚至对于变量的命名，都要与团队保持一致。 </p>\n\n<p>   大厂一般还会有一大堆自研组件，比如阿里的sofa，美团的cat，这些组件可能在外面完全没有机会接触，都需要慢慢上手。甚至很多时候觉得自己比新员工的唯一优势就是，更熟练地使用公司系统?。  </p>\n\n<h3><b>  技术包袱  </b></h3>\n\n<p>   承接上一个问题，大厂一般不太喜欢直接用开源组件，因为他们用不了。在学校做项目的时候，一般选最流行的架构，Kubernetes 配套搞起来。在公司呢，发现连docker都用不起来?（公司当时还在用vm）。  </p>\n\n<p>   大厂的架构一般成型很多年了，开源界很多新东西新概念不一定能兼容老架构老系统，再加上一堆自研组件的存在，大厂身上的包袱越来越重。而且不同于学校的小项目，这些包袱清理起来涉及到很多部门的利益（很多组件按开源架构做就被取代掉了），甚至不是领导一两句话就能解决的问题。  </p>\n\n<h3><b>  工作节奏 </b></h3>\n\n<p>   成为一个社畜不是一个渐进的过程，从签合同的那一刻起就已经把自己卖了。刚毕业那会儿，某日早上醒来非常非常想睡回去，非常非常不想工作的那种。但是不行?，想到不上班就要扣钱，就会乖乖爬起来去上班。一周5天工作日，不带休息，项目比较累的时候确实会喘不过气，但是没有办法，签了合同就只能好好工作。 </p>\n\n<p>   假期真的很少很珍贵，工作之后没有寒假暑假，过年甚至只有一周假（超级不适应！！），所以每个周末都十分珍贵。<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191019/6658561_1571454739471_4A47A0DB6E60853DEDFCFDF08A5CA249\" alt=\"6658561_1571454739471_4A47A0DB6E60853DEDFCFDF08A5CA249\" /></p>\n\n<p>   在学校的时候可以学累了摸鱼休息一会儿，在公司就真的不行。感觉领导和同事随时盯着你（然而并没有），看着旁边专心敲键盘的同事，非常不好意思开小差。这种节奏很累，但就是社畜的责任吧，毕竟拿钱办事。 </p>\n\n<p>   <img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191018/468200_1571396661629_9EB9CD58B9EA5E04C890326B5C1F471F\" alt=\"468200_1571396661629_9EB9CD58B9EA5E04C890326B5C1F471F\" /></p>\n\n<h3><b>  加班 </b></h3>\n\n<p>   互联网大多要加班，不加班的同学真的很幸福。8点以后才下班的人，基本丧失了白天的活动能力，因为下班时间比较晚很多事都做不了，晚餐跟朋友聚一聚，回家打几把dota，都成了奢望。特别有时候加班到10点，一般通勤到家差不多11点了?，基本就洗洗睡了。熬夜？不存在的，第二天还要上班呢！<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191018/468200_1571394935765_09DD8C2662B96CE14928333F055C5580\" alt=\"468200_1571394935765_09DD8C2662B96CE14928333F055C5580\" /></p>\n\n<p>   在此墙裂建议大家租在公司旁边，减少通勤成本。我刚毕业的时候下班需要坐地铁，回家大概需要45分钟，加了一天班拖着疲惫的身子挤地铁真的身心俱疲<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191018/468200_1571397817785_7B6FBD4C592D356E087A0F1053751007\" alt=\"468200_1571397817785_7B6FBD4C592D356E087A0F1053751007\" />。 </p>\n\n<p>   可能有的人比较崇尚奋斗，为公司奉献，相信努力一定有回报，但我觉得社畜和公司就是简单的雇佣关系，没必要搞太复杂。同届进来一个同学在业务那边天天加班到深夜，结果18年寒冬试用期前一周被公司优化掉了，下午收到通知，第二天直接走人，资本就是这么无情。 </p>\n\n<h3><b>  兴趣与钱 </b></h3>\n\n<p>   上学的时候真的很喜欢编程，经常研究各种新技术、新特性。曾经破解过校园网、搭过博客（现在还在写咕咕咕?）、写过爬虫，满腔技术热情。但工作跟兴趣真的是两回事儿，工作后基本就缩在项目的技术圈子里，没有接触其它技术的机会，可能很快就会失去新鲜感。下班到家，敲了一天键盘的我看到代码就想吐，已经无力再捣鼓自己感兴趣的东西了。 </p>\n\n<p>   而支撑这种工作的动力非常简单而粗暴——钱。互联网确实是高薪行业，但程序员真的有钱也没时间花。以前认为年轻可以为钱多吃点苦，现在想想多那点钱换自己自由时间不一定值得，因为多的钱也没时间花。<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191019/6658561_1571455041360_4A47A0DB6E60853DEDFCFDF08A5CA249\" alt=\"6658561_1571455041360_4A47A0DB6E60853DEDFCFDF08A5CA249\" />薪资方面，互联网行业是真的会倒挂！而且非常严重，可能明年新员工入职的时候我的薪水才涨到跟他们差不多的程度（是真的）<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191018/468200_1571397153644_2484A7DF36877A14689574EEBDA6DD7C\" alt=\"468200_1571397153644_2484A7DF36877A14689574EEBDA6DD7C\" />。 </p>\n\n<h3><b>  健康 </b></h3>\n\n<p>   做开发的长时间面对电脑，眼镜真的挺难受的。久坐+没时间锻炼很容易发福！键盘敲多了手指真的会酸，办公室待久了皮肤容易出油长痘痘，外卖吃多了营养很差，大家一定要注意身体。 </p>\n\n<h2><b>  关于基础研发 </b></h2>\n\n<h3><b>  底层知识 </b></h3>\n\n<p>   在基础研发的工作主要是跟各种架构、中间件打交道，比如 Kubernetes、注册中心等，可能很多同学在学校中就听说过或者用过它们来开发，但估计很少人直接参与过这些组件的开发。 </p>\n\n<p>   我刚进公司就参与到公司的RPC框架开发中，在此之前我对RPC的了解仅仅局限于使用。是的，好用就完事儿了，好的基础组件就是能对用户屏蔽技术细节，但开发人员则不同。RPC的开发需要对网络、序列化有深入的了解，我不得不翻出大学时的计算机网络，再去看tcp协议，三握四挥，捡起这些业务开发中“不常用”的知识。 </p>\n\n<p>   所以做基础组件开发所获得的技术成长是毋庸置疑的，在这里你永远不用担心成为 CRUD boy。但相比之下缺少业务接触，容易绑死在技术这条路上。 </p>\n\n<h3><b>  严格要求 </b></h3>\n\n<p>   一个业务的bug，可能会影响一个业务功能；一个基础组件的bug，可能会影响公司的所有业务。但凡基础组件出了事故，都是灾难性的。基础组件的开发就是在针尖上跳舞（所以基础组件删库也是最容易的），所以谨小慎微也不为过。 </p>\n\n<p>   做基础研发还容易被业务的同学甩锅（逃），在出现性能问题总是会先想到我们?，所以基础组件的日志、埋点都非常详细，就是为了确保每一个问题都能定位，防止用户甩锅。  </p>\n\n<h3><b>  鞭策 </b></h3>\n\n<p>   基础组件很容易被拿来比较，比如RPC框架有很多，做得不好用户就会喷，还不如直接用开源的xxx呢?。所以做基础组件是一直被用户鞭策着前进的，因为你的用户就是公司的同事，那天伺候不好说不定就找到你工位来了hhh  </p>\n\n<p>   甚至新组件开发完后，业务同事不一定愿意用?，还得像推销一样到处宣传，拉客户，毕竟没人用的组件没有绩效的。  </p>\n\n<h3>  需求  </h3>\n\n<p>   基础组件一般没有做不完的需求，甚至经常愁需求?，这跟业务开发差别很大，所以我们可能相对地轻松一些些（年终奖可能也少一些）。  </p>\n\n<p>   其它有什么想起来的话再补充吧（毕竟是碎碎念），也欢迎评论区互动hhh~<img width=\"100\" height=\"100\" src=\"https://uploadfiles.nowcoder.com/images/20191018/468200_1571397201641_258F63B9448490D648948081E23D86DB\" alt=\"468200_1571397201641_258F63B9448490D648948081E23D86DB\" /></p>\n\n<p>   -----------------------------------------------11月5日更新分割线--------------------------------------  </p>\n\n<p>   没想到收到了那么多小伙伴的回复和私信，哈哈哈哈整个周末都在回复大家了~  </p>\n\n<p>   还有好多小伙伴关注我?，真是受宠若惊，我平时就发发内推关注我干啥呢hhhh </p>\n\n<p>   更新一下回答一些常见问题吧。  </p>\n\n<h2>  FAQ  </h2>\n\n<h3><b>  基础架构 VS 业务开发 </b></h3>\n\n<p>   这应该是问得最多的……实在没法一两句话讲清楚，两者只是各有千秋，并无孰优孰劣。我们部门的对外资料有一句话非常形象，“基础架构就是公司的水和电”，我们提供最底层的资源支持业务开发。基础架构面向的大多是公司的开发同事，所以在研发流程、质量要求、业务价值上都有别于一般的业务开发。 </p>\n\n<p>   不过这都是理论上的理想情况，实际各厂的对基础架构和业务的划分五花八门。很多厂发展时期人力紧张、业务繁忙，没有专门划分基础架构，很多架构都使用开源组件，简单设计，这一般与业务开发是同步进行的。只有现有的架构不足以支撑日益增长的业务需求时，才会抽调人力搞基础架构。所以很多中小厂的基础架构部门非常简单，甚至没有基础架构部门，大家就不必纠结啦。还有某T厂因为历史原因，各事业群泾渭分明，都发展了自己的基础架构，这样的结构导致了T厂内部架构一直很混乱，也是从今年开始号称要着手统一各事业群内的基础架构（据说）。 </p>\n\n<p>   另外，是不是业务部门就不能做基础架构开发呢？当然不是啦，业务同学奋战在一线，往往更能发现开发中的痛点，我厂就不乏许多诞生于业务部门，后期再交接到架构部门的架构组件。此外，上文讨论的都是比较泛用的基础组件，某些业务（如金融业务）需要业务特定的一些基础组件，他们也会组织业务线内的“业务基础架构部”。 </p>\n\n<h3><b>  上海租房 </b></h3>\n\n<p>   真的很贵，仅次于北京吧大概。一般都是合租，合租小次卧2k~3k，主卧2.6k~3.5k这样（体感）。一居室比较贵，一般3.5k+。 </p>\n\n<p>   来租房最简单是找中介，链家、自如等房源很多。想要找性价比高的可以到豆瓣上找找个人转租的房子，比较随缘。 </p>\n\n<h3><b>  Offer 建议 </b></h3>\n\n<p>   理解大家在选择Offer时的纠结，我也尽量给一些参考性意见，但仅限于基础架构和我厂，其它不熟悉的就不方便给意见了希望理解哈~ 并不是因为私信太多了</p>',2,4,0,1,0,0,1,'2020-05-03 16:15:39','2020-05-13 18:47:52'),(17,'这条技术之路走得似乎并没有那么简单','1，技术是否可以永远的做下去？2，技术做久了怎么去转管理岗呢？3，互联网行业这两年似乎到了瓶颈期，以后发展前景会怎么样？ 一，基础技能 我所说的基础技能就是大家的技术能力，这点毋庸置疑，是你在互联网或IT行...','the-road-to-technology-doesnt-seem-so-easy','<blockquote><p>1，技术是否可以永远的做下去？</p><p>2，技术做久了怎么去转管理岗呢？</p><p>3，互联网行业这两年似乎到了瓶颈期，以后发展前景会怎么样？</p></blockquote>\n\n<p><span style=\"color:rgb(0,0,0);\"><b>一，基础技能</b></span></p>\n\n<p>我所说的基础技能就是大家的技术能力，这点毋庸置疑，是你在互联网或IT行业吃饭的家伙。但是我不和大家探讨具体的技术，我想说的是在各个阶段需要的达到什么程度，我从各个阶段的面试要求和腾讯晋级要求来聊一聊这个问题。<br /></p>\n\n<h2><b>（1）校招</b></h2>\n\n<h3><b>基本工作年限0~1年,对应腾讯的T1-2到T1-3或阿里P5的级别,这个阶段关注的是潜力和基础</b><br /></h3>\n\n<p>这个阶段的同学，基本都有过实习经历了，但是在技术上面除了一些个别比较牛的同学外，很多人基本没有对项目有一个很整体的认识，大家在实习过程中，导师基本只是安排一些很基本的任务，只要你能按时，还不能说按量的完成任务，基本你已经算是很不错的实习生了。所以在面试过程中会关注你那些点呢：</p>\n\n<p>&lt;1&gt;基础知识是否扎实。如果你在面试过程中连三次握手都回答不上来，那你基本说明你的面试凉凉了。<br /></p>\n\n<p>&lt;2&gt;是否有很高的学习热情。<br /></p>\n\n<p>这一点说来很很主观，但是在远程面试或者现场面试的过程中面试官完全可以体会的出来的。一个最直观的例子，大家在准备校招面试的过程中，一定都使用过的一个手段就是背面试题，但是面试官在面试过程中，不论是谁都很容易区分出来哪些人只是单纯的把题背了下来，而没有真正理解或掌握这方面的东西，所以这可以理解这个阶段只能证明你记忆力很强，但是学习热情几乎为0。<br /></p>\n\n<p>但是我在面试过程中，发现有些同学确实已经能做到对基础直接的理解并且掌握，如果我只面这些基础知识的话，会发现每个同学都差不多，有时候真的很难定夺谁更优秀，其实做到这个阶段的东西已经说明有很强的学习能力和热情了，基本这部分同学已经能收到比较好的offer了。<br /></p>\n\n<p>那如何从这里面找更好的同学，其实这就要靠你日积月累的学习成果了，所以同学在简历里面附上自己的github地址或者博客文章必然是给你自己加分，但是也是要求有质量的要求，我发现很多同学会把自己在某本书上的demo或者慕课网上的跟着做的项目提交到github上，但是我想说这些并不能说明什么，github上的项目最好是你在做项目或者学习过程中沉淀下来的一些代码，比如我会看见有些同学会把自己刷算法题目的解决思路和代码提交，有些同学会抽取出一些之前做项目沉淀下来的公用代码之类的，还有同学在自己博客上分享自己的学***结，这些完全是可以说明你学习的积极性和热情，并且在面试过程中增加面试官对你的好奇心，比如你为什么会抽取这个组件，你为什么用这种方案实现，所以不管校招还是社招，一定要好好想想，如何去增加面试官对你的兴趣。<br /></p>\n\n<h2><span style=\"color:rgb(0,0,0);\"><b>(2) 社招</b></span></h2>\n\n<p><span style=\"color:rgb(0,0,0);\"><b>工作经验1-3年，腾讯T2-1到T2-3或者阿里P5+~P6级别</b></span><br /></p>\n\n<p> </p>\n\n<p><br /></p>\n\n<p>这个阶段的前1-2年我会把他叫为认知期，在这个阶段很多同学都刚步入职场，你的导师或者leader会慢慢的把很多重要的事情交给你去做，但是更多的事情都会告诉你明确的目标和怎么做，你需要做的只是接单干活。因为在这个阶段你没有经验的积累，很多技术方案、产品方案的制定需要你要对团队或者业务有一个整体的认知，所以在这个阶段你会更像一个执行者的角色，其实我在这个阶段是过得最开心的，只需要做最简单的接单干活就可以了，完全不用考虑沟通问题，方案制定等，完全拼的是体力，所以很多码畜基本就停留在了这个阶段。所以在这个阶段你一定要多看，多想，多问，最重要的是不要忘记学习。</p>\n\n<p>工作了2年左右到了3年的时间，这个阶段我会把他叫为迷茫期。很多同学基本已经已经对团队的业务和技术有了一定的积累，甚至你可能会成为这个团队的一个骨干，这个阶段你可能会感觉你做的很多事情都是重复和无聊的工作，很多人会在这个阶段很迷茫，有时候会觉得自己如果一直这样下去会不会废掉，所以在这个阶段跳槽出去看机会的人会越来越多。</p>\n\n<p>我曾经也有过这样的问题，如果我一直是一个前端切图仔的话，一定会有被淘汰的危险，所以我尝试去接触别的技术，比如终端、后台，后来发现自己想了解的东西太多，导致没有一个具体的东西，我的leader每次和我交谈的时候我都会说我要作为一个架构师和有影响力（至少在团队内），但是在落实的时候发现离我的目标越来越远。后来我看到一句话大概意思是：如果想扩大影响力，先从自己所擅长的领域开始。所以我就开始想，我做前端除了需求以外，还能为业务做点什么呢？后来我发现我们一些通用的分享页和中转页的需求特别多，固定的样式固定的讨论，只是图片不一样。所以我用了大约两天的时间用nodejs和前端做了一个通用的管理端，每次产品只需要配置管理端就可以生成对应的页面，开发完全解脱了。所以尤其开发人员注意，你要从一个执行者变成一个推动者。这样你的工作才不会枯燥。因为这件事情我得到了leader和总监的肯定，越来越多的事情也可以放心的由我单独去做，做一个主动和善于思考的人，这对于你的成长很有帮助。</p>\n\n<p>我在总结一下工作1-3年的同学，深扎你的技术深度，提高你的认知宽度，技术深度大家都懂，说白了就是你的专业性。但是认知宽度我说一下，这个会决定你以后工作的发展空间，说的很简单，你在一个初创小公司的后台服务架构，基本就是单体服务，你完全不知道什么微服务，云服务等等的架构。而且单体服务基本需要人肉运维，你改错一行代码，可能就会牵一发动全身，每天你就处理粗糙再乱的业务代码，你那里还有时间去了解其他东西。你工作几年后你的认知维度就在这里，完全跳不出去。如果你在大厂，你的认知完全不一样了，这里有标准的工作流程，详细的架构分成和职级分层。所以这就是很多人追求大厂的原因，尤其是刚刚毕业前几年，你的认识边界，基本就决定你以后处理事情的思路和眼光。</p>\n\n<p>所以在工作这个过程中，如果你去面试，面试官会一是看你的技术基础是否扎实，还有就是你是否有深入研究过一些技术，比如前端的react，除了问你怎么使用，怎么设计一些场景外，还会问你react的底层原理的东西，比如虚拟树，react fiber等等。同时，还会问你的工作过程中用的技术栈，及一些工程化的东西，因为这样可以看到你前一份工作的环境从而判断你的眼界和认知。</p>\n\n<p><br /><br /></p>\n\n<p>待续...（最近一直在忙需求没有时间完善帖子，很抱歉，今天先到这）</p>',6,4,0,1,0,0,1,'2020-05-03 22:18:04','2020-05-13 19:16:36'),(18,'美团华为两年工作经验','首先介绍下自己工作经验，17届毕业生，在北京美团工作了1年半不到，然后主动离职回到了二线华为，马上满1年，不出意外，明年辞职。两段经历，分两段讲，公司模式不同体验也不同。 美团 在美团的部门是一个新业务，我...','two-years-working-experience-in-huawei','<blockquote><p><span>首先介绍下自己工作经验，17届毕业生，在北京美团工作了1年半不到，然后主动离职回到了二线华为，马上满1年，不出意外，明年辞职。</span></p><p><span>两段经历，分两段讲，公司模式不同体验也不同。</span></p></blockquote>\n\n<p><br /></p>\n\n<p><b>美团</b></p>\n\n<p>在美团的部门是一个新业务，我算组内比较新进的员工，美团这边工作体验和华为对比起来还是不错的，基础组件完善，用过的都知道。技术氛围好，有很多培训，技术沙龙。而且同事十分友善，这点对工作体验至关重要。虽然也会有甩锅的，或欺负新员工的，但是相对来说，体验算是不错的了。我运气也很好，在美团带我的导师是一个很nice的大兄弟，记得交付第一个大需求时，一起帮我攻关定位了很多问题。你为人人，人人为你，同事是乐于助人还是甩锅会很影响你的工作体验。<br /></p>\n\n<p><span>说了这么多好的，那我为什么呆了1年多就离开呢，主要有两方面原因，一个是自己个人原因，家里在二线买房了，自己想尽点责任，离家近点，有问题自己可以帮帮忙。二就是部门业务，部门做的是集团新业务，人员飞速扩张，业务从0到1，但是我自己做的这块业务，没有专门的pm负责，都是a做了一阵跑了b做，b做了一阵跑了c做。做到最后，我成了最懂业务的人，也成了这块业务的客服。每天从早到晚回大象，周六日出门都心惊胆颤。这种体验真的很不好，心理压力也大，和女朋友也因为工作问题吵过架。最后决定放弃这种客服式生活模式，回二线看看。</span></p>\n\n<p><span><b><br /></b></span></p>\n\n<p><b> 华为</b></p>\n\n<p><span>之前在美团平均是10105的节奏，一个月可能会有那么1/2次到1.2点。本来回到二线城市会稍微好点。结果更甚，华为是心声某网红部门，出了名的钱少事多，基本9116。过点的时候周末两天加班是正常水平。但是在华为这一年加班真正写的代码可能还没有美团半年多，每天都在打电话，开会，整改。这样子的生活让我彻底丧失了对代码的兴趣，以前在美团休息的时候还会充充电，看看一些技术公共号，一些技术书。现在在华为，休息只会休息，一方面身累，另一方面心累。自己这半年也想开了，程序员的发展曲线到30多如果上不去，可能就垮了，打算转行考个公务员或者做点其他的，一方面可以养养生，身体明显大不如前，体重增加30斤，所幸头发还在。另一方面，可持续发展强，如果能发展点副业就更好了。</span></p>\n\n<p><span>最后，工作了两年，有以下建议给萌新</span></p>\n\n<p><span>1.最重要的一条，身体比什么都重要！！！</span></p>\n\n<p><span>2.不光要去大厂，什么部门一定要打听清楚，新业务一定要看看方向，判断下自己是否认同，是否有前途。</span></p>\n\n<p><span>3.送给华为的萌新们，不要被主管工资是零花钱的大饼画住，只有15j才有评议奖金，才有可能很多，终端可能是例外，我不了解不评价。华为这地方，你一定要扎住根，呆个78上10年，才能挣到钱，如果你想挣快钱，请去互联网。</span></p>\n\n<p><span>4.要从长远发展考虑自己的职业生涯，特别是跳槽时，我第一次跳槽可以说是很失败，除了达成回家的目标，其他全部落空。</span></p>\n\n<p><span>5.相信自己，永远不要放弃，一切都会解决的，没有什么过不去的。初入职场，可能受到很多打击，但一定不要否定自己。没什么是和同学喝一场大酒解决不了的。</span></p>\n\n<p><span><b>华为和美团怎么选？</b></span><br /></p>\n\n<p>谈下个人的理解，我是觉得这个需要从每个人的职业生涯规划来看的。<br /></p>\n\n<p><span>美团属于典型的互联网公司，管理扁平，技术栈新，人员流动高。大部分同事都会是其他互联网大厂过来的。能在里面呆5/6年，应该就是资深老员工了。所以如果你想尽快提升自己技术，或者说干个2/3年就一跳的话，我觉得美团是更合适。而且从美团跳其他互联网公司，我觉得适应起来也不会太难，工作模式基本都是类似的。</span></p>\n\n<p><span>而华为是做通信起家的，而且成立较早，公司里原本c/c++ 是主力，最近几年java才逐步扛起大梁，你部门里很多pl，pd，专家，可能压根没写过java代码。华为公司太大，不同部门可能不一样，我这里只介绍下网络产品线的情况，网络产品线，大部分是卖产品解决方案，盒子的。就是我们要做出一套系统，从源码层面交付给客户。我们的代码需要在客户环境上持续运行，而不是互联网公司可以快速迭代，解决问题的。所以代码质量的要求很高，每一次产品出口，都会要过点。过点的意思就是产品的质量要达到一个标准。在这种环境下，公司对你的要求也就和互联网公司不一样了。一切基本以交付为导向，我们需要解决一切交付中遇到的问题。里面会有很多流程性的问题，很多磨人的问题，很多你会觉得没有意义的问题，但是只要是交付需要，我们就要去做。</span></p>\n\n<p><span>来华为还有一项技能要磨练的，叫端到端拉通对齐，如果你很擅长这个，那就别想了，来华为吧，这里会有你的一片天地。简单解释下什么叫端到端拉通对齐，假如有个问题涉及A部门，B部门，C部门。而你又是这个问题的owner，你就要把这三个部门的人都喊上，拉个会议，一起解决这个问题。当然这么描述的话听起来很简单，不就拉三个人吗？但你实际处理起来，就会发现，你拉了a部门的a1，他会让你找接口人a2，你拉了b部门的b1，b2让你先把问题发个邮件,你拉了c部门的c1,没拉上，过了半小时，拉上手机了，告诉你这个问题要找d部门的d1看，然后d1下班了。等到晚上，你忙了一天，问题还挂在你头上，你可以准备好接项目经理的深夜来电了。这就是一次失败的端到端拉通对齐。</span></p>\n\n<p><span>这里也介绍下自己端到端拉通的一点经验，就是平常多接电话，乐于助人。你端到端要拉通的人，他们一般也会经常要拉你，如果你们关系稍微好点，有很多问题，可能本来不是他负责，你也愿意帮你看。久而久之，你端到端拉通的效率会越来越高。如上所说，华为是一家通信起家的科技公司。在这里，如果你愿意长久的发展，积淀自己的人脉与经验，完成一次又一次成功的高质量交付，你会得到你物质上想要的满足的。但如果你想短期起飞，恐怕需要比较难。</span></p>\n\n<p><span>最后，每个公司都是要做ppt/wiki的，要汇报的，这是逃不掉的?大家习惯就好。做得一手好ppt是一个十分重要的技能，讲得一手好ppt是一个更加重要的技能。我们掌握的每个技能都有机会在工作中用到的，word，excel也是，大家要相信技多不压身。多读书多看报，少吃零食多睡觉。当然我们工作是为了更好的生活，如果有份工作让你想要放弃生活，请毫不犹豫的放弃他。</span></p>',9,4,0,1,0,0,1,'2020-05-03 23:41:14','2020-05-13 19:21:19'),(19,'写给20届毕业生的求职指南','  写给20届毕业生的求职指南 0.写在前面 记得去年的这个时候，我还在为求职感到迷茫。这份迷茫，一部分原因是对自己能力和定位认知的不足，还有一部分原因是对即将到来的春招和秋招所知甚少。为此，也咨询了一些师兄...','job-guide-for-the-20th-graduate','<p> </p>\n\n<p><span><b>写给20届毕业生的求职指南</b></span></p>\n\n<h2><span>0.写在前面</span></h2>\n\n<p><span>记得去年的这个时候，我还在为求职感到迷茫。这份迷茫，一部分原因是对自己能力和定位认知的不足，还有一部分原因是对即将到来的春招和秋招所知甚少。为此，也咨询了一些师兄师姐，提前获取了一些资讯。如今，经过2018年春招、实习和秋招的洗礼，再回头看，一些信息和注意点已经变得显而易见。但我相信20届毕业生，和去年的我一样，对于即将到来的求职季充满了迷茫。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>因此，我写这篇文章，主要是梳理一下整个求职季的环节、时间节点和注意事项等。希望能帮助20届毕业生提前窥视求职季全貌，从而在整个求职时间线上把控求职进度。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h2><span><b>1. 春招</b></span></h2>\n\n<p><span>其实春招的面向人群是19届毕业生和20届毕业生。对于前者是招募正式员工，对于后者则是招募具备转正资格的暑期实习生。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>1.1 时间节点</span></h3>\n\n<p><span>其实现在互联网行业的招聘越来越提前，比如vivo一月份就开启了春招、六月份就开启了秋招。但普遍来说，大规模的春招集中在三四月份，并一直持续到六月份。从时间上来说，建议2月底左右就要开始关注春招信息和准备投递简历了。如果前期结果不理想，也不要放弃，春招会持续到六月份，机会依然很多。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>1.2 信息渠道</span></h3>\n\n<p><span>关于综合性渠道：前几年听师兄师姐介绍求职经验的时候，说的比较多的求职渠道还是应届生网和大街网这种求职网站，不过我身边用这些的好像很少。大家用的比较多的还是一些求职类公众号，毕竟每天用微信，公众号接收信息还是比较方便的。这里推荐一个公号【校招薪水】，是我一个学长运营的，推荐关注。对了，求职季有一些公众号会推出一些转发拉群的活动，建议别浪费时间转发了，没啥用。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>关于单一渠道：就是各个公司的官网和招聘公众号了，比如【腾讯招聘】、【拼多多招聘】公众号之类的。这些渠道的优点是信息推送非常及时，能让你第一时间知晓各公司开启招聘渠道的时间节点。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>关于抱团：就是求职者们聚在一起共享信息，互帮互助，建议大家都找到自己的小团体哦。无团可抱的非科班程序猿本猿只得自己拉群了</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>1.3 关于内推</span></h3>\n\n<p><span>先说一下内推的流程吧，***找到目标公司的内推人-一般是公司正式员工或实习生，内推人将***的简历提交到公司简历池当中，各个部门各个组长会去简历池中筛选简历，相中某个简历后，组长将该简历锁定，然后发起面试；面试通过进入offer流程，不通过则解锁简历，可以继续被捞起面试。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>大部分公司都有内推渠道，但各个公司对待内推简历的态度不同。比如阿里，基本上就是上述流程，内推可以免去笔试，直达面试（当然首先要有人相中你的简历）。再比如字节跳动，内推也只是面去简历筛选而已，依然要参加笔试。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>内推最大的好处就是获得了一枚复活币，增加了一次投递机会。也就是说，内推失败依然可以参加正式批招聘。不过有些公司如阿里腾讯，对于每一次面试都会有记录，一次失败记录可能会影响正式批面试官的评价，所以，一定要谨慎对待内推，做好充分准备再去面试。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>关于内推人，尽可能选择比较熟的师兄师姐，避免选择网上公开发布的内推信息。后者一般是内部员工为了内推奖励而发布的信息，内推量巨大，很可能就遗漏了个别人的内推，而你又无法联系上他们，会白白浪费很多时间（我的血泪教训）。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>1.4 关于暑期实习offer选择</span></h3>\n\n<p><span>最好的当然是能去自己目标城市的目标公司，然后最好的结果是顺利转正留下！但是！相信很多人和我一样...并没有想好目标城市或者目标公司。那这个时候，个人建议选择越大的公司越好（其他因素相差不是很大的情况下）。毕竟暑期实习的最终目标是正式工作，即使不能留任，一份大公司的实习是非常为简历增色的，能够有效帮助到自己的秋招。</span></p>\n\n<h2><span><br /></span><br /></h2>\n\n<h2><span>2. 实习和秋招</span></h2>\n\n<h3><span>2.1 暑期实习</span></h3>\n\n<p><span>这里每个人去的公司和状态都不同，我只想说一点，就是实习秋招要兼顾。平时完成实习任务的额外时间，也要给自己留条后路，同时为秋招做准备。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>针对暑期实习，企业的目的是为了考察***，而我们的目的则是通过暑期实习留用或者为自己的简历增色从而找到更好的工作。无论你的目的是前者还是后者，都建议在尽量争取转正的同时，进行秋招的“广撒网”。注意，我这里的情况只是针对广大人民群众，不包括很牛的人（这些人也不需要看我这篇拙文.....）。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>如果你的目的是实习留用，并且成功地留了下来，我的看法是，依然继续参加秋招。原因有如下几点：</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>放弃秋招意味着放弃了更多机会。可能你觉得当前这个offer已经很满意了，但其实可能还有更好的机会可供选择。多试试，不要给自己留遗憾。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>准备秋招也是巩固基础，快速进步的一段时间。毕竟，有目标，有动力，又有面试官帮助你复习和答疑，这种机会真的不多。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>和不同公司不同职级的面试官交流，能够让你更加了解自己所在的行业以及自己所从事的方向在行业中的应用场景。虽然小编是做技术的，但我一直认为对整个行业的动向还是要有了解的。往大了说，这其实就是一个人的行业格局问题。在自己面临选择时，这种格局能够帮助自己做出更加正确的选择。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>如果你的目的是找到更好的工作，那就更不用说了，多去试吧！</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>2.2 时间节点</span></h3>\n\n<p><span>都说“金9银10”，好像现在已经过时了。秋招最早在六月份就已经开始了！（是的，又是那个vivo） 七月中旬到八月底，会有一大批提前批招聘开启。注意，提前批很重要！很重要！之前和同学讨论，有许多人后悔提前批没有多投一些，导致正式批的时候hc（head count，坑位）大大减少，许多hc都被提前批的同学给占了。所以，建议一定要重视提前批，争取在提前批能够拿下一些重量级offer，这样秋招会轻松很多。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>2.3 信息渠道和内推</span></h3>\n\n<p><span>见1.2和1.3</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>2.4 薪资谈判</span></h3>\n\n<p><span>写到这里，悲催的发现我好像从来没有谈判过薪资。突然有点后悔(〒︿〒)。 不过没吃过猪肉，还是见过很多猪跑的。所谓薪资谈判，就是比如你有阿里和腾讯的offer，可以拿着阿里的offer去和腾讯说我要加薪（当然过程可能没这么简单粗暴）。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>建议谈薪适度即可。见过一个骚操作，有人拿阿里offer和腾讯谈薪，然后又拿腾讯谈完的薪资去和阿里谈薪.（类似于左脚踩右脚，右脚踩左脚然后想上天？）.....不知道那位仁兄怎样了。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>还见过一个公司，就不提名字了，为了挽留***-我们群里的一位同学，慢慢一步步加薪，最后相比原offer加了6k（月薪）。虽然最后薪资非常可观，但我们都认为这家公司去不得。后面进行大幅度加薪，说明原本给的薪资是压价非常严重的，而且是一步步慢慢加薪，说明这家公司格局太小，去不得。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<h3><span>2.5 offer选择</span></h3>\n\n<p><span>正式offer选择不同于实习offer选择，要考虑的因素太多。可以参考我之前的offer选择文章。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>最后，祝20届的学弟学妹们，在19年校招中收获满意的offer！</span></p>',10,4,0,1,0,0,1,'2020-05-04 07:43:48','2020-05-13 19:22:14'),(20,'后端好书阅读与推荐','  给各位找工作的同学推荐一些书籍，不论是短期的面试还是长期的职业发展，相信都有一定的好处，欢迎交流         https://segmentfault.com/a/1190000022550912         后端好书阅读与推荐系列文章：     后端好书...','back-end-good-book-reading-and-recommendation','<p> </p>\n\n<p><b>给各位找工作的同学推荐一些书籍，不论是短期的面试还是长期的职业发展，相信都有一定的好处，欢迎交流</b>   </p>\n\n<p>     <b><a href=\"https://segmentfault.com/a/1190000022550912\">https://segmentfault.com/a/1190000022550912</a><br /></b>   </p>\n\n<p>     后端好书阅读与推荐系列文章：   </p>\n\n<p> <a href=\"http://mageek.cn/archives/33/\">后端好书阅读与推荐</a></p>\n\n<p> <a href=\"http://mageek.cn/archives/34/\">后端好书阅读与推荐（续）</a></p>\n\n<p> <a href=\"http://mageek.cn/archives/42/\">后端好书阅读与推荐（续二）</a></p>\n\n<p> <a href=\"http://mageek.cn/archives/43/\">后端好书阅读与推荐（续三）</a></p>\n\n<p> <a href=\"http://mageek.cn/archives/44/\">后端好书阅读与推荐（续四）</a></p>\n\n<p> <a href=\"http://mageek.cn/archives/47/\">后端好书阅读与推荐（续五）</a></p>\n\n<p> <a href=\"http://mageek.cn/archives/95/\">后端好书阅读与推荐（续六）</a></p>\n\n<p> <a href=\"http://mageek.cn/archives/106/\">后端好书阅读与推荐（续七）</a></p>\n\n<p> <a href=\"https://segmentfault.com/a/1190000022550912\">后端好书阅读与推荐（续八）</a>   </p>\n\n<h2>   阿里巴巴Java开发手册  </h2>\n\n<p>   阿里巴巴Java开发手册 (豆瓣): <a href=\"https://book.douban.com/subject/27605355/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   阿里在Java技术方面具有广阔而深入的研究和应用，而本书正是阿里技术团队的集体智慧结晶和经验总结，非常值得借鉴和学习。  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。的确是这样，这一行不存在“一招鲜吃遍天”的说法，每个人都要进行广泛而深入的终身学习      </li><li>    现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同。适当的规范绝对不是扼杀创新性，而是管理软件复杂度的一种手段      </li><li>    为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。不要嫌长，毕竟这是Java的一大特色(*￣︶￣)      </li><li>    任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。这一句说的很贴切      </li><li>    在高并发场景中，避免使用” 等于” 判断作为中断或退出的条件。如果并发控制没有处理好，容易产生等值判断被“击穿” 的情况（亦即瞬时状态跳变），使用大于或小于的区间判断条件来代替可以保证一定能终止      </li><li>    捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。      </li><li>    好的单元测试必须遵守 AIR 原则：Automatic（自动的，不要人工的print而是自动的Assert）、Independent（独立的，不依赖于其他单元测试、也不依赖于其他模块，必要时可以Mock）、Repeatable（可重复执行，支持持续集成）      </li><li>    对用户相关的数据要做校验（防止攻击）、鉴权（防止越权操作）、脱敏（防止信息泄露）、转义展示（避免代码逻辑泄露，或者让用户懵逼），还要做防刷（避免资损或骚扰用户）、违禁词过滤等风控策略      </li><li>    MySQL中 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果长度大于此值，定义字段类型为 text，独立一张表，用主键对应，避免影响其它字段索引效率（因为MySQL是按行存储的）      </li><li>    分层设计中，Dao层异常不要打印，而是直接抛出，因为Service层一定会借助日志并记录；web层绝不应抛出异常，因为已处于顶层，应自己记录，并选择合适页面渲染给用户；对于领域对象，DO与数据表一致,DTO是service向外传输对象,BO是Service层封装的业务逻辑对象,AO是Web与Service之间的复用对象模型,VO是显示层对象,Querry是上层给下层的查询对象     </li></ul>\n\n<p>   书比较薄，涉及面也较广，可以把本书当做一个目录，我们自己按需去发散，针对每个方面进行更深入的学习。<br /> 此外本书还有<a href=\"https://book.douban.com/subject/30333948/\">进阶版</a>，可以看做是对本书的一个扩充。  </p>\n\n<h2>   Clean Architecture  </h2>\n\n<p>   Clean Architecture (豆瓣): <a href=\"https://book.douban.com/subject/26915970/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   本书是<a href=\"https://segmentfault.com/a/1190000011076865#articleHeader6\">代码整洁之道</a>作者 Robert C·Martin 的Clean系列的最新大作，译为架构整洁之道，是作者多年软件架构经验的合集，值得细细品味。  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    软件架构的终极目标是用最小的人力成本来构建满足和维护该系统的需求。如果你觉得好的架构太费钱，大可看看先用随意的架构然后再慢慢改的成本，事实上国内好多公司也是这样做的，都是快速扩张追求速度，后面再慢慢还技术债。从软件开发的角度看，一开始偷懒妄想后期重构是不大可能的（因为市场的压力永远不会消退，你永远都在完成新功能，重构旧代码的机会不会再有了，系统越来越乱），所以精心设计的架构的确对后来的工作有好处，但是我觉得对于需要快速抢占市场的应用，先跑起来才是王道，这是已经超出了软件开发的范畴的理念。      </li><li>    软件的价值来自于两个维度：行为（业务逻辑，是直接产生利润的价值，也是大多数人唯一关注的价值）和架构（软件的灵活性，具体下来可以理解为可扩展性、复杂性管理等，这部分价值常被人忽略，但确是软件可以持续低成本地产生行为价值的基础，也是软件之所以“软的原因”）。如果用<a href=\"https://www.jianshu.com/p/fdb4e4fd2394\">艾森豪威尔矩阵</a>来衡量，行为价值是紧急的，但并不总是特别重要，架构价值是重要的，但并不总是特别紧急。我们需要很好的平衡这两个价值      </li><li>    结构化编程限制了goto语句，赋予了我们创造可证伪程序单元的能力，相应的，在架构领域，功能性降解拆分是最佳实践之一；C支持完美的封装，部分支持继承（结构体超集），支持多态（函数指针模拟，getchar、putchar等函数），所以这三大特性并不能代表OOP，OOP的真正精髓在于对于程序间接控制权的转移，亦即安全的多态（比如Java将函数指针封装到jvm中，程序员不可直接用指针了），这种多态能方便地实现依赖反转（implemention源码依赖于interface，控制流和源码依赖相反），让底层组件插件化，独立于高层组件进行开发和部署（边界划分的艺术）；函数式编程中变量（叫参数更好）不可变，借鉴到架构中就是隔离不可变与可变的部分（我们目前做不到完全不可变性，要么速度太慢，要么空间太小，如果有足够的空间和速度，就可以实现只需CR而不是CRUD的程序）      </li><li>    软件构建的底层目标（也就是具体的代码逻辑，类比砖头）应遵循“整洁之道”；中层目标（也就是组件，类比房间）是软件可容忍改动、更易理解、组件可复用，应遵循<a href=\"https://en.wikipedia.org/wiki/SOLID\">SOLID</a>原则（是设计类和模块适用的原则，在架构领域也适用）；高层目标（也就是软件系统。类比建筑）要遵循复用和发布等同（为复用而组合）、共同闭包（为维护性而组合）、共同复用（为避免不必要的发布而切分）三个原则，这三个原则互相牵制，架构师要在这三者中找到平衡；组件之间要避免循环依赖，打破循环依赖的方式有DIP、创建新组件两种方式，依赖要指向更稳定的方向      </li><li>    软件架构师首先是程序员，也许不是代码量最多的，但是应该亲自承接编程任务，不然体会不到不良设计带来的麻烦，逐渐就会迷失正确的设计方向；软件架构的最高优先级是系统正常工作，同时也要保留尽可能多的选项（这是让系统好理解、可扩展、易修改，为其将来正常工作打下基础），架构是要考虑软件系统的全周期，而非仅是当前；软件架构的目标是让系统的策略和细节分离，以允许具体决策过程中推迟与细节相关的内容，留下更多的选项      </li><li>    我们常说“Don\'t repeat yourself”，很有可能就陷入了见到重复就消灭的应激模式中，事实上，要区分真重复和假重复，如果两段代码走的是不同的演进路径，那么即使他们现在看起来比较像也要即时分开，不然后期的改动就会难以下手     </li></ul>\n\n<p>   我发现老外写书大致有两种风格，一种是大部头，经书似的。这种书看着人头疼，但是往往能把一个领域说的非常清楚和考究，属于科研派的，比如<a href=\"https://segmentfault.com/a/1190000016779589#articleHeader3\">TCP/IP详解 卷1：协议</a>这种；另一种是散文似的，每一部分都短小精悍，看着也不累，比如<a href=\"https://segmentfault.com/a/1190000010491157#articleHeader6\">Head First 设计模式</a>。这本书显然是后者，感觉学了不少，也不觉得累，究其原因我想是因为本书通篇就反复讲了一个概念：隔离变化（重要的事情说三遍？），所以看完还是感觉稍微有点水。  </p>\n\n<h2>   可伸缩架构  </h2>\n\n<p>   可伸缩架构：面向增长应用的高可用 (豆瓣): <a href=\"https://book.douban.com/subject/27071892/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   高可用是我们做系统的人不变的追求，本书就是该领域的一部佳作，从可用性谈起，介绍了监控并提高可用性的方法，然后重点讲了风险管理和伸缩性，最后讲了最近几年流行的微服务和逐渐成为主流趋势的上云。看完之后就能对高可用这个概念有一个全面系统的了解。  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    程序员一开始接触的是一个确定性的世界，什么样的输入就有什么样的输出，但是在面对分布式系统时首先要承认的就是不确定性，不能再把系统看做单体应用那样稳定，要充分考虑不确定状态（机器本身、代码质量、网络等因素所致），并把整个系统的不确定性因素梳理出来，作为风险进行管理，制定相应的措施，并持续地进行测试和评估，避免问题发生时手足无措      </li><li>    提高可用性的5个要点：时刻考虑应对故障（everything can fail at anytime，所以要为故障做出计划）；时刻考虑应对伸缩（具备快速扩展数据库、应用等的能力）；缓和风险（风险不能完全消除，但是应该做出缓和风险亦即降低问题带来的影响的努力）；监控可用性（眼睛，问题定位）；以可预期及明确的方式来处理可用性问题（对监控出的问题进行标准化流程处理，降低不可用时间）      </li><li>    计划和日常维护导致的不可用时间也应计算在可用性百分比之中，因为用户只在乎可用与否，而不管你是意外故障还是计划维修      </li><li>    可用性下降时有几点可以做：首先要跟踪并测量可用性（包括关键事件如变更和可用性之间的关系）；手动流程自动化（人肉操作不靠谱，自动化操作则有预期、可审查、可重复、易版本控制和回滚）；关注一致性、可重复性、标准的配置管理流程      </li><li>    风险管理就是在消除风险的成本与风险发生的成本之间保持平衡，其第一步就是列出所有已知风险，包括可能性和危害性并依此分级（最严重的风险自然就是可能性大、危害性大的），制定风险缓和措施（降低可能性和危害性，危险性更要首先关注）来控制风险并定期检查和持续维护（比赛日，也就是容灾演练）。当风险仍然不可避免的发生后采用恢复计划（风险发生后采取的行动，也属于风险缓和措施，如容灾计划）降低问题的危害性      </li><li>    如何从根本上缓和风险呢？那就是从一开始就考虑构建低风险系统，要素有：冗余（合适的冗余可以降低整体故障概率，但是过度冗余带来了复杂性，反而增加了风险）、幂等接口（通过简单重试避免失败）、独立性（看似冗余的服务如果运行中同一个物理机或者机架上那就不独立了）、简单（微服务降低了单体复杂性，但是服务数量增多也带来了构建大规模系统的整体复杂性，所以构建微服务要在单个服务和整体应用之间的复杂性做权衡，这个权衡取决于你的系统、组织和公司文化）、自修复（人工修复会显著降低可用性，比如半夜你还得先起床，所以要自修复，比如负载均衡自动剔除坏server、热备数据库自动上线等）、自动化流程（人总是会犯错）      </li><li>    微服务主要解决的是单体程序臃肿难理解、无法多组人员并行开发、难以测试、发布缓慢等问题，且可以给更重要的业务单独增加更多资源，当然这个进步的前提是服务之间边界明确且独立（代码库、数据、API、Owner的权利和责任），否则既不能解决这些问题，反而由于组件数量增多而增加了系统的复杂性。服务边界划分的原则有：业务需求、团队所有权、天然隔离的数据、对外服务的能力      </li><li>    AWS的可用区针对不同用户来说是不同的，主要是为了负载均衡，避免用户集中选择字母表中靠前字母的可用区，导致负载不均，同一个数据中心对甲是a可能对乙就是b，这个设计还是挺巧妙的     </li></ul>\n\n<p>   文中说可靠性很容易通过测试解决，所以主要讲了可用性，但是分布式数据一致性、持久化等也应属于可靠性，但是很难测试，所以书里的可靠性定义还是狭隘了一点，仅指传统软件测试方面的。而且我觉得广义上的可靠性应该是包含正确性和可用性两方面的，而广义上的可用性又包含能用和性能两方面（比如你的一个简单的服务虽然能用，但是RT是5分钟也可认为该服务是不可用的）。<br /> 另外后面关于云计算方面的内容稍有注水和广告之嫌，毕竟按固定量和使用量的方式分配资源这种话题太过浅显（虽然也属于伸缩性的范畴）。  </p>\n\n<h2>   软件架构师的12项修炼  </h2>\n\n<p>   软件架构师的12项修炼 (豆瓣): <a href=\"https://book.douban.com/subject/10746257/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   架构师的技术能力属于硬技能，关系技能、个人技能和商务技能等属于软技能。在商业化的社会，硬技能的确非常重要，是我们生存的基础，但是软技能也同样重要，是我们扩大影响力和业务面的基础，能帮我们超脱技术本身，为公司创造利润，为社会创造价值。这本书就着重帮我们培养这些软技能，并且基本按照原则、策略等要点来组织，非常有条理。  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    对于更高职位的人而言，深谙技术细节固然有用，但能力已经开始向与别人成功交互方向倾斜，为了将事情办成而倾销其观点，一个项目要成功，支付账单的人要获得最大回报其实并不一定需要完美的技术解决方案，所以遇上争执首先问自己：纠正重要吗？不纠正公司会付出很大成本吗？很大可能答案是不，此时最好就是保持平静而非面红耳赤，记住人不是软件（有问题就一定要立马解决），人有情绪，所以要时刻保持文雅      </li><li>    就像好的web服务一样，你应采用“无状态”的方式——只对当前输入做出响应（而不是很久之前别人对你冒犯），毕竟你的脑子是能处理几件事，不要将你的精力浪费在过时、无用的信息上，记住你学会的知识，放下不快的事情，你会成为一个真正进步、快乐的人      </li><li>    架构师通常不能直接管理别人，这样指示别人完成特定行动的能力就受到限制了，所以真正有效的手段就是你的影响力，一方面体现在你的专业知识上，另一方面就是沟通技能      </li><li>    出于本能，当别人说出对我们不是正面意义的话的时候我们往往会找借口、转移话题或者责怪别人，但事实上别人不一定出于恶意，先想想自己能从别人的话中得到改进吗？如果是，则是你成长的机会，所以要避免这种本能      </li><li>    我们常常会说“我早就告诉你会这样”，是下意识的想展示自己的优越感或者甩锅，但是这样对团队合作与项目进度毫无用处，所以要想成为一名好的team worker，我们要扔掉许多下意识的东西，并且尝试去了解肢体语言和心理学可以帮你更好的进行协商      </li><li>    管理是将事情做对，而领导力是做对的事。应该通过影响而不是要求别人来做一件事才是真正的领导力。领导力建立于信任之上，是为了建立一种共识，取决于建立战略伙伴关系和身体力行的能力。      </li><li>    透明化能为自己和他人带来清晰性，让公司充分评估风险。包括三大类：自我透明，向别人充分展示自己，不隐藏，让别人可信赖并对你有合理的期待；项目透明，展示项目的优缺点、风险、成本和假设条件，让别人也可以充分参与决策；关系透明，给别人信任，倾听，让别人对你也透明      </li><li>    激情是推动你事业进步的内在动力      </li><li>    商务就是为了赚钱，了解一些商务知识可以大大促进你了解伙伴（市场、销售）、领导和客户的能力，能帮你做出真正有商业价值的产品。      </li><li>    创新不会凭空而来，需要多阅读（书记、博客等），这样你才有知识储备，在你面临一个挑战性问题时，你才有原材料进行创新；平时有了点子都可以记录下来（好记性的确不如烂笔头，而且如今大家都很忙，很多想法不记录就溜走了），这就是将来灵感的种子     </li></ul>\n\n<p>   这本书还有个好处就是全书都在培养我们问自己问题的习惯，遇上一件事时先全方位多角度地问自己若干问题，然后再下手，这样才不会片面，不会走入“<a href=\"http://mindhacks.cn/2009/01/16/hammers-and-nails/\">锤子与钉子</a>”的桎梏，才能有更宽阔的眼界，走向创新的大门。<br /> 另外说一点和书没关系的话，我们工作中自己是锤子，不能看见啥都是钉子，这样容易走入死胡同。但是我们自己是锤子，看见啥都要想一想是不是钉子，这样才有可能发挥自己工作的最大价值。<br /> 最后，我觉得本书不只是架构师需要，而是各行各业的各类人都需要。  </p>\n\n<h2>   和秋叶一起学PPT  </h2>\n\n<p>   和秋叶一起学PPT (豆瓣): <a href=\"https://book.douban.com/subject/27613458/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   如果说代码能力、架构能力等技能属于我们的硬实力，那么表达能力、沟通能力就是我们的软实力，只有软硬兼修才能立于不败之地。在如今的学习和工作中，少不了汇报、组会等，制作一个好的PPT能帮我们更好地表达、展现和沟通。通过本书可以学到PPT的制作技术，而且书本身就可以看做一个素材库，针对不同行业、场合，帮助你选择不同的风格和素材，适合长留案边，以备不时之需。  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    感觉写书和写PPT有共性，作者一开始就把自己的书和其他书作对比，强调突出了自己的优势（比如同名微博+微信+书籍，打造学习闭环），一下子就把我震住了，可见PPT做得好不仅能会说，还能会写书，好处多多      </li><li>    从结果导向来说，还是要关注业务。office2003出来后，一众发烧友做了一大堆复杂动画模拟翻书切换效果，结果office2010直接一键实现，所以对于好多工具（比如开发语言、中间件）没必要耗费时间完全搞清楚它所有花里胡哨看起来高大上的特性，而是要关注业务的实现，在必要的时候再去了解特性（因为所谓特性其实很容易过时）      </li><li>    serif（有衬线字体），在字的笔画开始、结束的地方有额外的装饰，且笔画的粗细有所不同；反之，sans serif 没有额外的装饰，且笔画的粗细差不多。投影状态下受设备影响，大字部分适合serif（透气、美观） ，小字部分适合sans serif（简洁、识别度高、有冲击力）；此外，不同字体的使用要注意法律风险      </li><li>    打造一个高大上的PPT其实也是有章可循的，一般四步走起：统一字体、突出标题、巧取颜色（通过沿用logo或企业VI用色对PPT进行简单配色）和快速搜图（用关键词搜图法对PPT进行配图）      </li><li>    ......     </li></ul>\n\n<p>   这本书连真小白都可以看，所以老手们要跳着看啊，不然浪费很多时间（比如教你怎么下百度云，￣□￣｜｜）。  </p>\n\n<h2>   Kubernetes in Action  </h2>\n\n<p>   Kubernetes in Action中文版 (豆瓣): <a href=\"https://book.douban.com/subject/30418855/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   xx in action 系列的书一直不错，既有原理性的解读，又有实战性的上手指导，阅读价值非常高。而k8s作为云原生的代表技术，非常值得学习。  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    Kubermetes 抽象了数据中心的硬件基础设施，使得对外暴露的只是一个巨大的资源地，可以被当作集群的一个操作系统 看待，它让我们在部署和运行组件时，不用关注底层的服务器，使开发者可以自主部署应用，完全脱离运维团队的帮助，同时能让运维团队监控整个系统，并且在硬件故障时重新调度应用，系统管理员的工作重心，从监管应用转移到了监管 Kubermetes，以及剩余的系统资源，因为 Kubermetes 会帮助监管所有的应用      </li><li>    作者不喜欢先解释事物是如何工作的，然后再解释它的功能并教人们如何使用它 。 就像学习开车，你不想知道引擎盖下是什么，你首先想要学习怎样从 A 点开到 B 点 。只有在你学会了如何做到这一点后，你才会对汽车如何使这成为可能产生兴趣。毕竟，知道引擎盖下面是什么，可能在有一天它抛锚后你被困在路边时，会帮助你让车再次移动      </li><li>    一个 pod 是一组紧密相关的容器，它们总是一起运行在同一个工作节点上，以及同一个 Linux 命名空间中。为什么发明了pod的概念呢？ 首先，容器被设计为每个容器只运行一个进程（除非进程本身产生子进程），如果在单个容器中运行多个不相关的进程，那么保持所有进程运行、管理它们的日志等将会是我们的责任，所以不能将多个进程聚集在一个单独的容器中，我们需要另一种更高级的结构来将容器绑定在一起，并将它们作为一个单元进行管理，这就是 pod 背后的根本原理      </li><li>    注解也是键值对，所以们本质上与标签非常相似，但注解并不是为了保存标识信息而存在的，一般用来保存更多的信息，而标签更像是索引。此外，向Kubemetes引入新特性时，通常也会使用注解，一般来说，新功能的alpha和beta版本不会向API对象引入任何新字段而是用注解，当API更改变得清晰并得到所有相关人员的认可，就会引入新的字段并废弃相关注解。      </li><li>    尽管工作节点上的组件都需要运行在同一个节点上，控制平面的组件可以被简单地分割在多台服务器上。为了保证高可用性，控制平面的每个组件可以有多个实例。etcd和API服务器的多个实例可以同时并行工作，但是调度器和控制器管理器在给定时间内只能有一个实例起作用，其他实例处于待命模式      </li><li>    控制器执行一个“调和”循环，将实际状态调整为期望状态（在资源spec部分定义），然后将新的实际状态写入资源的 status 部分。控制器监听API Server来订阅变更，但使用监听机制并不保证不漏掉事件，所以仍然要定期执行重列举操作来确保不会丢掉什么      </li><li>    ......     </li></ul>\n\n<h2>   Kubernetes网络权威指南  </h2>\n\n<p>   Kubernetes网络权威指南：基础、原理与实践 (豆瓣): <a href=\"https://book.douban.com/subject/34855927/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   本书是要不要推荐我其实犹豫了一下，因为本书有许多代码，有充数之嫌，而且在阐述上有许多不清晰的地方。但是我还是推荐给大家，因为本书勾勒了一个基本上完整的k8s网络大图，值得通盘了解。  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    结合CNM，Libnetwork要达成的效果是，用户可以创建多个网络，也可以创建多个容器，最后选择让容器加入某个网络，从而使容器和网络分离，让开发者专注于自己感兴趣的地方      </li><li>    要支持大规模的容器集群，网络才是最基础的一环，其中的挑战是“以隔离的方式部署容器，在提供隔离自己容器内数据所需功能的同时，保持有效的连接”，隔离和连接是两个矛盾但是又缺一不可的关键词      </li><li>    Overlay是指在传统底层网络上构建一个虚拟网络，底层网络不需做任何适配，虚拟网络在底层网络上进行封包拆包完成通信，L2 overlay是一个大二层的概念，大是指这个网络可以跨越数据中心，二层是指通信双方在一个逻辑网段内，支持容器迁移而不用改变Ip的特性，L3 overlay类似，但是在节点上增加网关（不同节点网段可以不同），节点内通信走L2,节点间走L3；Underlay是指底层网络，传统组网就是underlay类型，L2 underlay就是2层互通的网络，L3 underlay就是L3互通的网络      </li><li>    Docker在容器的普及和迅速推广起到了非常重要的作用，但是它也正在集成网络、编排等功能，势必会被k8s弱化其作用，而拥抱更轻量的容器技术比如containerd、cri-o等      </li><li>    k8s网络策略和一些安全组在某些功能上有重叠，但是区别也较为明显，安全组一般记录在上层网关，网络策略则实施在每个节点上，节点上的agent需要watch pod、namespace、policy等资源      </li><li>    Linux内核在做SNAT时，由于端口分配和将连接插入contrack表存在时延，可能导致端口冲突而丢包（尤其是高并发模式下），所以不推荐在生产环境使用nodePort模式      </li><li>    受制于k8s的基于客户端的负载均衡架构（由每个节点的kube-proxy决定real server），即使用了支持多种负载均衡算法的ipvs也很难支持，比如least-connection算法，每个kube-proxy只能知道自己链接数最小的rs，而不能知道全局最小的rs      </li><li>    <a href=\"https://github.com/coreos/flannel\">Flannel</a> 通过监视etcd获取可用ip范围，在启动容器时指定ip范围，从而使得不同节点成为一个子网，容器ip不重复；通过overlay（用户态udp或内核态的vxlan）或者host-gateway（直接刷节点路由表，由于不能刷路由器所以需要节点2层可达）的方式实现容器间通信。<a href=\"https://www.projectcalico.org/#getstarted\">Calico</a> 也是通过类似的刷节点（虚拟路由器）路由表来实现容器通信，但是由于采用了BGP协议，其模拟的路由表信息可以被传递到其它路由设备中，直接实现了3层网络通信      </li><li>    <a href=\"https://linux.cn/article-9630-1.html\">BPF</a> 可以理解为一个高性能沙箱，使得内核变成可编程，内核有其加持后，linux的安全则不局限于传统的ip+port的包过滤模式，内核可以理解什么是微服务、安全性如何等问题。Cilium就把BPF带入了K8S     </li></ul>\n\n<h2>   大型系统应用架构实战  </h2>\n\n<p>   大型系统应用架构实战：部署、容灾、性能优化 (豆瓣): <a href=\"https://book.douban.com/subject/34782232/\">https://book.douban.com/subje...</a>   </p>\n\n<p>   本书作为阿里全球化的经验沉淀之作，不仅介绍了宏观的架构策略，还探讨了具体的算法实现，非常值得急速扩张的互联网公司借鉴。<br /> 此外，本书展现出来的知识面也告诉我们，要想作一个优秀的架构师，既要了解业务，也要了解技术，这样才能做出最适合业务的技术方案  </p>\n\n<p>   亮点：  </p>\n\n<ul><li>    互联网的本质是提高信息传递的效率，它极大地促进了全球化，而全球化对技术有如下几个要求：性能、可用性、互联互通、数据一致性、隐私保护、本地化对接、可伸缩性      </li><li>    区域化部署技术的本质是多层路由，每一层都要基于用户来调用路由服务，确定该用户所属的机房。而多层路由的最佳方式是接入层RPC调用路由服务后缓存起来（有一定的失效期）并透传给下面的服务层、消息层和数据层。有人可能会问了，都在接入层判断了，为啥后面每一层都要再判断一次？因为有可能路由服务变更了，还有可能一份数据被多个用户共享，所以每一层都要做路由决策      </li><li>    区域化容灾技术，在进行灾备切换时并不需要更新整个机房的用户路由表，也不会因为完全依赖DNS切换而必须等待DNS失效，因为区域化部署已经提前在路由服务中准备好了灾备机房，所以在统一接入层即可完成灾备切换，即使统一接入挂了，也只是会影响部分用户而不会带来危害      </li><li>    ......     </li></ul>\n\n<h2>   后记  </h2>\n\n<p>   有时候会觉得“知道了许多道理，却依然过不好这一生”，看了许多书，却觉得自己依然没有进步。我觉得主要有两点，一是看书要带着思考去看，不要用眼睛过一遍就完事了，要对书中的内容多想想：书里说的对不对？如果是对的我有没有做到？书对我的学习和工作有实际价值吗？等等，多问几个问题书里的内容就能自然而然转化为自己的知识，平常和别人交流就能用上了。二是要及时地把书中的知识运用起来，并有意识的对自己进行相应的训练，比如对于很内向的人，看了《架构师修炼这本书》后就可以好好实践一下透明化这一章节，多展示自己，让别人了解并信任你，这就是你的进步。  </p>\n\n<p>   查看<a href=\"https://segmentfault.com/a/1190000022550912\">原文</a>，来自<a href=\"http://mageek.cn/\">MageekChiu</a>。</p>',9,3,0,1,0,0,1,'2020-05-06 21:34:06','2020-05-13 19:21:17'),(21,'失败的滋味','  今天是5.6号了，昨天看见很多牛友在鼓励，也有同样的遭遇。生活还是得前行，不管怎么样，自己努力总会有收获。今天家里又问了之前的面试怎么样？实在是感到不好意思了。哎！期待offer到来的那一天，也给家里一个满...','the-taste-of-failure','<p> </p>\n\n<p>今天是5.6号了，昨天看见很多牛友在鼓励，也有同样的遭遇。生活还是得前行，不管怎么样，自己努力总会有收获。今天家里又问了之前的面试怎么样？实在是感到不好意思了。哎！期待offer到来的那一天，也给家里一个满意的答复。 </p>\n\n<p>   现在都五月了，这个五一假期应该是我过的最难受的一个假期。没有任何消息。春招的一切都归为了0。到现在，每天逛逛牛客的帖子，20届找不到工作的应该就只剩下我了把。（真的越说越难过?)。出现的帖子都是21届的实习贴，真羡慕21届还有秋招。每天在招聘网上找招聘信息，现在是真的没有什么了，不知道该怎么办，学习也是总达不到自己想要的学习效率了，难不成一毕业就失业了吗？毕业后就不再是20届了，就得走社招通道，可是社招又要求有经验的，不知道该怎么办才好。现在都只想找个小公司能够落脚，积累经验，好社招再战。奈何就是小公司都不招人啊！！！  </p>\n\n<p>   羡慕各位大佬拿到的offer，怎么就这么难啊？☹☹  </p>\n\n<p>   还有20届的没有offer的吗？大概是没有了把。该拿的都应该拿到了。感觉自己书都白读了</p>',10,5,0,1,0,0,1,'2020-05-07 10:19:47','2020-05-13 19:22:12'),(22,'牛友们，双非本科真的能进大厂吗？','说实话，双非本科真的能进大厂吗？靠啥进？确实是好奇，没别的意思   带诗人1# 能不能进大厂不知道，但是气场一定要足 发表于 昨天 16:10:31 来自 Android 客户端回复(1)赞(1)分享 Arven  ： 有道理嗷 昨天 16:11:32...','niuyou-can-double-non-undergraduate-really-enter-the-big-factory','<p>说实话，双非本科真的能进大厂吗？靠啥进？确实是好奇，没别的意思<br /></p>\n\n<p><br /></p>\n\n<p> </p>\n\n<p><br /><br /></p>\n\n<p>带诗人1#</p>\n\n<p>能不能进大厂不知道，但是气场一定要足</p>\n\n<p>发表于 昨天 16:10:31 来自 Android 客户端回复(1)赞(1)分享</p>\n\n<p>Arven  ： 有道理嗷</p>\n\n<p>昨天 16:11:32回复(0)赞(0)</p>\n\n<p><br /><br /></p>\n\n<p>回复tobewind 2#</p>\n\n<p>可以的，据我了解，我学校的本科生好多个去大厂了，薪资也是杠杠的</p>\n\n<p>发表于 昨天 16:21:43 来自 Android 客户端回复(6)赞(1)分享举报</p>\n\n<p>tobewind  ： 能去大厂实习的话，留用的机会还是很大的</p>\n\n<p>昨天 16:23:05回复(0)赞(0)举报</p>\n\n<p>Arven  ： 厉害，是不是有很丰富的项目经历啊</p>\n\n<p>昨天 16:23:13回复(0)赞(0)举报</p>\n\n<p>tobewind  回复 Arven  ： 他们多是实习然后留用</p>\n\n<p>昨天 16:28:06回复(0)赞(0)举报</p>\n\n<p>Arven  回复 tobewind  ： 大厂对实习生的要求也很高吧</p>\n\n<p>昨天 16:30:41回复(0)赞(0)举报</p>\n\n<p>tobewind  回复 Arven  ： 这个只能说及早准备了，自己积极咯</p>\n\n<p>昨天 16:46:11回复(0)赞(0)举报</p>\n\n<p>ohhhh  ： 啥学校啊</p>\n\n<p>昨天 20:11:34回复(0)赞(0)举报</p>\n\n<p><br /></p>\n\n<p><br /></p>\n\n<p>gaza21#</p>\n\n<p>可以的，身边有同学进腾讯，看本事的</p>\n\n<p>发表于 今天 00:05:32 来自 Android 客户端回复(0)赞(1)分享</p>\n\n<p><br /><br /></p>\n\n<p>可爱鹅22#</p>\n\n<p>可以的</p>\n\n<p>发表于 今天 00:09:35 来自 Android 客户端回复(0)赞(0)分享</p>\n\n<p><br /><br /></p>\n\n<p>soap_miko 23#</p>\n\n<p>我双非一本本科，计算机专业，同班同学里技术岗的都有两个腾讯两个字节，剩下还有很多其他厂的。我做非技术岗，去的公司在行业里也算大公司。双非在学历上确实不占优，但真的没到让你进不了互联网大厂的程度。</p>\n\n<p>发表于 今天 10:09:47 来自 Android 客户端回复(0)赞(0)分享</p>\n\n<p><br /><br /></p>\n\n<p>Codle 24#</p>\n\n<p>本科的学生团队（10人左右）每年2-3个Bat，双非二本</p>',6,5,0,1,0,0,1,'2020-05-07 10:21:23','2020-05-13 19:16:19'),(23,'...','是不是在你受伤了以后的第二天，明明受伤的地方还是又红又肿，可是家里的大人尤其是爸爸还是非要听你说一句我没事或者不痛了这样的话才会心满意足的走开。','','<p><span>是不是在你受伤了以后的第二天，明明受伤的地方还是又红又肿，可是家里的大人尤其是爸爸还是非要听你说一句我没事或者不痛了这样的话才会心满意足的走开。</span><br /></p>',7,5,0,0,0,0,1,'2020-05-07 10:22:42','2020-05-07 10:22:42'),(24,'欢迎找HR小姐姐来内推~还有大厂笔面经答案等福利赠送','最近很多同学反馈投了很久没有收到笔试，或者笔试后很久没有面试，最近校招组的同事们确实人手不太够~所以排时间这条战线拉的很长，大家体谅下哦~   【我们是谁】 奇安信集团( 以下简称“奇安信”)是专门为政府、企业...','welcome-to-miss-hr-for-internal-promotion-and-other-welfare-gifts','<blockquote><p><span>最近很多同学反馈投了很久没有收到笔试，或者笔试后很久没有面试，最近校招组的同事们确实人手不太够~所以排时间这条战线拉的很长，大家体谅下哦~</span><br /></p></blockquote>\n\n<p> </p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>【我们是谁】</span></p>\n\n<p><span>奇安信集团( 以下简称“奇安信”)是专门为政府、企业，教育、金融等机构和组织提供企业级网络安全技术、产品和服务的网络安全公司，相关产品和服务已覆盖90%以上的中央政府部门、中央企业和大型银行，已在印度尼西亚、新加坡、加拿大、中国香港等国家和地区开展了安全业务。奇安信是国内网络安全领域中高速成长的企业目前已拥有7000余名员工，2016- 2018年三年的营业收入的年复合增长率超过90%，增长速度创记录。 奇安信以“让网络更安全，让世界更美好”为使命，以“成为全球第一的网络安全公司” 为愿景，不断打造网络安全颠覆性和非对称性核心技术，竞争力不断提高。</span></p>\n\n<p><span>2019年7月, 奇安信正接受上市辅导 启动登陆科创板。</span></p>\n\n<p><span>2019年10月，奇安信以200亿元位列《2019胡润全球独角兽榜》第84位</span></p>\n\n<p><span>2019年12月，奇安信成为北京2022年冬奥会和冬残奥会官方赞助商。</span></p>\n\n<p>2020年1月9日，胡润研究院发布《2019胡润中国500强民营企业》， 奇安信以市值230亿元位列第321位。</p>\n\n<p><span>【福利待遇】</span></p>\n\n<p><span>大公司 好待遇 工作地点全国各地选</span></p>\n\n<p><span>薪资情况可通过offershow，看准网等网站查询：360企业安全，或者奇安信进行了解</span></p>\n\n<p><span>1.我们有大牛导师带队，一般是一对一或一对二</span></p>\n\n<p><span>2.我们是国内最大规模网络安全公司(目前员工数接近8000)</span></p>\n\n<p><span>3.我们通过3年时间打造独立品牌(与360完全分离)</span></p>\n\n<p><span>4.我们走在当前网络安全的风口</span></p>\n\n<p><span>5.全新的技术，全新的产品，全新的理念</span></p>\n\n<p><span>6.只要你有能力，你就有机会拿股票拿期权</span></p>\n\n<p><span>7.我们拒绝996，因为toB根本不需要996！</span></p>\n\n<p><span>8.我们是新一代网络安全领军者</span></p>\n\n<p><span>9.我们期待你的第一份简历，当然还有第二次机会</span></p>\n\n<p><span>10.我们有丰富的下午茶，高配高逼格的办公笔记本，每日四餐的美食体验</span></p>\n\n<p><span>11.更幸福的是公司配有各种福利区，理发，运动，咖啡，只有你想不到，没有我们做不到</span></p>\n\n<p><span>12.每天有35块的餐补</span></p>\n\n<p><span>13.六险一金（12％的公积金）</span></p>\n\n<p> </p>\n\n<p><span>【招聘对象】</span></p>\n\n<p><span>20届春招的小伙伴和21届暑期实习的小伙伴</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>【招聘岗位】 （前面带?的为稀缺岗位，HC多 竞争人数少，所以offer率会出奇的高，薪资也会更高一点，你们懂的）</span></p>\n\n<p><span>1. 营销类： 售前工程师，大客户销售，行业售前工程师</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>2. 安全类： web 安全工程师、威胁分析与安全运营、信息安全工程师、安全研究员、?反病毒工程师、网络防护工程师、?渗透测试工程师</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>3. 研发类： 数据分析及应用工程师、web 前端开发工程师、?安全开发工程师、大数据开发工程师、Windows安全开发、</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>服务端开发工程师-系统开发（Linux或者Windows）、服务端开发工程师-应用开发、移动 android 开发、</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>?客户端开发工程师-Linux 开发、? 客户端开发工程师-windows 开发</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>4. 算法类： 机器学习工程师</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>5. 测试类： 测试工程师</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>6. 技术类： 技术支持工程师</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>7. 运维类： 运维工程师、运维开发工程师</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>8. 职能类： 助理研究员、财务管理、采购专员、人力资源专员、商务专员、项目管理专员、政府项目专员、</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>行政专员、法务专员</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>【岗位地点】：</span></p>\n\n<p><span>北京，上海，武汉，成都，西安，珠海，沈阳，南京，深圳长沙，广州，贵阳，海口，杭州，拉萨，南昌，南宁，</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>天津，西宁，银川等天气预报cue到的城市都有~</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>【如何内推？】</span></p>\n\n<p><span>1. 先在牛客网完善自己的“在线简历”，若已经完成可直接进行下一项；若没有，页面右上角自己的头像，点“我的简历”，在“在线简历”写一份自己的简历！</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>2. 【HR小姐姐专属内推网申链接】</span></p>\n\n<p><span><a href=\"https://www.nowcoder.com/careers/qianxin/13274?type=neitui&amp;source=16B16CFF87562E5AB46FFE3CFCB787F6287A05BD4D8FBA82\">https://www.nowcoder.com/careers/qianxin/13274?type=neitui&amp;source=16B16CFF87562E5AB46FFE3CFCB787F6287A05BD4D8FBA82</a></span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>3. 往下拉，会看到“内推职位”，选一个点“申请”，然后“投递简历”，内推成功！</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>4. 等待笔试/面试 通知，通常是邮件 或者 短信形式，两个都要注意</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>5. 笔面试和offer流程：</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>【培训成长】</span></p>\n\n<p><span>全方位 360 度关注新人成长：</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>第一阶段：岗前学习（1-3 个月），明确导师，制定培养计划； 第二阶段：培训培养（入职培训 10-13 天+岗位培养 6 个月）； 第三阶段：长期发展——优中选优，成为骨干，为核心岗位人才选拔奠定基础；</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>【一线大厂笔面试原题+答案+简历模板】</span></p>\n\n<p><span><a href=\"https://www.nowcoder.com/discuss/246351\">https://www.nowcoder.com/discuss/246351</a></span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>?</span></p>\n\n<p><span>资料也同时全在这个帖子里哦</span></p>\n\n<p><span>祝大家春招顺利！</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>【如何内推？】</span></p>\n\n<p><span>1. 先在牛客网完善自己的“在线简历”，若已经完成可直接进行下一项；若没有，页面右上角自己的头像，点“我的简历”，在“在线简历”写一份自己的简历！</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>2. 【专属内推网申链接】</span></p>\n\n<p><span><a href=\"https://www.nowcoder.com/careers/qianxin/13274?type=neitui&amp;source=16B16CFF87562E5AB46FFE3CFCB787F6287A05BD4D8FBA82\">https://www.nowcoder.com/careers/qianxin/13274?type=neitui&amp;source=16B16CFF87562E5AB46FFE3CFCB787F6287A05BD4D8FBA82</a></span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>3. 往下拉，会看到“内推职位”，选一个点“申请”，然后“投递简历”，内推成功！</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>4. 欢迎加入内推QQ群，有大神云集哦：122127911</span></p>\n\n<p><span>5. 投递之后记得在评论区留个言说下职位哦，方便我帮大家在后台匹配投递记录！</span></p>',7,3,0,1,0,0,1,'2020-05-07 10:38:52','2020-05-13 19:18:25'),(25,'【内推】0 offer的赶快抓紧吧，送福利，传经验，帮内推','  在线回答  怎么答疑解惑 如何准备招聘会  简历排版  笔试  面试 技巧 奇安信是国内规模最大的信息安全公司，国内最具影响了的公司之一，奇安信以“成为全球第一的网络安全公司”为 愿景，奇安信是国内网络安全领域中...','push-in-0-offer-hurry-up-give-benefits-pass-experience-help-push-in','<p> </p>\n\n<p><br /></p>\n\n<p>在线回答  怎么答疑解惑 如何准备招聘会  简历排版  笔试  面试 技巧</p>\n\n<p>奇安信是国内规模最大的信息安全公司，国内最具影响了的公司之一，奇安信以“成为全球第一的网络安全公司”为 愿景，奇安信是国内网络安全领域中高速成长的企业，目前已拥有 7000 余名员工，2016-2018 年 三年的营业收入的年复合增长率超过 90%，增长速度创记录</p>\n\n<p>【内推方法】</p>\n\n<p>电脑投递：点进 <a href=\"https://www.nowcoder.com/careers/qianxin/13274?type=neitui&amp;source=16ED61390934CADA03E726DB685DB9BF77E6AA6078DCE88B5E9F2A685D821025\">https://www.nowcoder.com/careers/qianxin/13274?type=neitui&amp;source=16ED61390934CADA03E726DB685DB9BF77E6AA6078DCE88B5E9F2A685D821025</a> 往下拉，会显示【内推职位】，然后直接-》申请-》投递简历，即可内推 千万不要点进去点击官网投递</p>\n\n<p><br /><br /></p>\n\n<p>【福利发放】</p>\n\n<p>3000套简历模板 + 海量笔试面试原题 + 各种各种各样面经发放 + 研发资料收集 + 各种手写底层源码</p>\n\n<p><br /><br /></p>\n\n<p><br /><br /></p>\n\n<p><br /><br /></p>\n\n<p><br /><br /></p>\n\n<p>领取方法： 没有任何套路 投递简历后   评论区回复   已投递    就可领取我秋招整理的 大厂笔试面试原题 + 简历模板 + 求职资料</p>\n\n<p>3000套简历模板 + 海量笔试面试原题 + 各种各种各样面经发放 + 研发资料收集 + 各种手写底层源码</p>\n\n<p>【我们是谁】</p>\n\n<p>奇安信集团( 以下简称“奇安信”)是专门为政府、企业，教育、金融等机构和组织提供企业级网络安全技术、产品和服务的网络安全公司，相关产品和服务已覆盖90%以上的中央政府部门、中央企业和大型银行，已在印度尼西亚、新加坡、加拿大、中国香港等国家和地区开展了安全业务。奇安信是国内网络安全领域中高速成长的企业目前已拥有7000余名员工，2016- 2018年三年的营业收入的年复合增长率超过90%，增长速度创记录。 奇安信以“让网络更安全，让世界更美好”为使命，以“成为全球第一的网络安全公司” 为愿景，不断打造网络安全颠覆性和非对称性核心技术，竞争力不断提高。</p>\n\n<p>2019年7月, 奇安信正接受上市辅导 启动登陆科创板。</p>\n\n<p>2019年10月，奇安信以200亿元位列《2019胡润全球独角兽榜》第84位</p>\n\n<p>2019年12月，奇安信成为北京2022年冬奥会和冬残奥会官方赞助商。</p>\n\n<p><br /><br /></p>\n\n<p>2020年1月9日，胡润研究院发布《2019胡润中国500强民营企业》， 奇安信以市值230亿元位列第321位。</p>\n\n<p>【福利待遇】</p>\n\n<p>大公司 好待遇 工作地点全国各地选</p>\n\n<p>薪资情况可通过offershow，看准网等网站查询：360企业安全，或者奇安信进行了解</p>\n\n<p>1.我们有大牛导师带队，一般是一对一或一对二</p>\n\n<p>2.我们是国内最大规模网络安全公司(目前员工数接近8000)</p>\n\n<p>3.我们通过3年时间打造独立品牌(与360完全分离)</p>\n\n<p>4.我们走在当前网络安全的风口</p>\n\n<p>5.全新的技术，全新的产品，全新的理念</p>\n\n<p>6.只要你有能力，你就有机会拿股票拿期权</p>\n\n<p>7.我们拒绝996，因为toB根本不需要996！</p>\n\n<p>8.我们是新一代网络安全领军者</p>\n\n<p>9.我们期待你的第一份简历，当然还有第二次机会</p>\n\n<p>10.我们有丰富的下午茶，高配高逼格的办公笔记本，每日四餐的美食体验</p>\n\n<p>11.更幸福的是公司配有各种福利区，理发，运动，咖啡，只有你想不到，没有我们做不到</p>\n\n<p>12.每天有35块的餐补</p>\n\n<p>13.六险一金（12％的公积金）</p>\n\n<p><br /><br /></p>\n\n<p>领取方法： 没有任何套路 投递简历后   评论区回复   【已投递】    就可领取我秋招整理的 大厂笔试面试原题 + 简历模板 + 求职资料</p>',7,3,0,1,0,0,1,'2020-05-07 10:40:16','2020-05-13 19:18:38'),(26,'做了三年还觉得自己是菜鸟程序员','在我最开始写代码的时候，连最简单的权限系统都搞不清楚基本逻辑，被同事训斥了好几次。我一度认为自己不适合编程，夜里睡不着的时候会想要不放弃了吧。后来总算熬过去了，回头来看发现当时觉得很难的问题，也不过如...','ive-been-a-rookie-programmer-for-three-years','<p><span>在我最开始写代码的时候，连最简单的权限系统都搞不清楚基本逻辑，被同事训斥了好几次。我一度认为自己不适合编程，夜里睡不着的时候会想要不放弃了吧。后来总算熬过去了，回头来看发现当时觉得很难的问题，也不过如此。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>在我 curd 日渐熟悉的时候，自信到膨胀，觉得没有什么是不能 Google 出来的。有一次在一个面试中，突然迎面而来一个问题，php 有_GET 和_POST, 那么 put 请求是怎么获取的？开始是大脑一片空白，然后带着不确定的口吻尝试回答，但其实完全是不知道。后来反思总结了两点，第一，把框架的技术错误的等同于自己的技术让自己没清楚意识到自己水平，第二，作为一个 phper 连 PHP 手册都没有认真看一遍，贪图快带来了的后果就是基础不稳。先打好 php 基础吧，不要浮躁。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>后来的日子，在摸鱼的时候会看到论坛或者群里有人聊技术，每当出现了进程、线程、同步异步等等一些专业的计算机术语的时候就会觉得很打脑壳（四川话），curdboy 骂骂咧咧退出了群聊:triumph: 。在知乎上查看别人的高赞回答，觉得不过瘾又去 stackoverflow 上面看老外的回答，后来强迫自己看了《深入理解计算机系统》，慢慢的从野路子出身到开始查漏补缺完善自己的计算机知识体系。前端大火的这几年里，前端开发都饶有兴趣的聊着 node，说着什么非阻塞异步等等特性。那个时候我听到他们聊这些，我都不敢说话。后来在 php 项目中，利用队列、guzzlehttp 实现过异步。对异步有了更多的理解，异步不只是多线程独有的，只是刚好 node 用多线程去实现了异步，单线程本身也可以做异步。计算机知识真的很重要，让我看山不是山。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>不知道你们发现没有，像鸟哥，韩天峰、陈皓或者群里的大佬他们都会推荐大家学习底层，学习 c 语言。最开始的时候，我心态是他们装逼吧？后来抱着尝试的心态，在中国大学慕课上面认认真真的把翁恺老师的 c 语言课程看完后，以前一些感觉知识点很模糊的地方就豁然开朗。学到 c 静态变量的时候，触类旁通的搞清楚了 php 中超全局变量和静态变量的相关知识，在以后使用普通变量和静态变量的时候，有了更深的认识。学枯燥晦涩的计算机底层知识，不能让工资马上就涨，但让我看问题的角度确实就不一样了。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>后来接触的人变多了，让我知道了一件事。技术人员成为大牛，是一件概率问题。即使热爱技术，即使有心专研，依旧不能成为大牛。有人被无休止的加班拖累，有人被繁琐的技术栈折磨。做技术就是难者不会，会者不难。现在的我，是尽量帮助身边的同事朋友一起 debug。可能你会说，怎么都没看到我在论坛回答多少问题。说实话，隔着屏幕面对一个信息不全的问题，代码不知道上下文的一个片段，开发环境也没说明的时候，真的很难去做。这是一件费力不讨好的事情，所以我很敬佩经常在网上解答的朋友。被误解，是表达者的宿命。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>最后最后，我唯一能给大家的好建议就是，从现在开始锻炼身体吧。当你身体好的时候，精力充沛，debug 都事半功倍。之前司徒正美的离开，和最近每日优鲜程序员累死的事情都提醒着大家，好好活着。</span></p>',7,1,0,1,0,0,1,'2020-05-07 11:04:44','2020-05-13 19:18:00'),(27,'个人比较反感的一些写法','这只是我个人的感觉() 里面的数字代变我个人讨厌程度。1-5 吧这些令我反感的，我都做过 重要逻辑不拆分 (4) 这种才是最为讨厌的，一旦出 bug (也很容易出), 调试是非常麻烦的。 对于订单结算这些复杂操作，我认为必...','some-writing-methods-of-personal-disgust','<blockquote><p>这只是我个人的感觉<span style=\"font-size:inherit;\">() 里面的数字代变我个人讨厌程度。1-5 吧</span><span style=\"font-size:inherit;\">这些令我反感的，我都做过</span></p></blockquote>\n\n<p>重要逻辑不拆分 (4)</p>\n\n<p>这种才是最为讨厌的，一旦出 bug (也很容易出), 调试是非常麻烦的。</p>\n\n<p>对于订单结算这些复杂操作，我认为必须要用事件之类的来解耦。</p>\n\n<p>用 DB 查询 (3)</p>\n\n<pre><code class=\"lang-php\">DB::table(\'user\')-&gt;find(1);<br /></code></pre>\n\n<p>模型关联：减少非常多代码， 两表 或者 三表关联 过于噩梦 (主要原因)</p>\n\n<p>统一入口：用模型的 关于这个表操作全部都是这个模型</p>\n\n<p>模型自带的功能</p>\n\n<p>个人觉得，如果表单验证 需要 2 个 if 以上 就该用验证器 或 封装。<br /></p>\n\n<pre><code class=\"lang-php\">if(! $request-&gt;name) return $this-&gt;error(\"姓名不能为空\");\nif(! $request-&gt;phone)  return $this-&gt;error(\"电话不能为空\");\nif(! $request-&gt;phone)  ....\nif...    <br /></code></pre>\n\n<p>封装” 完美” 代码 (2)<br /></p>\n\n<pre><code>$this-&gt;bannerService-&gt;getBanner();\n//这个bannerService -&gt; bannerRepository -&gt; Banner(Model) \n<br /></code></pre>\n\n<p>实属蛋疼，对于简单的项目，尽量不封装才是最好的。<br /></p>',8,3,0,1,0,0,1,'2020-05-07 12:24:46','2020-05-13 19:20:15'),(28,'字节前端面试经历','2020年不仅是互联网寒冬，也是整个经济的大寒冬，在疫情缓和之后，本人就加入了求职者的大军，期望找一份更好的工作，来维持生活o(╥﹏╥)o。 因为疫情现在都是视频面试，字节用的是牛客网，支持在线视频和同步编码。...','byte-front-end-interview-experience','<p>2020年不仅是互联网寒冬，也是整个经济的大寒冬，在疫情缓和之后，本人就加入了求职者的大军，期望找一份更好的工作，来维持生活o(╥﹏╥)o。</p>\n\n<p>因为疫情现在都是视频面试，字节用的是牛客网，支持在线视频和同步编码。</p>\n\n<p>面试重点</p>\n\n<p>自我介绍，是一场面试的核心，面试官很多问题都源自你的自我介绍中。所以自我介绍的时候一定要捡你会的说。</p>\n\n<p><br /><br /></p>\n\n<p> </p>\n\n<p>面试题</p>\n\n<p>这次三轮面试总共做了四道面试题。</p>\n\n<p><br /><br /></p>\n\n<p>实现一个抓包请求</p>\n\n<p>这块一开始没了解清楚面试官的要求，然后具体问了下，最终理解下来是需要实现一个并发限制功能。</p>\n\n<p><br /></p>\n\n<pre><code>function asyncPool(poolLimit, array, iteratorFn) {\n  let i = 0;\n  const ret = [];\n  const executing = [];\n  const enqueue = function () {\n    if (i === array.length) {\n      return Promise.resolve();\n    }\n    const item = array[i++];\n    const p = Promise.resolve().then(() =&gt; iteratorFn(item, array));\n    ret.push(p);\n    const e = p.then(() =&gt; executing.splice(executing.indexOf(e), 1));\n    executing.push(e);\n    let r = Promise.resolve();\n    if (executing.length &gt;= poolLimit) {\n      r = Promise.race(executing);\n    }\n    return r.then(() =&gt; enqueue());\n  };\n  return enqueue().then(() =&gt; Promise.all(ret));\n}\n\n\n </code></pre>\n\n<p>实现一个防抖功能</p>\n\n<pre><code>function debounce(fn, wait) {\n  let timeout = null;\n  return function () {\n    if (timeout !== null) clearTimeout(timeout);\n    timeout = setTimeout(fn, wait);\n  };\n}<br /></code></pre>\n\n<p>拓展：现在有一个搜索输入框，已加上防抖功能，但是恰巧后一个请求先回来怎么办？</p>\n\n<p><br /><br /></p>\n\n<p>提供一个简单的思路，给每个请求复制给一个id，然后每次请求回来的时候判断下id是不是最新的。</p>\n\n<p><br /></p>\n\n<p><br /></p>\n\n<p>实现一个图片懒加载</p>\n\n<p>这里就不实现了，提供一个思维方式，图片懒加载中，最重要的一个步骤就是，在页面滚动的时候判断图片即将进入窗口。</p>\n\n<p><br /><br /></p>\n\n<p>我们可以判断图片在屏幕外，然后取反，就可以了。</p>\n\n<p>实现一个异步求和函数<br /></p>\n\n<pre><code>function createAdd(a, b = 0) {\n  return new Promise((resolve) =&gt; {\n    asyncAdd(a, b, (err, result) =&gt; {\n      if (!err) {\n        resolve(result);\n      }\n    });\n  });\n}\n\nasync function sum(...args) {\n  if (args.length &gt; 1) {\n    const result = [];\n    for (let i = 0; i &lt; args.length; i = i + 2) {\n      result.push(createAdd(args[i], args[i + 1]));\n    }\n    return sum(...(await Promise.all(result)));\n  }\n  return args[0];\n}\n\n </code></pre>',3,2,0,1,0,0,1,'2020-05-07 16:48:04','2020-05-13 19:08:52'),(29,'微信小程序开发个人心得与总结','本次的微信小程序开发简单来说还算顺利，因为毕竟后台有经验老道的大牛加持，因为项目组的其他成员以前也都没有接触过微信小程序开发，或多或少有过了解，但是没有真正的上手体验过，那就暂时让我这个菜鸟给个位讲讲...','personal-experience-and-summary-of-wechat-applet-development','<blockquote><p>本次的微信小程序开发简单来说还算顺利，因为毕竟后台有经验老道的大牛加持，因为项目组的其他成员以前也都没有接触过微信小程序开发，或多或少有过了解，但是没有真正的上手体验过，那就暂时让我这个菜鸟给个位讲讲我这次开发的心得与经验，废话不多说，进入正题。</p></blockquote>\n\n<p>目录</p>\n\n<ul><li> 首先，开发微信小程序需要使用一个编辑器，也就是微信开发者工具<br /></li><li>这个app.js就是全局的js文件，了解vue的话，可以理解为他是index.js，有着相同的功能，这里面可以放一些全局的属性。<br /></li><li>app.json这个文件比较有意思，他是放全局的配置的，比如小程序的头部以及底部，都可以用app.json配置，但是也并不是唯一配置的地方，当你添加一个页面的时候，每个页面都有一个json文件。这里面我们的tabbar就实在app.json配置的。<br /></li><li>app.wxss是全局的样式文件，project.config.json是小程序的配置文件。<br /></li><li>pages目录是这个小程序的总目录，images和libs可以按照个人喜好放文件。<br /></li></ul>\n\n<p>下面给大家介绍一下小程序登录以及请求接口拿数据渲染逻辑</p>\n\n<p>      首先，在请求我们的登录接口之前，我们需要通过wx.login()获取code，通过wx.request()请求后台接口将code传给后台，后台拿到code去请求微信官方的接口拿到openid和session_key返给前端，用作判断设备的唯一标识，然后我们拿到openid就可以带着账号密码登录了（不知道说的大家能不能懂，哈哈！！！其实大部分都在后台）。</p>\n\n<p>     需要注意的是，因为微信小程序是单项数据绑定的，当我们拿到input框的数据后，每次都需要setData()一下，不然没法给data{}中的数据赋值，这一方面感觉有点拉啊，像用惯了vue的v-model，简直是致命的打击。<br />    wx:if和wx:for也就是相与vue的v-if和v-for也就是判断和循环，渲染data中的数据直接使用{{xxxx}}就行了。<br /></p>\n\n<p>     总的来说，微信小程序开的很完善，各种toast,model,loading都封装好了，可以配合请求接口时直接调用，可以参照微信开发者文档。<br /></p>\n\n<p>       在请求接口方面，微信官方也封装好了，直接使用wx.request()请求就行了，在这里说明一下，无论是请求接口还是显示toast,loading都是可以使用回调的（成功与失败的回调），这样方便加入很多的操作。</p>\n\n<p>       然后就是微信小程序的一些钩子函数了<br /></p>\n\n<p>       进阶一下，微信小程序wxml中不能直接使用函数，这可怎么办，这简直是不能忍，渲染数据和格式数据很多地方都要用到函数筛选，不用急，soeasy!,微信小程序有自己的wxs,可以引入，对数据进行操作，但是wxs和js还是有点去别的，比如es6好多都用不了，wxs搞得和js基本一毛一样，但是又不能完全使用js的东西，那不是让我们抓狂吗！</p>\n\n<p> </p>',6,1,0,2,0,0,1,'2020-05-07 17:32:50','2020-05-13 19:15:55'),(30,'如何学习Kubernetes？','  推荐 张磊 老师的一本书和专栏 以及 陈皓 老师的几篇文章。 才云科技的教程kube-ladder，详细地讲解了从小白到大神的进阶之路，并且配套了很多源码，十分推荐: https://github.com/caicloud/kube-ladder  《Docker...','how-to-learn-kubernetes','<p> </p>\n\n<p>推荐 张磊 老师的一本书和专栏 以及 陈皓 老师的几篇文章。</p>\n\n<ol><li><p>才云科技的教程kube-ladder，详细地讲解了从小白到大神的进阶之路，并且配套了很多源码，十分推荐: <a href=\"https://github.com/caicloud/kube-ladder\">https://github.com/caicloud/kube-ladder</a></p>  </li><li><p><a href=\"https://book.douban.com/subject/26894736/\">《Docker——容器与容器云（第2版）》</a>：从 cgroup和 namespace，到Docker实现原理；从Docker Container 到 Pod；从 Pod 再到Kubernetes的各种Resources。由浅入深地讲解了Kubernetes的原理，十分推荐。（书里面还重点讲解了容器网络的原理，强推！）</p>  </li><li><p><a href=\"http://gk.link/a/100w5\">深入理解 Kubernetes</a>：张磊老师的极客时间专栏，写了 Kubernetes 的新特性和Kubernetes 背后的一些故事（比如：为啥Kubernetes会成功？ Kubernetes 社区怎么维护的？）</p>  </li><li><p><a href=\"https://coolshell.cn/articles/17010.html\">Docker基础技术：Linux Namespace（上）</a></p>  </li><li><p><a href=\"https://coolshell.cn/articles/17029.html\">DOCKER基础技术：LINUX NAMESPACE（下）</a></p>  </li><li><p><a href=\"https://coolshell.cn/articles/17049.html\">DOCKER基础技术：LINUX CGROUP</a></p>  </li></ol>\n\n<p>欢迎私信交流~</p>',6,3,0,1,0,0,1,'2020-05-07 18:52:38','2020-05-13 19:14:17'),(31,'那些年在编程题中踩过的坑','  循环输入输出处理常见问题  	1、为什么需要循环输入输出：通常来说OJ对于每道题里面有.in和.out文件，分别表示测试数据的输入和输出。如果某些编程题的所有数据都只做在一个.in和一个.out中，这样就会变成多组测试...','the-holes-in-programming-problems-in-those-years','<p> </p>\n\n<h3><strong>循环输入输出处理常见问题</strong> </h3>\n\n<p>	1、为什么需要循环输入输出：通常来说OJ对于每道题里面有.in和.out文件，分别表示测试数据的输入和输出。如果某些编程题的所有数据都只做在一个.in和一个.out中，这样就会变成多组测试了，所以需要提交的代码中循环处理。</p>\n\n<p>	2、处理方法：其实这个问题可以避免，就是编程题后台每个样例做一组对应的.in和.out文件，这样就变成单组测试，代码就不需要循环处理，但是平时练习的题目质量不一，这个问题都会出现。</p>\n\n<p>	代码里面循环处理了即使是单组测试也会完全没问题，所以为了偷懒，可以全写成循环处理。</p>\n\n<p>	3、还有一个坑：如果测试数据是多组的，但是恰巧你代码里面需要些标记数组，map，set等，在循环内一定记得清空，不然可能会产生前面的测试样例影响了后续数据的答案。</p>\n\n<h3>	<strong>对于各种语言的一些基本知识</strong> </h3>\n\n<p>	1、出题人通常会使用C/C++编写标程，数据也是由标程制造的，所以使用跟出题人一样的语言会比较稳妥</p>\n\n<p>	2、C/C++效率比较高，通常来说一般OJ对于一道题目的时限限制会区分C/C++和其他语言，通常处理方式是假设C/C++时限是1s，其他语言就会给2倍时限，甚至更多。</p>\n\n<p>	3、关于cin cout和scanf     printf。做题的时候尽量使用scanf  printf。下面告诉一个小常识，不要惊讶：在数据量比较大的情况下cin cout比scanf printf慢挺多。一旦遇到大数据量，光是读入就有可能跪掉。你或许可以使用std::ios::sync_with_stdio(false);  这条语句关掉scanf和cin的同步，加快效率。但是即使这样cin还要慢，而且一旦使用了这条语句，scanf和cin混用可能就会造成一些奇怪的错误</p>\n\n<p>	4、Java相关：Java整体效率大概比C/C++慢2倍以上，但是Java写编程题也没什么问题，主要就是处理好各种输入输出的情况。</p>\n\n<p>	5、python等等其他语言，<strong>做编程题首先要自己在平台上多练习不同的数据格式的读取方法</strong>，还有就是效率可能偏低，另外有些语言封装的功能太丰富了，以至于代码里各种函数完成的最终代码，笔试官或者面试官对于算法的考察并不想看到这样的code。</p>\n\n<p>	6、开辟数组空间最好根据题目的数据范围要求来，这里可能会造成runtime error，如果代码中递归的深度太深也可能爆栈空间导致runtime error。</p>\n\n<h3>	<strong>关于输出格式</strong> </h3>\n\n<p>	格式问题经常令人抓狂，其实主要都有几个常见的坑</p>\n\n<p>	1、行末空格：比如我输出需要打印多个数需要使用空格分隔的时候，我们循环使用printf(\"%d  \",x);这种会很方便，但是这样会导致行末多一个空格，后台系统会严格比对你的输出和.out文件，这样也会被判错误</p>\n\n<p>	2、换行问题，对于每个样例，建议输出完全之后都换行一下。对于一些题目，可能就是不换行就导致了后面输入数据错位，那就肯定不可能过了。</p>\n\n<h3>	<strong>关于时间复杂度分析：</strong> </h3>\n\n<p>	通常来说一般的系统1s能跑的算法量级是不足1e8的，所以做题的时候评估算法效率很重要，直接判断你的做法能否通过，当然这是以C/C++为标准的，其他语言自己乘个时间倍数。。</p>\n\n<p>	举个例子，比如题目n = 1e5，那么我就可以很敏感的知道我的算法需要一个 O(n) 或者 O(nlogn)。平方复杂度直接超时！</p>\n\n<h3>	<strong>最后关于 \"我本地能通过，交上去就是不对\"</strong> </h3>\n\n<p>	这个问题很蠢！通不过就是有一些问题。一个是要累积经验，分析到底可能出现的问题在哪里。另外不要使用一些奇怪的函数和行为。之前有见过有人使用了windows和linux平台那个功能的函数名都不一样的奇葩函数，所以要使用<strong>标准的跨平台的库函数</strong>。 各个语言一般平台都会告诉你每种语言给的编译器版本，这个环境信息也是很重要的。</p>',7,2,0,1,0,0,1,'2020-05-07 18:54:56','2020-05-13 19:17:57'),(32,'我眼中真实的华为实习生活','  来源：牛客网 LZ来华为实习一个月了。想和大家分享一下我自己在华为的实习生活。 	面试还有签约都是客服端开发。来的时候也是被分配到了志愿部门。本来是很开心的。但是当我到工位后才发现事情并不是那么简单。我...','huawei-internship-in-my-eyes','<p> </p>\n\n<p>来源：牛客网</p>\n\n<p>LZ来华为实习一个月了。想和大家分享一下我自己在华为的实习生活。</p>\n\n<p>	面试还有签约都是客服端开发。来的时候也是被分配到了志愿部门。本来是很开心的。但是当我到工位后才发现事情并不是那么简单。我发现周围人都没有在写代码，都是在弄文档。然后我就主动跟带我的老师提出我的疑惑，老师也很真诚的跟我说部门是为开发服务的测试部门。然后我和老师交流了一下，老师也说我实习期间其本不会写代码，然后我就向老师表明了我只干开发写代码不想干测试。然后老师也很好，说会帮我交涉换岗。所以第一周我基本都是忙换岗的事情，真的很感谢带我的老师，领导和hr。很尊重我的想法。所以后来就换到了开发岗，虽然做的工作不是啥核心技术，但是能接触到项目，能天天写代码，就很开心。最主要的是这些工作细细分开都是平时自己所学的一些基础组合在一起。所以能切身实际的感觉到自己这么多年所学能用到实际项目中。很欣慰。</p>\n\n<p>	接着说我的工作。我被分到的项目组里成员都是些比我稍微大一些的哥哥姐姐。所以我有不会的就转圈地问他们。他们都很和蔼，有问必答，还有个哥会经常主动过来看我进度，问问我有什么需要帮助的。总之跟着他们学到了很多。第一次动手写需求的时候，真的是完全不会，然后有个老师就直接一边给我讲流程，一边敲出了个需求给我打样子。当时就觉得那个哥太帅了，实名羡慕，想成为他那样的人，逻辑清晰，代码规范。后来更幸运的是领导还给我分配了个正式员工的小姐姐，帮我一起完成整个需求。所以我就又多了个老师。</p>\n\n<p>	接着说下任务量，由于很多人可以请教，所以目前为止遇到的问题都能很快解决。然后我就每周给领导汇报进度，他要是觉得我做的可以就继续分配任务，要是哪里不行，就会让那些老师们指导我一下再改改。</p>\n\n<p>	再说一下华为的氛围真的很不错。大家对自己的任务都是很认真。上班期间大家都是在努力的完成自己的工作，真的有一种把公司工作当成自己的工作地认真态度。还有就是外界一直传的加班的问题。至少在我看来不是这样的。我一个实习生六点就可以走。但是我一般会待到八点半（没错，是为了免费的夜宵）其实我发现正式员工他们基本也是八点半就走了。待到很晚的基本都是领导了（怪不得人家能当上领导）我有时候周末会去公司自习，我看周末加班的人也很少。</p>\n\n<p>	最后就不得不提一下华为的零食。来华为最大的感触就是零食太多了。啊哈哈哈。除了晚上免费的夜宵，部门还有个零食柜，秘书小姐姐会经常来给我投喂，而且还会时不时拉一小车水果来给大家分。甚者晚上加班到很晚的时候，还会有领导过来对你说声“辛苦了”顺便送你个牛奶或者水果捞。还有就是只要是开会或者培训，屋里一定是四周摆上水果零食，我们都是一边吃一边听。这样就省下了买零食和水果的花销。而且华为这里是在北京超级偏僻的地方。所以每天除了吃饭基本也没有别的花销了。华为的食堂也还不错。一顿饭大约20。</p>\n\n<p>	总结就是，在这里实习，除了可能会被随机分岗之外，其他都很Nice。但是随机分岗这件事又很难避免，我看一些更好的学校，一些清北，北航，天大南开的大佬们也可能会被随机分配。但是我觉得无论干什么在这里都能学到很多。无论是专业领域还是社会与人交往方面。</p>',7,5,0,1,0,0,1,'2020-05-07 18:57:36','2020-05-13 19:17:20'),(33,'工作了一段时间，突然想读博了','工作了一段时间，突然想读博了，跪求各位大佬敲醒我?','after-working-for-a-while-i-suddenly-want-to-read-blog','<p><span style=\"color:rgb(51,51,51);\">工作了一段时间，突然想读博了，跪求各位大佬敲醒我?</span><br /></p>',2,5,0,1,0,0,1,'2020-05-07 18:58:48','2020-05-13 19:07:04'),(34,'租房帖子','  来源：牛客网 北京•保利茉莉公馆，2室1厅1卫，    85平南向，2012年房，次顶层（总共24层）     要求：整租，月租金5500-6000（价格可商量）     自如装修，⚠️高米店北地铁站 在小区地下，直接不出小区进入地铁站...','renting-post','<p> </p>\n\n<p>来源：牛客网</p>\n\n<p>北京•保利茉莉公馆，2室1厅1卫，</p>\n\n<p>   85平南向，2012年房，次顶层（总共24层） </p>\n\n<p>   要求：整租，月租金5500-6000（价格可商量） </p>\n\n<p>   自如装修，⚠️高米店北地铁站 在小区地下，直接不出小区进入地铁站。 </p>\n\n<p>   价格面议，有意者私信！</p>',2,5,0,1,0,0,1,'2020-05-07 19:00:55','2020-05-13 19:06:47'),(35,'涨薪50%的简历+面试核心法则',' 从C酱提出离职，同事建议这个行情不要轻举妄动吧。再到我说出自己的薪资，好生惹人羡慕。最近更是很多同事要我的简历，去进行修改。从内推到石沉大海，我们的简历差别是什么？图6J姐详细分析了我与一位同事的简历差...','resume-with-50-salary-increase-core-rules-of-interview','<p> 从C酱提出离职，同事建议这个行情不要轻举妄动吧。再到我说出自己的薪资，好生惹人羡慕。最近更是很多同事要我的简历，去进行修改。从内推到石沉大海，我们的简历差别是什么？图6J姐详细分析了我与一位同事的简历差别。</p>\n\n<p> </p>\n\n<p>????</p>\n\n<p>	面试一问:请自我介绍。很多人是工作经历的介绍，做了哪些，项目成果是。</p>\n\n<p>	? C酱的自我介绍，跳脱于形式的，说成果却不说成果:我是C酱，从事教育行业中所带来的xxx成就，其中xxx成就可以再我的简历中详细看出，针对上面问题，如果老师有任何疑问都可以问我；这样说，一是缓解自己不会总结性的自我介绍，二是引起面试官好奇，去认真看你的简历突出的工作介绍。（重点项目介绍就很重要了。）三是为了掌握主动权，引导面试官，直接进入正题。如果这时面试官没打断你，可继续后面的介绍。</p>\n\n<p>	面试二问:加班，你怎么看。</p>\n\n<p>	??很简单，不说空话，什么自己不会加班，什么努力提高自己的工作效率，让这样的事情少发生。这已然成为标准答案，?C酱回答:加班，已为互联网常态了，我们注意的不应是加班，而是重点得到了什么，如果因我工作进度加班，提高效率；如果加班的时候，我能学习其他的东西，比如自己学习安排，公司的学习安全，也方便老板随时找到我，两全其美，何乐而不为呢。</p>\n\n<p>	面试三问:你期望的薪资？</p>\n\n<p>	?这个问题真的是重头戏，啊啊啊啊，想要高工资，看了看自己的流水，脑壳疼，对不对！对不对！</p>\n\n<p>	C酱也是。但你需要拿出砍价买衣服的自信，基本会事半功倍，你买衣服时，坚信这衣服值这个价格，那自己呢，是不是更值这个价；化身卖家，你为了挣到钱，需提高自己身价，等对面还价，不满意价格，可以，想想你是怎么挑那件衣服的不好，什么线头啊，什么破损。这个时候挑自己的优点，能怂吗，不能！如果有其他同类型的竞品的offer也可做出说明！接下来就是，你品，你细品！</p>',2,5,0,1,0,0,1,'2020-05-07 19:02:43','2020-05-13 19:05:32'),(36,'一则交友贴','  个人简介：男，92年人，狮子座，身高178，体重71，体型不错。去年211硕士毕业，目前在上海某航司工作，本来想去互联网，最后还是选择本专业，平时上二休二不加班，时间充裕，自己也会去做一些事情，已在上海落户并...','a-friend-making-post','<p> </p>\n\n<p>个人简介：男，92年人，狮子座，身高178，体重71，体型不错。去年211硕士毕业，目前在上海某航司工作，本来想去互联网，最后还是选择本专业，平时上二休二不加班，时间充裕，自己也会去做一些事情，已在上海落户并打算在此长期发展。</p>\n\n<p>兴趣爱好：对很多事情都抱有兴趣，较擅长的有摄影，美食，做旅行攻略，羽毛球乒乓球足球等，还有热衷多类型电影。</p>\n\n<p>另一半期待：性别女，164以上，在上海工作，学历本科及以上，天蝎座除外，性格直爽，有对美的理解和一定衣品。</p>\n\n<p>想对她说的话：有过几段感情经历，深知人与人的相逢来是缘，散也是缘。现在心静下来想找个人踏踏实实过我们的生活，虽然我们都曾不甘于平凡，但我想，两个人一起努力的日子会比一个人好一些。最后希望我们能互相理解欣赏对方。</p>\n\n<p>春天来了，你愿意跟我一起去看看外面的世界吗？</p>',2,5,0,1,0,0,1,'2020-05-07 20:03:23','2020-05-13 18:47:36'),(37,'两年Java工程师经历第一次社招--给新生的建议和规划','  经过此次疫情，现在工作不好找，面试了很多次，才进入一家公司，请相信有志者，事竟成，幸福美好的生活都是自己拼来的，一起加油吧      首先对于很多从事程序员这个职业的人，在到了30岁以后就会有一大部分想要转...','java-engineers-experience-the-first-social-recruitment-in-two-years-suggestions-and-plans-for-freshmen','<p> </p>\n\n<p>经过此次疫情，现在工作不好找，面试了很多次，才进入一家公司，请相信有志者，事竟成，幸福美好的生活都是自己拼来的，一起加油吧</p>\n\n<p>     首先对于很多从事程序员这个职业的人，在到了30岁以后就会有一大部分想要转行，为什么会出现这种情况呢?程序员无疑是个调薪行业，所有高薪行业都有围城现象，圈外人看高薪，圈内人看苦逼，而真正热爱的人，一定会走下去，直到牛气冲天，比如安全界的tomkeeper、黑哥都是医学界跨过来的大牛。另外一种原因，很多人是喜欢编程才干这一行的，但大多数人是为了糊口才来掺和一下的。  </p>\n\n<p>         混口饭吃和喜欢才去做是完全不同的，所能到达的成就也将会天差地别。仅此举个我身边的例子，之前公司同一部门的一个Java工程师，天天只知道维护，在没有项目的时候无所事事，成天混日子，也不懂得去学习，根本不上github和stackflow这类技术人员专业的网站。当我们的PM提出市场上最先进的功能时，他却连怎么做都不知道，并且直接就说这个做不了!这样固守一方怎么会有成就?    </p>\n\n<p>     而另外一个前端工程师则完全相反，在一些特殊的情况下，我与他也一起住了一段时间，他是一个对自己目标非常明确的人，每天晚上下班后，会自己看视频学习相关UI设计、JS、一些小插件等。并且当我们的PM提出他不会的需求的时候，他不会说做不了，而是说我去查查看看怎么做，然后会研究出来最终实现这个功能。  </p>\n\n<p>    一位新手工程师给年轻程序员的建议   </p>\n\n<h2>    1、好好规划自己的路，不要跟着感觉走;   </h2>\n\n<p>    根据个人的理想来安排自己的生活，绝大部分人并不指望成为什么院士或教授，而是希望活得滋润一些，痛快一些，那么就需要慎重安排自己的的轨迹，从一个行业入手逐渐对该行业深入了解，不要频繁跳槽，特别是不要为了一点工资而转移阵地，从长远看，这点钱根本不算什么，当你对一个行业有那么几年的体会以后，钱根本不是问题，频繁地动荡不是上策，最后你对哪个行业都没有摸透，永远是新手。   </p>\n\n<h2>    2、可以做技术的，切不可沉湎于技术;   </h2>\n\n<p>    千万不可一门心思钻营技术，给自己造成很多压力，如果你的心思全部放在上面那么注定你将成为孔乙己一类的人物，适可而止为之，因为技术只不过是你今后前途的支柱之一，而且还不是最大的支柱，除非你只愿意到老，还是个工程师。   </p>\n\n<h2>    3、不要去做技术高手，只去做综合素质高手;   </h2>\n\n<p>    在企业里工作，我们时常瞧不起某人，说他“什么都不懂，凭啥拿那么多钱，凭啥升官，”这是普遍的、典型的工程师的迂腐之言，你想想，老板搞经营那么多年难道见识不如你这个新兵?人家或许善于管理，善于领会老板意图，善于部门协调等等等，因此务必培养自己多方面的能力，包括，管理，亲和力，公关能力等要成为最综合素质的高手则前途无量，技术以外的技能才是更重要的本事，从古到今，一律如此。   </p>\n\n<h2>    4、多交“三教九流”的朋友;   </h2>\n\n<p>    不要只和工程师交往，认为有共同语言，其实更重要的是和其他类人物交往，如果你希望有朝一日当老板或高层管理者，那么你整日面对的就是这些人。了解他们的经历，思维习惯，爱好，学习他处理问题的模式，了解社会各个角落的现象和问题，这是以后发展的巨大本钱，没有这些以后就会笨手笨脚，跌跌撞撞，遇到重重困难，交不少学费的成功的概率大大降低。   </p>\n\n<h2>    5、知识涉猎不仅要专，还一定要广;   </h2>\n\n<p>    多看看其他方面的书，金融，财会，进出口，税务，法律等等为以后做一些积累的以后的用处会更大，会少交许多的学费。   </p>\n\n<h2>    6、抓住时机向技术管理或市场销售方面转变;   </h2>\n\n<p>    要想有前途就不能一直搞开发，适当时候要转变为管理和或销售的前途会更大，以前搞技术也没有白搞，以后还用得着，搞管理可以培养自己的领导能力，搞销售可以培养自己的市场概念和思维，同时为自己以后发展积累庞大的人脉，应该说这才是前途的真正支柱。   </p>\n\n<h2>    7、逐渐客户自己的心理弱点和性格缺陷;   </h2>\n\n<p>    多疑，敏感，犹豫不决，胆怯，多虑，这些工程师普遍存在的性格弱点必须改变，很难吗，只在床上想一想当然不可能改变，去帮朋友守一个月地摊，包准有效果，去实践，而不要只想，不克服这些缺点，一切不可能，甚至连项目经理都当不好，?尽管你可能技术不错。   </p>\n\n<h2>    8、工作的同时要为以后做准备，建立自己的工作的环境;   </h2>\n\n<p>    及早为自己配置一个工作环境，装备电脑，模拟器，编程器等，业余时间可以接点活，一方面接触市场，培养市场感觉，同时也积累资金，更重要的是准备自己的产品，咱搞技术的没有钱，只有技术，技术的代表不是学历和证书，而是产品，拿出像样的产品，就可以技术转让或与人合作搞企业，先把东西准备好，等待机会，否则，有了机会也抓不住。   </p>\n\n<h2>    9、要学会善于推销自己;   </h2>\n\n<p>    不仅要干，还要能说，能写，善于利用一切机会推销自己，树立自己的品牌形象，要创造条件让别了解自己，不然老板怎么知道你能干，外面的投资人怎么相信你，提早把自己推销出去，机会自然会来找你，搞个个人主页是个好主意，特别是培养自己在行业的名气，有了名气，高薪机会自不在话下，更重要的是有合作的机会。   </p>\n\n<h2>    10、该出手时便出手。   </h2>\n\n<p>    永远不可能有百分之百把握，条件差不多就要大胆去干，去闯出自己的事业，不要犹豫，不要彷徨，干了不一定成功，但至少为下一次冲击积累了经验，不干永远没出息，而且要干成必然要经历失败，不经历风雨，怎么见彩虹，没有人能随随便便成功。</p>\n\n<p>但是，工作以后不要忘记学习，也要继续学习，牛客网、csdn等网站就是很好的学习社区。</p>\n\n<p> </p>\n\n<p>从不同的人对待不同的事情看来，很明显将会有不同的成就。因此，对于那些很多看上程序员调薪才入行而对编程本身却不感兴趣的朋友们来说，在到了40岁左右的时候，他们会突然发现，继续做这些编码的活下去不是办法，没有出路。那么怎么办呢?转行吧!这就有了为什么这么多程序员想要转行一说。</p>\n\n<p> </p>\n\n<p>如果一个人对自己的职业生涯没有规划的话，是件很可怕的事情。如果你没有规划好，你可能在事业上就不那么上进，浑浑噩噩到了30而立之年，你会发现你的下半辈子要怎么过都不知道。所以职业生涯的规划非常重要。那么Java工程师的职业生涯应该如何规划?下面一起来了解一下Java工程师的职业生涯应该如何规划。  </p>\n\n<p>   Java工程师的职业生涯应该如何规划?  </p>\n\n<p>   “选择重于努力，方向重于能力。”很多职场人都缺乏借助职业导师的职业智慧和职场经验为自己拨开职场迷雾，导航职业方向的意识。钟总监建议，有好像王敏这种职业困惑的职场人，最好向具有同行业职场经验的职场导师寻求职业指导，借助导师们的职业智慧和职场经验让自己少走弯路。</p>\n\n<p> </p>\n\n<p><strong>选择比能力重要</strong>！  </p>\n\n<p>   通常，作为开发工程师，一般会有以下几种职业走向。  </p>\n\n<ul><li>    走技术路线：技术高手、技术专家、软件架构师。      </li><li>    走管理路线：项目经理、部门经理、技术总监。     </li></ul>\n\n<p>   甚至，从事销售顾问、培训讲师、自己创业都是一种可能。  </p>\n\n<p>   其实，这些职业当中的每一种，都有一条非常宽敞的职业发展之路，关键在于作为还是一个开发工程师的你，将会做出什么样的选择，哪怕我们想从事软件产品的市场和销售工作，带着对技术的理解，也必将做出自己独特的一面。  </p>\n\n<p>   但无论如何，我们都要做出一个选择，给自己定一个目标。目标对人生有着巨大的导向作用。成功，在事业起步的时候仅仅是一种选择，你选择什么样的目标，就会有什么样的人生。不少朋友最大的痛苦就是不知道自己适合做什么，该干什么，该走什么路，不满足于现状又不得不沉沦于现实。  </p>\n\n<p>   所以，先认清“正确的结果”，根据正确的结果去设计你的过程。当一个人具有明确的职业目标时，就会对有助于实现目标的蛛丝马迹都特别敏感，做事情相应也就会很有目的性，而不是稀里糊涂的。所以，就容易到达自己的目的。如果没有职业目标，就算是天上真有神仙，神仙也不知道该给你什么。  </p>\n\n<p>   “做正确的事情，永远比正确地做事更重要!”  </p>\n\n<p>     最后，在这里希望不管喜欢还是不喜欢编程的Java程序员们都能好好规划一下自己的职业生涯，在接下来的职业道路上走得越来越远！  </p>\n\n<p>     附上俺的牛客博客：<a href=\"https://blog.nowcoder.net/stylitelyp\">https://blog.nowcoder.net/stylitelyp</a>   </p>\n\n<p>   <strong>谢谢您的支持！</strong></p>',2,2,0,1,0,0,1,'2020-05-07 20:08:00','2020-05-13 18:47:32'),(38,'入职三个月','  一转眼距离去年第一次去北京实习已经过了17个月；距离第一个秋招offer过去了15个月；距离签约北漂过去了一年；距离春招毁约过去了半年多。。。  现在入职三个多月，技术氛围一般，很多活都是外包在做；  工作强度...','three-months-in-office','<p> </p>\n\n<p>一转眼距离去年第一次去北京实习已经过了17个月；距离第一个秋招offer过去了15个月；距离签约北漂过去了一年；距离春招毁约过去了半年多。。。</p>\n\n<p> 现在入职三个多月，技术氛围一般，很多活都是外包在做；</p>\n\n<p> 工作强度一般，比以前小了很多，很少再会焦头烂额，基本都能应付，还能经常帮别人解决问题。想起两次实习都只有我一个实习生&amp;女生，压力大到失眠，9 10 7的日子，带电脑回出租屋加班到深夜的日子，现在应该再也不会有了；</p>\n\n<p> 心态上，有时会觉得自己没有成长，但仔细想想，不管走到哪里，成长都是取决于自己啊；</p>\n\n<p> 有过抱怨，有过不满，有时8点下班看着空荡的办公室，都会觉得很累。但仔细想想，在互联网公司9.10点等着打车的日子，好像现在也算幸福。</p>\n\n<p> 得到一些的同时，肯定会失去一些的。琐碎的流程多了，技术上的打磨和深入少了，即使菜鸡如我，好像也成了身边人眼中的“大佬”。有时心里会很慌，担心自己原地踏步有一天被淘汰，陷入焦虑中。</p>\n\n<p> 有时觉得自己身上还留有互联网的烙印，在别人眼里宛如奋斗逼。周天路过公司想起工作没完，顺便去改了会代码做压力测试，同事知道后都目瞪口呆。。。</p>\n\n<p> 值得庆幸的是有时间跑步，健身，做任何想做的事情了。这半年身体不好了，工作强度太大也吃不消。</p>\n\n<p> 有时会怀念在学校的日子，每天只需要上课，做个本分的学生。</p>\n\n<p> 而工作就像谈恋爱——你看上的看不上你，看上你的你不满意，分手以后会怀念前任，仔细想想现任也凑合，哪有那么多白月光。</p>',8,4,0,1,0,0,1,'2020-05-07 20:09:12','2020-05-13 19:19:53'),(39,'【毕业三年总结】希望对各位有帮助','  今天发现帖子未经我同意的情况下被转载了，特此说明一下，未经我本人同意的情况下禁止转载，谢谢大家。       说来奇怪，毕业三年了，每年都看到很多人会写年度总结，但是自己总提不起兴趣去写，但是今年写个总结...','summary-of-three-years-after-graduation-i-hope-it-can-help-you','<p> </p>\n\n<p><strong>今天发现帖子未经我同意的情况下被转载了，特此说明一下，未经我本人同意的情况下禁止转载，谢谢大家。</strong> </p>\n\n<blockquote>     说来奇怪，毕业三年了，每年都看到很多人会写年度总结，但是自己总提不起兴趣去写，但是今年写个总结的想法非常强烈，可能是今年不管是从工作还是从生活都有一些比较大的感触吧。  <br />     我个人不是牛客的老用户，准确的说我才用不到1个月，也是因为年底了突然有了想往互联网跳槽的想法，来牛客刷了下剑指offer的题目。  <br />     偶然的机会发现讨论区里还是蛮活跃的，并且发现以应届毕业生为主，想着是不是也总结一下，看看能不能给学弟学妹们一些启发。  <br />     我这个人写东西比较碎碎念，而且没有什么逻辑，一般都是想到哪写到哪，大家见谅。  <br /><br /><br />     我想从下面几个方面分享一下：  <br />     1. 个人情况碎碎念  <br />     之所以想介绍个人情况，也是想给后面的内容一个背景色。  <br />     2. 应届生找工作如何准备？  <br />     简历？刷题？笔试？面试？内推？  <br />     3. 毕业的抉择  <br />     时间不同，但相信大家遇到的问题都差不多。  <br />     4. 2016-2019的银行IT工作生涯  <br />     做一个工程师，而不是一个码农。  <br />     5. 银行转互联网难么？  <br />     今年年底把北京各个大厂都面的差不多了，有了一些自己的想法。  <br />     6. 朋友口中的互联网  <br />     虽然我不在互联网，但是我朋友多啊..  <br />     7. 2019年年末的互联网走一圈  <br />     分享一下年底这一圈拿到的offer情况，以及我了解到的互联网现状。  <br />     8. 2020依然在抉择  <br /></blockquote>\n\n<p>  <br /></p>\n\n<p>  1. 个人情况碎碎念 </p>\n\n<p>  <br /></p>\n\n<p>  - 我是江苏人，本科是南京的一个非211非985的综合类院校，计算机专业实力一般更不是什么热门专业。幸运的是，这个是我自己选择的专业，很长一段时间我都认为是因为沉迷电脑游戏我才这么选的。 </p>\n\n<p>  - 大三的同学都会面临一个选择，考研还是工作？ 我选择考研，原因很简单，我想要一个更好的平台。 </p>\n\n<p>  - 功夫不负苦心人，顺利考上一个211的研究生后，发现研究生的生活就是在为导师打工，我个人其实不排斥这种事情，相反我还有点感谢这为我带来了很重要的项目经验。 </p>\n\n<p>  - 毕业后，没有去向往的互联网行业，而是去了银行IT。 </p>\n\n<p>  - 毕业三年了，拿了北京户口，今年也结了婚买了房，背上了200多万贷款，好在三年间待遇从税后20W涨到了40W，还贷虽然仍然有压力，但是也还能过得滋润。 </p>\n\n<p>  - 今年年底想着试试往互联网看看，面了一圈，对如今的互联网又有了新的认知，也面临了新的分叉路，如一个学生一样不知道如何抉择。 </p>\n\n<p>  <br /></p>\n\n<p>  <br /></p>\n\n<p>  2. 应届生找工作如何准备？ </p>\n\n<p>  我是做Java后端的，我就说说我的一些经验吧。 </p>\n\n<h3>  简历 </h3>\n\n<ul><li>   不要只说你做了什么，还要说实现了什么效果。如性能优化，那就要提到你优化之后提升了多少性能指标；    </li><li>   你写在简历上的东西，你必须做到不管面试官怎么问，你都能招架的住。甚至你都可以将不是你做的内容写上去，但是必须做到不会被问倒。简历就好像是你给面试官的一个题库，他只会在你的题库中去问你，如果你这样都被问倒了，那真的是你自己的问题；    </li><li>   简历中提到技术栈，最好不要都停留在使用层面，尽可能的往原理层去多了解，因为面试官一般都会针对一个点不断的往深层次问的。所以有个技巧就是缩小范围，比如你本来写的是熟悉Java。这个范围就很广，你指不定面试官会问题什么，建议你后面再跟上具体的如集合，IO等，这样你就可以有针对的去准备；   </li></ul>\n\n<h3>  刷题 </h3>\n\n<ul><li>   我当时刷的是英文的leetcode，最近发现都有了中文版了，叫力扣，但是我个人感觉还是英文版的更好一些，主要是discuss的质量，发现力扣里面太多为了做题而做题了；    </li><li>   刷多少？ 我们毕业的时候leetcode算法题一共也就300多点好像，我当时把简单和中等的都刷完了，一般都是直接在页面敲，不去用IDE的自动提示，这对你后面面试手写代码很有帮助；    </li><li>   剑指offer现在似乎依然很热门，建议都过一遍；    </li><li>   ACM有必要刷么？ 没有，因为这种题目以及不是校招算法题的难度了，基本不太会遇到；    </li><li>   刷题有用么？有！先不说你掌握了一些标准算法的解题技巧，就撞题这个事来说，概率真的不小。   </li></ul>\n\n<h3>  内推 </h3>\n\n<ul><li>   一定要知道一个原则，能内推的绝对不走统招，因为你根本不知道为什么你感觉做的很好的一套笔试题怎么就没通过；    </li><li>   很多高校的论坛，比如水木、北邮人等等都有师兄师姐们发内推的帖子，管他是不是亲师兄亲师姐，能蹭就蹭，不亏的；   </li></ul>\n\n<h3>  笔试 </h3>\n\n<ul><li>   笔试这个东西，很悬，就跟上面说的一样，你不知道怎么的你就挂了，而且根本不给你理由    </li><li>   所以，能集中大家智慧一起答题的，就集中，别当孤胆英雄。（当然也要注意别被发现）   </li></ul>\n\n<h3>  面试 </h3>\n\n<ul><li>   答的上来的问题，就要充分展现自己，说的面试官明明白白，结束的时候甚至可以有意无意的往另外一个你知道的知识点上面去引；    </li><li>   对于不会的问题，那就不要再想了，用自己的思路去想如果让你做你应该怎么做，然后告诉面试官你不知道，但是如果是你做，你会怎样怎样，这样比直接说不会要好；    </li><li>   面试之后对于自己不会的知识点进行复盘，下次面试再问到能回答上来就行；    </li><li>   如果可以，建议先找一些小公司或者不太想去的公司去刷一刷面试经验（虽然有点不太厚道）；   </li></ul>\n\n<p>  <br /></p>\n\n<p>  3. 毕业的抉择 </p>\n\n<p>  我当时可能是对自己未来的想法比较明确吧，我要留北京，所以必须要有户口，所以就在我的有户口的offer中挑了一个待遇最高。 </p>\n\n<p>  这部分我没有太多想说的，主要还是看你个人想法。 </p>\n\n<h3>  户口 </h3>\n\n<p>  这里我说的是北京户口，别的地方我也没经验。其实很多公司都有户口，国企、银行、研究所、运营商、互联网，只是指标多少、竞争多少、拿户口概率多少的问题。 </p>\n\n<p>  对于当时的我来说，第一选择是互联网行业并且一定能拿到户口的，但是后来发现太难了，可能是个人水平有限吧。 </p>\n\n<p>  如果你是想未来在北京定居的，那我认为你应该将户口放在第一位，因为从目前看到的情况来说，没有户口同学很多都回老家或者各个城市换来换去，很少能一直坚持在北京的，特别是当你面临结婚、买房、生娃这样的事情的时候。 </p>\n\n<p>  <br /></p>\n\n<blockquote>  <p>   额，发现很多同学纠结于楼主的工资，我大概解释下。  </p>  <p>   首先，在16年的时候，这个起点工资确实是高的，关键还解决户口。但是我算的20w指的是转正后的一年收入，银行是有试用期的，半年适用期80%工资，所以如果按照正常毕业的时间点算，可能第一年到不了20w税后。  </p>  <p>   第二，现在起点依然是这么多，但是互联网白菜价已经到了30w的门槛，税后已经被超过了。  </p>     第三，为什么可以涨的这么快，这么说吧，三年拿了4个最高绩效评级，所以涨的比较快。这部分我会在银行工作三年的部分给大家说一下自己的经历。  <br /></blockquote>\n\n<h2>  ----------------------------------------二更开始-------------------------------------------- </h2>\n\n<h3>  银行 </h3>\n\n<p>   在我入职银行钱，我对银行的印象一直是“待几年就废了” “涨薪慢” “关系比能力重要” ，嗯，确实这些并不是谣言，但是也没那么绝对 </p>\n\n<p>   <strong> “待几年就废了</strong><strong>”</strong>：这个其实看个人，在银行里，特别是搞开发的，你很容易从一个写代码的上升到管外包公司的人去做项目的项目经理。这个仁者见仁智者见智，对于一部分人来说，他可能就只做项目管理，了解业务需求，然后交给外包的去做，不在去关注技术实现，甚至我见过连需求都不管，丢给外包公司的一个小组长去负责的，对于这部分人确实“待几年就废了”，但是不是因为你在银行，而是你在银行你选择了这样的工作方式。但是从另外一个角度来看，这是个优势，因为相对于互联网来说，你更容易跳出写业务代码的工作内容，从一个拧螺丝的角色变到一个掌握方向盘的角色，也就是一个项目或者系统的管理者、架构的设计者。我自己现在也基本不写代码，但是我要保证如果是我自己写我是有能力写的，可以不熟练，但是要具备这样的额能力，这就足够了，然后将自己的大部分时间抽到对业务模型的理解，对架构的优化上。所以我leader经常跟我们说，不要把自己定位成一个码农，码农做的是你去翻译别人告诉你的代码逻辑，要做一个工程师，去抽象、设计、实现、优化。 </p>\n\n<p>   <strong> “涨薪慢”</strong>：其实现在互联网的红利也越来越少了，我问了下互联网的情况，涨薪也不是很快。但是往往互联网会有普调之类的，幅度还是乐观。关键是互联网跳槽简单，所以涨幅整体看上去还不错，一般跳槽都能拿到20%-30%的涨幅，但是银行的人一般不会跳槽，所以只能在银行里面熬资历。如果不说跳槽的话，在一个公司内部升职加薪，都不容易。 </p>\n\n<p>   <strong> “关系比能力重要”</strong>：这个身边也确实有这样的情况，但是不妨碍能力强的人靠自己的努力升的也快，努力做一个不可被替代的人，这样你的议价权就会很高，领导也会自然的重视你。 </p>\n\n<p>   有同学说到银行的科技在做子公司化，我也大概说下我对这部分的理解。 </p>\n\n<p>   从领导层传达下来的理念看，将科技团队作为银行的一个子公司单独成立的好处在于，1. 面向整个金融市场，而不仅仅局限于一家银行，可以做科技输出。2. 体系独立于总行，摆脱总行僵化的员工体质，建立更有效的激励政策。3. 用科技公司来替代外包模式，增强自主权。不得不说，愿景很好。 </p>\n\n<p>   但是从旁观者来看，会提出很多问题： </p>\n\n<ul><li>    面向整个金融市场，科技公司如何与蚂蚁金服这样的互联网公司比输出的产品质量？银行成立子公司的核心竞争力在哪？      </li><li>    从表象上，不得不让员工理解为从总行被踢出去了，被强制划转到了一家互联网金融公司（更想不开的可能会觉得自己变成了一个外包人员）      </li><li>    这是不是一次变相的裁员，毕竟自负盈亏与大锅饭比起来，危机感更重，而很多老员工的竞争力并没有那么强。      </li><li>    划转之后待遇怎么定？级别怎么定？新的制度是什么？     </li></ul>\n\n<p>     我觉得如果一家公司可以将我上述的问题完美的回答给我，我觉得公司化也不一定是一个坏事情。  </p>\n\n<p>     目前像兴业、招商、建行、光大、民生都已经成立了自己的子公司，中信好像也有这个势头，但是模式也不完全一样，知乎上有很多关于银行成立科技公司的帖子，建议有兴趣的同学可以去了解了解。。  </p>\n\n<p>   关于成立子公司，大家立场不同、资历不同看事情的角度也不一样得到的结果肯定也都不一样。 </p>\n\n<p>   但是有一点是肯定的，不要觉得在银行就稳定了，就是个金饭碗，指不定哪天就公司化了。所以不管在哪都要提升自己的综合能力，提高自己的议价权。 </p>\n\n<h3>  领导们很重要 </h3>\n\n<p>   这里说的领导，可能是你的直接领导，可能是你的部门领导。你上层领导的风格严重影响你的发展，幸运的是我的领导都很注重技术，没有官场那一套东西，如果你遇到了一个很势力很看中关系背景的领导，那其实你怎么努力最终都不太好受，找工作是一个双向选择，你可以多去了解你未来的领导是个什么风格。举个简单的例子，评绩效的时候，有些领导属于大锅饭类型的，大家轮着来，今年你优秀，明年他优秀。有的领导属于交际型的，谁跟他关系好，谁今年就是优，谁拍马屁拍的好，就是谁优。有些领导就是务实型的，你做得好产生的价值大，那你就应该是优秀。好在我的领导属于最后一种，这也是我幸运的地方，希望各位同学也能如我一样幸运。 </p>\n\n<h3>  互联网 </h3>\n\n<p>   之前说了，我是向往互联网的，一直觉得互联网才是我应该从事的方向，我今年也尝试了跨出这一步，但是现在还没有下最终的决定，还是有些犹豫。 </p>\n\n<p>   说说我理解的互联网的优势吧： </p>\n\n<ul><li>    技术提升快：高负荷的压力，锻炼人是一定的，年轻身体不是问题；      </li><li>    跳槽涨幅大：一般2年一跳都会有20%-30%的涨幅，我见过double的；不过不建议频繁跳槽，现在很多HR比较关注这个。      </li><li>    敢于使用新技术，技术迭代快：这个也是相对银行来说的，也听说过一些老牌的互联网大厂技术栈也挺落后的；      </li><li>    薪资天花板高：我感觉如果是在阿里，连续拿4次3.75或者是4的话，现在应该可以到P7了，P7的待遇可就不是税后40w这么点了。反观银行的话，想年入百万，真的是太难了。     </li></ul>\n\n<p>   互联网的劣势： </p>\n\n<ul><li>    加班严重，996、大小周到处都是，很多人吐槽没有生活；      </li><li>    往往应届选择互联网的基本都是没有户口的，在很多个瞬间你会因为没有归属感体会到成年人的崩溃；      </li><li>    不稳定，互联网寒冬已经说了好几年了，裁员风波不时的就来一下；     </li></ul>\n\n<p>  4. 2016-2019的银行IT工作生涯  </p>\n\n<p>   楼主2016年硕士毕业，但是在银行的实习是从2015年的8月底开始的。 </p>\n\n<p>   <strong>实习期：</strong>  </p>\n\n<p>   2015年8月到2016年2月，没错，就是半年的实习期，而且我做到了基本全勤，因为公司离学校比较远，所以我选择了在公司附近租房子，平时就导师要汇报论文进度的时候和周末会回学校，其他时间全部在公司实习。包括2016年的那个寒假，也只在家呆了10天就回公司了，而那时候学校根本没开门，租的房子也到期了，在公司的加班宿舍住了2个月，然后又重新租的房子。要知道我们3月份毕业，2月份才给我们实习转正的offer，而那时候基本上所有人手里都已经没有offer了，因为基本上都到了deadline，大家都在赌，孤注一掷。很不幸有一部分人没有拿到offer，嗯，是因为不幸运，而不是不够努力，坚持到最后孤注一掷的人，大都跟我经历的差不多，只能说运气也是实力的一部分吧。 </p>\n\n<p>   说一下我实习期做了什么，也是比较巧吧，当我入职之后有一个新的项目需要做，领导想让我来做，我也是初生牛犊不怕虎，就接下来了。一个从0到1的系统，从了解业务、跟业务沟通需求、跟配合系统沟通实现、到系统搭建、技术选型、服务实现全部的工作都是我自己完成的，遇到不会的点可以跟leader讨论，但是为了不耽误太多leader时间，很多问题都自己想自己消化的，大概从实习的第二个月我就开始做这个项目，一直到我毕业答辩的那天，系统正式投产。我还记得我答辩完之后leader就叫我直接打车到公司运维那里准备系统上线，我连我的毕业答辩报告都是让同学帮我写的，投产的时候另外一个组的同事还夸我说还没转正就有自己负责的系统投产了，当时还是蛮有成就感的。后来leader告诉我，我拿着一个月2000多的实习工资，写了一个可能要评估出几十万开发费用的系统，真是为行里省了不少钱，性价比超高。 </p>\n\n<p>   2月份顺利拿到offer，5月份正式入职。 </p>\n\n<p>   <strong>试用期那年（5月入职后 -&gt; 2017年春节前）：</strong>  </p>\n\n<p>   入职之后，就是半年的试用期，期间工资只有80%，由于实习期已经有了一些开发的基础，leader又让我兼着做我们负责的一个系统的服务开发，第一年我写了很多代码，一方面是我实习期的系统A上线后很多业务发现有这么一个系统可以解决他们的需求，所以纷纷的来找我们来实现他们的需求，期间还有一个大领导特别重视的项目，我经常就是加班到10点在做。另一方面就是前面说的我们负责的一个重要系统B的服务开发。第一年其实就是在做加法，不停的接需求、写代码、投产。 </p>\n\n<p>   行里有个惯例，第一年的应届生进来一般都只能拿合格的绩效，我也不例外，但是leader私下跟我说我不应该拿这个的，但是实在没办法，跟我解释了半天，我也很理解。第一年就这样过去了，11月份顺利转正，拿了正常工资。 </p>\n\n<p>   <strong>第一个整年</strong><strong>（2017.1 - 2017.12）</strong><strong>：</strong>  </p>\n\n<p>   实习的时候做的系统A交付给另外一个团队了，因为业务冲突了，我们不太适合继续把这个业务做起来，于是按照领导要求把这个系统交给了对应的团队。 </p>\n\n<p>   我开始全面负责系统B的所有需求，这一年我接了20多个项目需求，因为时间的原因，我也由具体的开发人员，变成了项目管理，下面带着3个外包公司的小伙。 </p>\n\n<p>   这一年的年底参加了一个996的项目，3个月时间，顺利完成我们团队的相关交付。 </p>\n\n<p>    这一年如愿拿到了优秀，级别有微调，但是依然维持在原有的大级别档位上。  </p>\n\n<p>   这一年行里也对新人做了一些改革，更看重每个人的产出，所以收入明显增长，2017年大概税后28万左右。 </p>\n\n<p>   <strong>第二个整年</strong><strong>（2018.1 - 2018.12）</strong><strong>：</strong>  </p>\n\n<p>   这一年我们组立了一个重点的新项目C，一开始由leader牵头，我还有另外一个同事负责。我充其量算是第三顺位，但是后来leader忙于一些其他的事情，渐渐不管了。另外一个同事也因为一些特殊的原因暂时无法支持这个项目。于是这个项目就落到了我的手里，于是我带着2个合作公司的人，在10月份的时候把它推上线了。其实真正的开发是在5、6月份开始的，整理上完成了leader的预期，上线后也出现什么问题，然后开始大力推广。这算是我在18年的主要的KPI吧。但是系统B依然是我负责，还是会有很多需求提过来，也算比较忙吧。 </p>\n\n<p>   这一年依然拿了优秀，然后没有质的区别。2018年税后大概33万左右。 </p>\n\n<p>   <strong>第三个整年</strong><strong>（2019.1 - 2019.12）</strong><strong>：</strong>  </p>\n\n<p>    这一年因为前两年绩效较好，行里也给了一些出乎我意料的激励，简单来说相当于给了两个优秀的绩效，直接让我升到了上一个级别。所以薪资有了质的提升，2019年税后大概38万，因为是5月份调级的，前5个月的薪资还是按照上个级别发的，所以没有上面说的40w。  </p>\n\n<p>    这一年我开始带一个应届毕业生和两个实习生，体验了做导师的感觉，但我一直觉得自己并不是一个合格的导师，很多地方做的还不足；  </p>\n\n<p>    这一年我把B系统交给了应届毕业生，因为实在没有时间管这么多需求了，而且这个项目对我的成长也没多少了，应该交给新人来历练历练。  </p>\n\n<p>    这一年我们不断完善项目C，推广到了多个重要的项目系统，项目C也基本被大家所接受和认同。  </p>\n\n<p>    这一年我又参与了2个比较重要项目的规划和落地，压力很大，但是乐观前行。  </p>\n\n<p>   <strong>这部分大概就是写到这吧，稍微总结一下：</strong>  </p>\n\n<ul><li>    不要怕自己做不好，先把事情揽下来，然后按部就班的去实现它，你会发现这并没有那么难；      </li><li>    有表现的机会就要表现自己，比如leader让你去给大领导汇报，让你去独立承接一个项目；      </li><li>    一件事分配给你了，你做到了，那是应该的；你做好了，那是良好；你做的超出了我预期，那是优秀；其实这并不是很难；      </li><li>    不要抛问题的leader，要给leader解决方案让他选。我一直都是这么做的，但是现在带实习生就发现他们经常把问题抛给我，我就很不理解，明明可以自己想好解决方案的，为什么不做的更好，更进一步。而是觉得自己不行就直接把问题抛上来，不去思考。     </li></ul>\n\n<blockquote>     本来想写这两部分的，但是发现很多自己的想法上面都已经写到了，这块就不展开再说一遍了。  <br /><br /><br />     5. 银行转互联网难么？  <br />     今年年底把北京各个大厂都面的差不多了，有了一些自己的想法。  <br />     6. 朋友口中的互联网  <br />     虽然我不在互联网，但是我朋友多啊..  <br /></blockquote>\n\n<p>  7. 2019年年末的互联网走一圈  </p>\n\n<p>   嗯，今年年末因为种种原因，突然想试试自己几斤几两了，看看去互联网是个什么价。 </p>\n\n<p>   我面的基本上都是北京的几个大厂和1.5线互联网，一共面7家，收到了5家offer，PKG基本在 65w-70w之间（有2家没给到这个范畴）。 </p>\n\n<p>   我这边留了3家的面经，因为现在offer还在，所以不太想发出来面经，如果大家有兴趣，可以私信我，我发给大家。 </p>\n\n<p>   整体对互联网的感觉是 </p>\n\n<ul><li>    加班严重，10106，大小周，感觉时薪真的不如现在，甚至听说有的公司有比谁走的更晚的风气，实在无法结束；      </li><li>    经验之谈，一般社招的2面会是你未来的leader，在面试过程中多观察这个人，对，就像我前面说的，要跟对人。这个人对你之后的发展有很大的影响；      </li><li>    银行确实是会受到一点小偏见的，主要从定级和谈薪的时候可以看出来，但没有传言那么大（也可能是我是异类）；     </li></ul>\n\n<p>  8. 2020依然在抉择  </p>\n\n<p>   大家可能觉得3年这个薪资挺不错了，但是这个工资如果我没有什么特殊的机遇的话，可能未来4-5年都是这样的待遇。这也是为什么我选择在这个时间点去看互联网机会的一个原因。 </p>\n\n<p>   机会这个东西是不可预期的，抓住了可能2年就能完成，抓不住可能就要5年，我通常都是用最坏的来规划未来，所以仍然有很大的危机感。 </p>\n\n<p>   但是反过来看，我现在的情况，在我刚入职的时候，也是觉得是5-7年才完成的一个目标，现在不也3年完成了么。 </p>\n\n<p>   所以2020我依然处在互联网和银行的十字路口上，犹豫不决，大家也可以多分享下你们的想法，给我开拓开拓思维。 </p>\n\n<p>  END </p>\n\n<p>   嗯，就这么多吧，希望对大家有帮助。因为这些都是我根据我自己情况总结出来的，可能有些问题说不到，大家如果有想问的可以留言或者私信问我，至少最近这段时间我还是会常看的。</p>',8,4,0,1,0,0,1,'2020-05-07 20:16:44','2020-05-13 19:19:14'),(40,'京东前端hr面（三面）面经','  京东一面：https://www.nowcoder.com/discuss/420401 京东二面：https://www.nowcoder.com/discuss/421103 京东hr面：https://www.nowcoder.com/discuss/423204 贴主0429参与的京东前端实习二面，然后0430状态变更...','hr-side-three-sides-in-front-of-jingdong','<p> </p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>京东一面：<a href=\"https://www.nowcoder.com/discuss/420401\">https://www.nowcoder.com/discuss/420401</a></span></p>\n\n<p><span>京东二面：<a href=\"https://www.nowcoder.com/discuss/421103\">https://www.nowcoder.com/discuss/421103</a></span></p>\n\n<p><span>京东hr面：<a href=\"https://www.nowcoder.com/discuss/423204\">https://www.nowcoder.com/discuss/423204</a></span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>贴主0429参与的京东前端实习二面，然后0430状态变更为hr面试中，隔了个五一假期，0506收到的面试通知，约在了第二天上午电话面试。</span></p>\n\n<p><span>因为面完京东之后发生了一些麻烦事，耽误到现在才写面经，已经有点忘了问啥了，能记得多少写多少吧</span></p>\n\n<p><span>1.自我介绍</span></p>\n\n<p><span>2.你感觉前端和其他端有什么不同，说说你对前端的理解（这里可能是因为贴主的简历上有写到参与过其他端的开发才问的，然后顺便回答了自己为什么选择前端的问题）</span></p>\n\n<p><span>3.你说到有个项目参与了开题立项和一些管理安排的工作，来具体聊聊（我这个聊的稀烂，因为我当时处理的确实不好，所以基本就在聊自己的不足了）</span></p>\n\n<p><span>4.可实习的时间（我这里说了二到三个月，因为学校在北京，开学情况不明了，然后hr好像特别吃惊，交涉了之后才发现hr想要问的不只是暑期实习的时间，hr说他们的春季实习生主要目的是要留用的，也就是说你转正之后，研三能不能直接来干活的意思了。。我回答说如果可以转正的话还是会简单参与一下秋招，但是如果最终确认京东了，是可以研三一直实习的，不过这里hr好像不太满意我的回答，可能是觉得我如果转正了还要去秋招就不太好的样子）</span></p>\n\n<p><span>5.二面的面试官是否有和你说部门的业务内容（其实当时二面面试官在疯狂画饼，说什么急缺各种技术人才，和这个那个的国外知名it公司合作，做一些前沿探索工作，贡献自己的微薄力量。。可拉倒吧，所以我就回答了二面面试官没有具体的描述业务内容）</span></p>\n\n<p><span>6.你为什么会选京东（吹京东的环节到了，但我没吹好。。面试官有点不开心）</span></p>\n\n<p><span>7.方便的话可以透露下你的春招投递情况吗，你除了京东还投了哪些（基本如实回答了）</span></p>\n\n<p><span>8.那现在那些公司的流程状态如何（也基本如实回答了）</span></p>\n\n<p><span>9.那这么些个公司，你的意向情况是怎么样的（提到了最想去腾讯，但可能没机会了，然后京东的优先级比较高，我这里其实答的有点模棱两可。。面试官也有点不高兴）</span></p>\n\n<p><span>10.你希望能在实习收获什么，你感觉京东相比别的这些公司能给你带来什么（大概是这么个意思，我感觉又没吹好）</span></p>\n\n<p><span>11.那假如京东给你发offer了，你会怎么做抉择（这里如实回答已经确认了网易游戏的offer了，所以虽然很想去京东，但是因为流程先后问题，没法去了）</span></p>\n\n<p><span>12.答完这个问题面试官有点不开心的样子，然后就是反问环节了</span></p>\n\n<p><span>13.然后就挂电话了（感觉应该是凉了。。）</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>全程二三十分钟，感觉很多题都是送命题，我本来是想留个好印象来走流程的，一二面也发挥的挺好的，而且听说京东hc蛮多的，感觉挺有希望拿offer的，但这些吹京东的题我都没发挥好，我怕我吹的天花乱坠，表现的特别想来，到时候反手搞一个拒offer的操作就被秋招拉黑了，所以回答的都比较保守，也能感觉到面试官不太满意。个人面试的感觉就是京东对忠诚度和归属感这些都挺看重的，准备的话，最好就是多了解一下京东的业务，多赞赏一下京东，其实京东确实有很多点可以吹，大家可以挖掘挖掘，然后就是简单的准备一下京东与其他公司的对比这种问题（例如你为什么选京东来实习，不选美团之类的），还有就是最好抱着想转正，想给东哥拼命三十年的态度去答，感觉他们对留用转正的问题也看的挺重。我有点后悔参与这个hr面，因为hr面感觉就是来考察你的态度和意向的，我抱着不端正的态度来面试，反而会给hr留下一个坏印象的感觉。。</span></p>\n\n<p><span><br /></span><br /></p>\n\n<p><span>顺便给我另一个帖子打个广告(想水一个大橘已定，求大家多多点赞)：春招实习总结(附美团百度携程京东网易游戏360完美世界面经) ：<a href=\"https://www.nowcoder.com/discuss/421643\">https://www.nowcoder.com/discuss/421643</a></span></p>',10,2,0,1,0,0,1,'2020-05-07 20:19:46','2020-05-13 19:22:10'),(41,'已上岸，字节，奇安信等，回馈牛油的面经以及基础知识整理','      国际惯例，讲一下楼主的基本情况，教育部直属211本科毕业，非科班，专业偏硬件，秋招考研总分差点，饮恨考场。技术栈的话就会C/C++，matlab（毕设用的），linux系统，mysql数据库语句，项目就是一个在学校和同...','on-shore-byte-qianxin-etc-finishing-the-surface-economics-and-basic-knowledge-of-butter-feedback','<blockquote><p>      <span style=\"font-size:inherit;\">国际惯例，讲一下楼主的基本情况，教育部直属211本科毕业，非科班，专业偏硬件，秋招考研总分差点，饮恨考场。技术栈的话就会C/C++，matlab（毕设用的），linux系统，mysql数据库语句，项目就是一个在学校和同学做的课设（和科班比差太多），无实习，在国内外疫情这么严重的情况下还要进入互联网公司，综合考量之后决定从一名测试人员做起，从2月20日至今拿到了奇安信（软件测试工程师），字节（游戏测试工程师，base北京），三七玩估计也是能过得（游戏测试工程师），剩下的还没面试或者面试中的就不继续进行了，已经签字节跳动了（开森）</span></p></blockquote>\n\n<p>这个时候发面经已经有点晚了，所以现在打算让这篇面经主要面向即将秋招的童鞋，当然现在还在春招的童鞋也可以看哈，我和大家一起聊聊关于测试的二三事<span style=\"font-size:inherit;\"><br /></span></p>\n\n<p> </p>\n\n<p><strong>一、什么是测试工程师？</strong></p>\n\n<p>以软件开发为例，宏观上说测试工程师就是软件质量的把关者，在一个软件开发流程中测试人员要与开发人员一起对软件的研发进行负责，软件进行质量把关，开发进行功能实现，相辅相成。</p>\n\n<p>测试又分为传统的测试工程师和测试开发工程师，测试开发工程师（以下简称测开）就要在上述的基础上最少在掌握一门脚本语言，两门及以上更好，脚本语言包括但不局限于Python，golang，shell等等因为测试开发工程师其实是造轮子的，换言之就是开发测试用的各种工具；测试工程师对代码要求较测开低一些，但不是一窍不通（我面试的时候都会遇到代码问题），不懂代码层次的问题的话其实就不好进行测试分析这个后面再解释为什么。</p>\n\n<p><strong>二、测试工程师的工作是什么？</strong></p>\n\n<p>测试工程师简单点说就是找bug，然后反馈给开发人员，不要小看这个工作。</p>\n\n<p>首先很明显的bug开发人员有时候自己就能找到，测试人员要有比开发人员更加全面的想法才能找到深层次的问题点，</p>\n\n<p>其次，要端正一个态度就是测试人员不是一个电脑小白，相反国外顶级的测试开发工程师同时也是顶级的开发工程师甚至更厉害，所以作为一个测试工程师一定要有继续学习的精神和心态，然后明白测试工程师要会写测试用例，这很重要，文本写的好坏会直接影响到后期的维护成本。</p>\n\n<p>----------------------------分割线--------------------------------</p>\n\n<p>这段时间问自动化测试的童鞋比较多，那我就来聊聊我对自动化测试的理解（个人愚见）。</p>\n\n<p>首先说一下自动化测试是什么？自动化测试从职能上讲就是去在一定的框架下去开发一些自动化测试脚本来实现QA所做不到的事情，拿fgo来举栗子比较合适，众所周知fgo核心玩法之一就是抽卡，这个抽卡是有概率的（欧皇请自动左滑），而QA是不可能去抽几十万次甚至上百万次来验证概率问题，这时候就要自动化脚本来模拟抽卡去抽，看看概率算法是否有问题，本来自动化测试其实在某种意义上是一种灰盒测试，但是现在很多公司会把自动化测试归到测开里面去，所以现在自动化就偏白盒一些。</p>\n\n<p>第二个要说的就是语言，现在自动化测试流行的语言就是Python，shell，golang，（据说要是cpp厉害的也可以），不是很死板，但主流一定是脚本语言。</p>\n\n<p>就先讲这么多吧，也算是一个小总结。欢迎各位大佬对我提出意见或者交流经验，鞠躬。</p>\n\n<p>-------------------------------分割线--------------------------------</p>\n\n<p>游戏QA的话要求会更高，因为传统软件测试要看的方面游戏要测试，而传统软件不作为重点的地方游戏也要测试，所以游戏测试工程师相对来说是工作量会大一些。具体的测试流程的话可以自行百度或者Google，里面讲的比我要好很多。</p>\n\n<p><strong> 三、聊聊测试方法吧</strong></p>\n\n<p>测试有一种分类方式可以简单的分成黑盒测试和白盒测试，举个栗子，黑盒测试常见的测试方法有等价类划分方法、边界值分析方法、错误推测方法、因果图方法、判定表驱动分析方法、正交实验设计方法、功能图分析方法、场景设计方法等等，具体的话要看你所要测试的具体内容而定。</p>\n\n<p>白盒测试，先讲一下，白盒测试其实应该是测试开发工程师，要懂代码，要看的懂代码层次的逻辑和架构，然后去寻找代码层次出现的bug问题，方法具体有：</p>\n\n<p><strong>语句覆盖</strong>，主要特点：语句覆盖是最起码的结构覆盖要求，语句覆盖要求设计足够多的测试用例，使得程序中每条语句至少被执行一次。</p>\n\n<p><strong>判定覆盖</strong>，主要特点：判定覆盖又称为分支覆盖，它要求设计足够多的测试用例，使得程序中每个判定至少有一次为真值，有一次为假值，即：程序中的每个分支至少执行一次。每个判断的取真、取假至少执行一次。</p>\n\n<p><strong>条件覆盖</strong>，主要特点：条件覆盖要求设计足够多的测试用例，使得判定中的每个条件获得各种可能的结果，即每个条件至少有一次为真值，有一次为假值。</p>\n\n<p><strong>判定/条件覆盖</strong>，主要点：设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。</p>\n\n<p><strong>组合覆盖</strong>，主要特点：要求设计足够多的测试用例，使得每个判定中条件结果的所有可能组合至少出现一次。</p>\n\n<p><strong>路径覆盖</strong>，主要特点：设计足够的测试用例，覆盖程序中所有可能的路径。</p>\n\n<p>从方法上不难看出如果测试人员不懂代码会给工作带来一定的压力，也正好的解释了第一章里最后问题，具体的也希望大家去进行一下自学。</p>\n\n<p>当然我只是去罗列一下一些测试方法，百度也可得，我只是做了一下整理，真正变成自己的还需要去实践，当你自己去亲身测一段代码或者去测一测软件的某个功能，你就会去融会贯通。</p>\n\n<p><strong>四、说了这么多再聊聊面经吧（这里我只讲一下字节和奇安信的）</strong></p>\n\n<p><strong>字节跳动游戏测试工程师</strong></p>\n\n<p><strong> 一面（45min）、二面（30min）综合讲</strong></p>\n\n<p>1、自我介绍，项目介绍，然后让测一下项目里的内容；</p>\n\n<p>2、讲一讲自己的游戏史，因为我的简历里写了我有丰富的游戏史；</p>\n\n<p>3、从自己说的游戏中面试官挑了几个点进行测试；</p>\n\n<p>4、聊了聊fps游戏的中测试内容和外挂问题（ps：因为我谈了我对外挂很感兴趣）；</p>\n\n<p>5、聊了聊为什么要当测试以及游戏测试和测试人员的不同；</p>\n\n<p>6、讲了讲测试用例应该有什么，要注意什么；</p>\n\n<p>7、讲了讲一个单链表中查找第K个节点能用的方法，时间复杂度是多少；</p>\n\n<p>8、智力题：两个桶来取水的问题，重点看实现过程；</p>\n\n<p>9、聊了聊对测试职能的理解；</p>\n\n<p>10、反问环节；</p>\n\n<p>ps两面的面试官都超级温柔，有问题会耐心解答，体验极佳</p>\n\n<p><strong> 三面的话（35min）</strong></p>\n\n<p>比上述内容多了一些内容，就是聊了聊moba和fps具体的一些测试，然后出了道足球赛的赛制问题；再就多了和我聊了聊自己的性格和特点之类的。</p>\n\n<p>反问环节和面试官聊了蛮多的关于游戏方面的知识，面试官逻辑超强，讲的很棒，自己受益颇多。</p>\n\n<p><strong>hr面（15min）</strong></p>\n\n<p><strong> 就很正常的问了一些个人性格，经历等等，跟牛客网上大佬们的面经大同小异，不在赘述。</strong></p>\n\n<p><strong>奇安信测试工程师</strong></p>\n\n<p><strong> 一面（30min）</strong></p>\n\n<p>1、自我介绍，项目介绍；</p>\n\n<p>2、重点讲一下项目；</p>\n\n<p>3、对项目里的每一项功能进行测试，不断锤炼，不断反问（20min）</p>\n\n<p>4、反问；</p>\n\n<p><strong>二面（30min）</strong></p>\n\n<p> 1、自我介绍，项目介绍；</p>\n\n<p>2、再测一遍自己的项目（没错，就是再来一遍）；</p>\n\n<p>3、设计场景进行测试；</p>\n\n<p>4、问了问自己平时有没有学一些别的技术比如网页开发之类的，然后我又说外挂。。。。（10min）</p>\n\n<p>5、反问；</p>\n\n<p><strong>HR面（20min）</strong></p>\n\n<p><strong>就很正常的问了一些个人性格，经历等等，跟牛客网上大佬们的面经大同小异，不在赘述。</strong></p>\n\n<p><strong> 五、最后再写点碎碎念</strong></p>\n\n<p>个人对于工作和考研的态度就是：完全看个人发展，开发和测试对经验看中一些，算法等对学术要求高一点，具体还是看个人，不过有一点要声明，找工作趁早。</p>\n\n<p>招聘期间多注意公司的JD然后自行匹配，努力让自己更加贴合JD会增加简历通过概率，JD其实也是帮助我们自己看看自己还有那些知识要注意,要利用好。</p>\n\n<p>大三或者研二条件允许的情况下一定找实习，这会让你先看看行业内容，进而判断自己是不是适合这份工作。</p>\n\n<p><strong>欢迎想做测试的童鞋们和我探讨测试的问题，真心想聊的童鞋可以私信，但是晚上统一回复，要不然太忙了，大佬体谅下。（我在晚上查看我的消息记录，会逐一回复，别慌啊）</strong></p>\n\n<p>过一两个月我会开个CSDN的博客，记录自己开始学习自动化测试的知识的历程，会有干货分享，到时候我会在牛客网上做一个传送门，有兴趣的童鞋可以围观。</p>\n\n<p><strong>最后感谢牛油大佬的一路陪伴，鞠躬感谢，祝诸君前程似锦，一帆风顺！</strong></p>',7,2,0,3,0,0,1,'2020-05-07 21:22:27','2020-05-13 19:17:43'),(42,'CentOS7 环境配置指南',' CentOs7 环境配置指南 一、免密登录 1）ifconfig 查看本机 ip。 2）创建远程登录用户: adduser username: 创建用户passwd username: 修改密码 3）给该用户设置管理员权限：(可选) 打开 /etc/sudoers 文件，添加 use...','centos7-environment-configuration-guide','<p> <span style=\"color:rgb(0,0,0);font-size:24px;\">CentOs7 环境配置指南</span></p>\n\n<h2>一、免密登录</h2>\n\n<p>1）<code>ifconfig</code> 查看本机 ip。</p>\n\n<p>2）创建远程登录用户:</p>\n\n<ul><li><code>adduser username</code>: 创建用户</li><li><code>passwd username</code>: 修改密码</li></ul>\n\n<p>3）给该用户设置管理员权限：(可选)</p>\n\n<ul><li>打开 <span style=\"color:rgb(53,56,58);\">/etc/sudoers</span> 文件，添加 <code>username ALL=(ALL) ALL</code>。</li></ul>\n\n<p>4）将公钥拷贝到服务器：</p>\n\n<ul><li><code>ssh-keygen</code> 命令可生成密钥。如果本机已在其他服务器设置了免密登录，就无需重新生成，直接使用 <code>ssh-copy-id username@remote-server</code> 将原有公钥拷贝至需要免密登录的服务器即可。</li><li>本机的公钥路径可通过 <code>ssh-keygen</code> 命令查看</li></ul>\n\n<pre><code>$ ssh-keygen\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/Path/.ssh/id_rsa): <br /></code></pre>\n\n<ul><li>第三行的括号部分就是密钥路径，此时 <code>ctrl+C</code> 退出即可。</li><li><code>ssh username@remote-server</code> 测试免密登录，OJBK！</li></ul>\n\n<h2>二、防火墙配置</h2>\n\n<p>1）关闭 selinux。</p>\n\n<ul><li>打开 <span style=\"color:rgb(53,56,58);\">/etc/selinux/config</span> 文件，将 <code>SELINUX=enforcing</code> 改为 <code>SELINUX=disabled</code>。</li></ul>\n\n<p>2）配置 firewalld。</p>\n\n<ul><li>检查 firewalld 运行状态，开启常用的服务的监听端口，如 SSH、FTP。开启端口时加 <code>--permanent</code> 参数设置为永久生效。</li></ul>\n\n<h2>三、调教 Vim</h2>\n\n<p>1）vim 编辑器的配置文件:</p>\n\n<ul><li>Mac 位于：~/.vimrc</li><li>Centos7 位于：/etc/vimrc</li></ul>\n\n<p>2）常用配置:</p>\n\n<pre><code>set nu                      \nsyntax on\nset autoindent\nset tabstop=2\nset tags=/data/php/test_mysql/tags\nset nohlsearch    \nset ruler\nset history=1000\nset showmatch\nset cursorline\nfiletype plugin on\nautocmd FileType php set omnifunc=phpcomplete#CompletePHP\nset incsearch \"输入搜索内容时就显示搜索结果\nset matchtime=5  \" 匹配括号高亮的时间（单位是十分之一秒）\n\"colorscheme molokai\nset expandtab \"用空格代替tab <br /></code></pre>\n\n<h2>四、FTP 服务搭建（以 vsftpd 为例）</h2>\n\n<p><span style=\"color:rgb(99,107,111);\">1）检查是否已安装 ftp 工具。</span><br /></p>\n\n<pre><code>[binhua@centos-7 ~]$ vsftpd -v\nvsftpd: version 3.0.2<br /></code></pre>\n\n<p>2）如显示版本号则已安装，否则使用 <code>yum -y install vsftpd</code> 安装。</p>\n\n<p>3）为 ftp 服务创建专属用户。</p>\n\n<p>4）修改 ftp 配置。文件位置为 <span style=\"color:rgb(53,56,58);\">/etc/vsftpd/vsftpd.conf</span>.</p>\n\n<pre><code>anonymous_enable=NO    # 是否允许匿名访问\nlocal_enable=YES      # 是否允许使用本地帐户进行 FTP 用户登录验证\nchroot_local_user=YES   # 是否限定用户在其主目录下（NO 表示允许切换到上级目录）\n#chroot_list_enable=YES # 是否启用限制用户的名单（注释掉为禁用）\nchroot_list_file=/etc/vsftpd/chroot_list # 用户列表文件（一行一个用户）\nallow_writeable_chroot=YES # 如果启用了限定用户在其主目录下需要添加这个配置，解决报错 500 OOPS: vsftpd: refusing to run with writable root inside chroot()\nxferlog_enable=YES     # 启用上传和下载的日志功能，默认开启。<br /></code></pre>\n\n<h2>五、编译安装 Nginx1.17</h2>\n\n<p><span style=\"color:rgb(99,107,111);\">1）安装依赖包</span><br /></p>\n\n<pre><code>yum -y install pcre pcre-devel openssl openssl-devel gcc gcc-c++ autoconf automake zlib-devel libxml2 libxml2-dev libxslt-devel gd-devel perl-devel perl-ExtUtils-Embed GeoIP GeoIP-devel GeoIP-data make  GeoIP-devel GeoIP-update<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">2）下载 nginx 1.17 安装包。</span><br /></p>\n\n<pre><code>curl -o nginx-1.17.9.tar.gz http://nginx.org/download/nginx-1.17.9.tar.gz<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">3）创建用户和组。</span><br /></p>\n\n<pre><code>groupadd nginx\nuseradd nginx -g nginx -s /sbin/nologin -M\n<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">4）解压，配置，编译，安装。</span><br /></p>\n\n<pre><code>tar -zxvf nginx-1.17.9.tar.gz\ncd nginx-1.17.9\n\n./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_realip_module --with-http_geoip_module --with-http_stub_status_module --with-http_sub_module --with-stream --with-stream=dynamic\n\nmake &amp;&amp; make install<br /></code></pre>\n\n<p>5）添加环境变量。</p>\n\n<ul><li>Centos 的环境变量在 <span style=\"color:rgb(53,56,58);\">/etc/profile</span> 中设置。</li><li>Mac 的环境变量在 <span style=\"color:rgb(53,56,58);\">~/.bash_profile</span> 中设置。（引申）</li></ul>\n\n<p><span style=\"color:rgb(99,107,111);\">6）添加为系统服务。</span><br /></p>\n\n<pre><code>vim /usr/lib/systemd/system/nginx.service\n\n[Unit]\nDescription=nginx\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/local/nginx/sbin/nginx\nExecReload=/usr/local/nginx/sbin/nginx -s reload\nExecStop=/usr/local/nginx/sbin/nginx -s quit\nPrivateTmp=true\n\n[Install]\nWantedBy=multi-user.target<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">7）设置开机自启动。</span><br /></p>\n\n<pre><code>systemctl enable nginx.service<br /></code></pre>\n\n<h2>六、安装 php7.2</h2>\n\n<p><span style=\"color:rgb(99,107,111);\">1）安装 EPEL 包。（注：php 高版本的 yum 源地址，有两部分，其中一部分是 epel-release，另外一部分来自 webtatic。如果跳过 epel-release 直接安装 webtatic 的时候，会报错）</span><br /></p>\n\n<pre><code>yum install epel-release -y\n</code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">2）安装 webtatic-release。</span><br /></p>\n\n<pre><code>rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\"><span style=\"color:rgb(99,107,111);\">3）安装 php 豪华套餐包</span><br /></span></p>\n\n<pre><code>yum -y install php72w php72w-cli php72w-fpm php72w-common php72w-devel php72w-embedded php72w-gd php72w-mbstring php72w-mysqlnd php72w-opcache php72w-pdo php72w-xml<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\"><span style=\"color:rgb(99,107,111);\"><span style=\"color:rgb(99,107,111);\">4）设置开机自启动。</span><br /></span></span></p>\n\n<pre><code>systemctl enable php-fpm.service<br /></code></pre>\n\n<h2>七、安装 Mysql5.7</h2>\n\n<p><span style=\"color:rgb(99,107,111);\">从 CentOS 7 系统开始，MariaDB 成为 yum 源中默认的数据库安装包。在 CentOS 7 及以上的系统中使用 yum 安装 MySQL 包将无法使用 MySQL。您可以选择使用完全兼容的 MariaDB，或依照本文介绍配置来继续使用 MySQL。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">1）检查 MariaDB 是否安装，如果安装了就卸载全部。</span></p>\n\n<pre><code>yum list installed | grep mariadb   #检查是否安装\nyum -y remove mariadb*          #卸载<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">2）下载、安装、检查 MySQL 的 YUM 源。</span><br /></p>\n\n<pre><code>cd /data   #进入要下载的路径\nwget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\nrpm -ivh mysql57-community-release-el7-11.noarch.rpm   #安装\nyum repolist enabled | grep \"mysql.*-community.*\"     #检查是否成功<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">如果出现相关 mysql 的项则表示安装成功。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">3）安装 MySQL。</span></p>\n\n<pre><code>yum install mysql-community-server -y<br /></code></pre>\n\n<p><span style=\"color:rgb(99,107,111);\">4）设置 MySQL 开机自启动。</span><br /></p>\n\n<pre><code>systemctl enable mysqld.service<br /></code></pre>\n\n<h4>测试连接 Mysql 服务</h4>\n\n<p>刚安装的 MySQL 是没有密码的，这时如果出现：</p>\n\n<pre><code>ERROR 1045 (28000): Access denied for user \'root\'@\'localhost\' (using password: NO)<br /></code></pre>\n\n<p>解决方式如下：<br />a) 停止服务:  <code>systemctl stop mysqld</code><br />b) 以不检查权限的方式启动 MySQL:  <code>mysqld --user=root --skip-grant-tables &amp;</code><br />c) 再次输入 <code>mysql -u root</code> 或者 <code>mysql</code> 就可以进来了。<br />d) 更新密码:<br /></p>',5,1,0,1,0,0,1,'2020-05-07 21:34:48','2020-05-13 19:11:17'),(43,'Golang 学习——常量 const 和 iota','Golang 中常量 const 和 iota 学习 一.const 常量是一个简单值的标识符，在程序运行时，不会被修改的量。 Java 编程规范中，常量一般都是全大写字母，但是在 Golang 中，大小写是具有一定含义的，所以不一定所有常量...','golang-learning-const-and-iota','<h2>Golang 中常量 const 和 iota 学习</h2>\n\n<p>一.const</p>\n\n<p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>\n\n<p>Java 编程规范中，常量一般都是全大写字母，但是在 <span style=\"color:rgb(53,56,58);\">Golang</span> 中，大小写是具有一定含义的，所以不一定所有常量都得全大写</p>\n\n<p><span style=\"color:rgb(53,56,58);\">Golang</span> 中，大写字母开头表示 <code>public</code>, 小写字母开头表示 <code>private</code></p>\n\n<h2>1. 语法</h2>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span>  常量名  <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>数据类型<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span>  value </code></pre>\n\n<p>数据类型可以忽略不写，<span style=\"color:rgb(53,56,58);\">Golang</span> 编译器会自动推断出数据类型。</p>\n\n<p>在使用时，要注意以下几点：</p>\n\n<ol><li>数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型</li><li>满足多重赋值</li><li>常量只定义不使用，编译不会报错</li><li>常量可以作为枚举，常量组</li><li>常量组中如不指定类型和初始化值，则与上一行非空常量右值相同</li><li>显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值</li></ol>\n\n<h2>2. 实例</h2>\n\n<p>1. 定义单个常量</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> monday <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 显式类型定义</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> tuesday <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"2\"</span>  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 隐式类型定义</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> wednesday <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span>  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 不使用 编译不会报错</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"monday 的数据类型为：%T，值为：%d\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> monday<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> monday<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"tuesday 的数据类型为：%T，值为：%s\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> tuesday<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> tuesday<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出为:</p>\n\n<pre><code>monday 的数据类型为：<span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>，值为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span>\ntuesday 的数据类型为：<span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>，值为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span></code></pre>\n\n<p>2. 定义一组常量</p>\n\n<p><span style=\"color:rgb(53,56,58);\">Golang</span> 中没有枚举类型，不像 Java 或 Python 中有 <code>Enum</code> 类可以实现枚举，所以 <span style=\"color:rgb(53,56,58);\">Golang</span> 通过 <code>const</code> 来实现枚举</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> monday<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> tuesday<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> wednesday <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span>\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 更推荐以下定义方式</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>\n    one   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span>\n    two   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span>\n    three <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>一组常量中，如果某个常量没有初始值，默认和上一行一致</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>\n    one   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span>\n    two   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span>\n    three <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span>\n    four\n    five\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"four 的数据类型为：%T, 值为：%d\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> four<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> four<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"five 的数据类型为：%T, 值为：%d\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> five<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> five<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出为：</p>\n\n<pre><code>four 的数据类型为：<span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> 值为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span>\nfive 的数据类型为：<span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> 值为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span></code></pre>\n\n<p>写到这里，不知道有没有这样一个想法，如果我的常量很多，难道每一个常量都要一一赋值吗？</p>\n\n<p><span style=\"color:rgb(53,56,58);\">Golang</span> 中有一个关键字，可以解决这个问题，在定义枚举时，通常都会结合 <code>const</code> 来使用</p>\n\n<p>二.iota</p>\n\n<p>iota，特殊常量，可以认为是一个可以被编译器修改的常量</p>\n\n<h2>1. 知识点</h2>\n\n<p>在使用 <code>iota</code> 时，需要注意以下几点：<br />**1. 每当定义一个 const，iota 的初始值为 0</p>\n\n<ol><li>每当定义一个常量，就会自动累加 1**</li><li>直到下一个 const 出现，清零</li><li>如果中断 iota 自增，则必须显式恢复。且后续自增值按行序递增</li></ol>\n\n<p><span style=\"color:rgb(53,56,58);\">5. 自增默认是 int 类型，可以自行进行显示指定类型</span><br /><span style=\"color:rgb(53,56,58);\">6. iota 可以参与运算</span></p>\n\n<p>加粗的部分是需要重点关注的，现在实例演示一下</p>\n\n<h2>2. 实例</h2>\n\n<p>1. 定义 const 枚举，首项为 iota</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>\n    one   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">iota</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//iota初始值为0</span>\n    two   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">iota</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//自增1</span>\n    three <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">iota</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//再自增1</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"one 的值为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> one<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"two 的值为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> two<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"three 的值为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> three<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n</code></pre>\n\n<p>输出：</p>\n\n<pre><code>one 的值为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">0</span>\ntwo 的值为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span>\nthree 的值为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span></code></pre>\n\n<p>可以看到，每一项都自增了 1。 在定义时，不需要每次都写 <code>iota</code>，结合 <code>const</code> 的特性，<code>iota</code> 除了首项之外，后续常量不显示写 <code>iota</code>，都会自增</p>\n\n<p>2. 不显示写 <code>iota</code>，常量也会自增</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>\n    one   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">iota</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//iota初始值为0</span>\n    two        \n    three\n    four\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"one 的值为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> one<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"two 的值为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> two<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"three 的值为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> three<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"four 的值为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> four<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>one 的值为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">0</span>\ntwo 的值为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span>\nthree 的值为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span>\nfour 的值为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span></code></pre>\n\n<p>难道 <code>iota</code> 只能定义 0,1,2,3 吗？ 如果有别的值想用怎么办？</p>\n\n<p><span style=\"color:rgb(53,56,58);\">Golang</span> 中 <code>iota</code> 有一个非常非常好用的特性：<span style=\"color:rgb(53,56,58);\"><code>iota</code> 可以参与计算</span></p>\n\n<p>3.<code>iota</code> 参与计算</p>\n\n<p>比如，定义 b，kb，mb…. 等等</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>\n        b  <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&lt;&lt;</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token boolean\" style=\"color:rgb(0,224,224);\">iota</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">10</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// iota初始值为0 ，所以 1 &lt;&lt; (0 * 10)</span>\n        kb                    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 1 &lt;&lt; (1 * 10)</span>\n        mb                    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 1 &lt;&lt; (2 * 10)</span>\n        gb                    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 1 &lt;&lt; (3 * 10)</span>\n        tb                    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 1 &lt;&lt; (4 * 10)</span>\n        pb                    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 1 &lt;&lt; (5 * 10)</span>\n    <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>b<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> kb<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> mb<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> gb<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> tb<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> pb<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code><span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1024</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1048576</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1073741824</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1099511627776</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1125899906842624</span></code></pre>\n\n<p>是不是非常好用？ 虽然 <span style=\"color:rgb(53,56,58);\">Golang</span> 中没有枚举类，但是通过 <code>const</code> 和 <code>iota</code> 也可以方便的实现枚举</p>\n\n<p>三。结合 type，更能表现实际意义</p>\n\n<p>在实际开发中，枚举类通常都是有一定意义的，比如：月份，vip 等级……</p>\n\n<p>上面的例子中，只是简单的定义了数字常量，我们可以定义一个具体类型，来表示这些常量，实现一个有意义的枚举</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> VipLevel <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">const</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>\n    vipOne VipLevel <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">+</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">iota</span>\n    vipTwo  \n    vipThree \n    vipFour\n    vipFive\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>one<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> two<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> three<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> four<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> five<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code><span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">4</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">5</span></code></pre>\n\n<p>总结一下，<code>const</code> 和 <code>iota</code> 通常结合使用来定义枚举，为了使枚举更有意义，会自定义 <code>type</code> 类型。</p>\n\n<p>要多注意 <code>const</code> 和 <code>iota</code> 的特性，在使用的时候留心下，熟能生巧，勤练习，勤思考。</p>',5,1,0,1,0,0,1,'2020-05-07 21:39:18','2020-05-13 19:11:13'),(44,'Golang 学习——结构体 struct (一)','Golang 中结构体 struct 定义，结构体指针，空结构体和 nil 区别学习 Golang 中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。 结构体是由一系列具有相同类型或不同类型的数据构成...','golang-learning-struct-1','<h2>Golang 中结构体 struct 定义，结构体指针，空结构体和 nil 区别学习</h2>\n\n<p><span style=\"color:rgb(53,56,58);\">Golang</span> 中数组可以存储同一类型的数据，但在结构体中我们可以为不同项定义不同的数据类型。</p>\n\n<p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p>\n\n<p>类似 Java，Python 中的 class。</p>\n\n<p>一。结构体的定义和初始化</p>\n\n<h2>1. 语法</h2>\n\n<p>关键字 <code>struct</code> 表示创建一个结构体，语法如下</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> struct_variable_name <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n   member1 definition\n   member2 definition\n   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span>\n   member definition\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>我们定义一个 <span style=\"color:rgb(53,56,58);\">Person</span> 结构体，包含 name,age,hight 三个成员变量：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Person <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    age   <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n    hight <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>一旦定义了结构体类型，它就能用于变量的声明</p>\n\n<h2>2. 初始化</h2>\n\n<p>结构体初始化有多种方式，根据应用场景自由选择</p>\n\n<p>(1). 方式一，简短声明初始化：</p>\n\n<pre><code>bob <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Bob\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.85</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Bob 数据类型：%T,值为：%v\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出为:</p>\n\n<pre><code>Bob 数据类型：main<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>值为：<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Bob <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.85</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>这个结构体是在 <code>main</code> 方法中定义的，为了能够执行 <code>main</code> 方法，导入包的地方必须写为：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">package</span> main</code></pre>\n\n<p>所以，在输出 Bob 数据类型的时候，前面有个 <code>main</code>，<code>.</code> 点表示隶属于 main 包下的结构体。 之后输出的是 Bob 结构体的内容</p>\n\n<p>(2). 方式二，var 定义：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> alan Person\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"alan 结构体：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> alan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> \nalan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Alan\"</span>\nalan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span>\nalan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>hight <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.78</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Alan 结构体内容：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> alan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出为:</p>\n\n<pre><code>alan 结构体： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">0</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">0</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>   <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// {  0 0}  注意:第一个值是空字符串，控制台输出不明显，看不出来</span>\nAlan 结构体内容： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Alan <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.78</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>通过 <code>var</code> 声明结构体 (未初始化) alan，alan 是一个只有默认值的结构体，不是 nil。</p>\n\n<p>我们可以试验一下：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> jerry Person\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>jerry <span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">nil</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 这段代码编译会报错-&gt;无效操作：不匹配的类型Person和nil</span>\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 报错内容：invalid operation: jerry == nil (mismatched types Person and nil)</span></code></pre>\n\n<p>我们定义了一个名为 jerry 的结构体，并未进行初始化，在判断是否为 nill 时，代码报错了<br />首先要明白，<span style=\"color:rgb(53,56,58);\">Golang</span> 中 <code>nil</code> 表示什么，以下是我从源码中复制的：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// nil is a predeclared identifier representing the zero value for a</span>\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// pointer, channel, func, interface, map, or slice type.</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">nil</span> Type <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// Type must be a pointer, channel, func, interface, map, or slice type</span></code></pre>\n\n<p>可以看到， <code>nil</code> 的类型必须是一个指针，通道，函数，接口，字典，切片类型，他们都是引用类型</p>\n\n<p>而结构体 <code>struct</code> 是值类型，jerry 结构体未初始化，其成员变量的值都会取默认值，所以也可以理解为是有值，只不过是默认值。</p>\n\n<p>(3). 方式三：Person {}<br />结构体后面加 {}，表示声明结构体。</p>\n\n<pre><code>tom <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\ntom<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Tom\"</span>\ntom<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">21</span>\ntom<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>hight <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.73</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Tom 结构体内容：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> tom<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出为：</p>\n\n<pre><code>Tom 结构体内容： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Tom <span class=\"token number\" style=\"color:rgb(0,224,224);\">21</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.73</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>(4). 方式四：Person {} 变体<br />(3) 方式中是先创建一个结构体，然后初始化，分两步操作的。其实我们可以一步到位的：</p>\n\n<pre><code>jack <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>  <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Jack\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    age<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>   <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    hight<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.69</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Jack 结构体内容：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> jack<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>Jack 结构体内容： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Jack <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.69</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>二。结构体指针</p>\n\n<p>它是一个指针，指向了一个结构体</p>\n\n<h2>1. 结构体前面加’*’</h2>\n\n<p>在结构体前面加一个 <code>*</code> 即可</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> jerryPtr <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>Person  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义一个结构体指针，指针指向Person</span>\njerryPtr <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span>bob       <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 将bob的内存地址赋值给jerryPtr</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"jerryPtr 结构体指针为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> jerryPtr<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"jerryPtr 结构体指针地址为：%p,类型为：%T\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span>jerryPtr<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> jerryPtr<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>jerryPtr 结构体指针为： <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Bob <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.85</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\njerryPtr 结构体指针地址为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">0xc000006030</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>类型为：<span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>main<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Person</code></pre>\n\n<h2>2. 通过 <code>new()</code> 创建结构体</h2>\n\n<p>或者通过 <code>new()</code> 创建结构体，返回的也是一个指针</p>\n\n<pre><code>alan <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token function\" style=\"color:#FFD700;\">new</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"alan 为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> alan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 不是nill</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"alan 的地址为：%p,数据类型为；%T\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> alan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> alan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nalan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Alan\"</span>\nalan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span>\nalan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>hight <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1.79</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"alan 结构体的内容为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> alan<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>alan 为： <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">0</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nalan 的地址为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">0xc00006e540</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>数据类型为；<span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>main<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Person\nalan 结构体的内容为： <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Alan <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span> 男<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>观察输出，我们发现，alan 的数据类型 <code>*main.Person</code>，是一个指针。</p>\n\n<h2>3. 空结构体和 nil 区别</h2>\n\n<p>写到这里，在思考一个问题，那我定义一个没有任何成员变量的结构体，new 的时候，返回的是不是 <code>nil</code> 呢？</p>\n\n<p>查看了下 new () 函数返回的是指针类型，源码如下：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// The new built-in function allocates memory. The first argument is a type,</span>\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// not a value, and the value returned is a pointer to a newly</span>\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// allocated zero value of that type.</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">new</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>Type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>Type</code></pre>\n\n<p>带着疑问，实际操作一下。<br />我们先定义一个空结构体:</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Student <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>然后我们在 <code>main</code> 函数中声明一个空结构体，并判断是否为 <code>nill</code>：</p>\n\n<pre><code>student <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token function\" style=\"color:#FFD700;\">new</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>Student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"student 的数据类型为:%T,值为：%v\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"student == nill :\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student <span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">nil</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>student 的数据类型为<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>main<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>值为：<span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nstudent <span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span> nill <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">false</span></code></pre>\n\n<p>可以看到，空结构体 <code>student</code> 并不是 <code>nil</code>，而且其的值为 <span style=\"color:rgb(53,56,58);\">&amp;{}</span>。</p>\n\n<p>写到这里，返回上文看了下 <code>nil</code> 的源码，疑惑瞬间解开了：</p>\n\n<ul><li><p><code>stuct</code> 是一个值类型，即使加了 <code>*</code> 也只是变成了一个指针，指向结构体了。</p></li><li><p><code>nil</code> 是一个 <code>Type</code>，根据源码 <code>var nil Type</code>，它其实也是 <span style=\"color:rgb(53,56,58);\">Golang</span> 中的一中类型，nil 的类型必须是一个指针，通道，函数，接口，字典，切片类型</p></li></ul>\n\n<p>举个栗子，声明一个 <code>slice</code>，不做任何初始化，那么该 <code>slice</code> 就是一个 <code>nil</code></p>\n\n<p>Talk is cheap, show me code：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> s <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int64</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"s :\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"s == nil：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s <span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">nil</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>s <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span>\ns <span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">nil</span>： <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">true</span></code></pre>\n\n<p>可以看到，s 确实一个 <code>nil</code>，和我们思考的一样。</p>\n\n<p>总结一下，今天记录了 <code>struct</code> 的定义和声明方式，弄清楚了空结构体和 <code>nil</code> 的区别。</p>\n\n<p><code>nil</code> 在概念上和其它语言的 null、None、nil、NULL 一样，都指代零值或空值。<code>nil</code> 是预先说明的标识符，也即通常意义上的关键字。在 <span style=\"color:rgb(53,56,58);\">Golang</span> 中，<code>nil</code> 只能赋值给指针、<code>channel</code>、<code>func</code>、<code>interface</code>、<code>map</code> 或 <code>slice</code> 类型的变量</p>\n\n<p>另外，要注意的是，在 <span style=\"color:rgb(53,56,58);\">Golang</span> 中 <code>struct</code> 是值类型，结构体作为参数时，是副本拷贝。如果想引用传值，加个 <code>*</code> 即可。</p>',9,1,0,1,0,0,1,'2020-05-07 21:40:21','2020-05-13 19:21:13'),(45,'Golang 学习——结构体 struct (二)','Golang 中匿名结构体和匿名字段，结构体嵌套，模拟继承性学习 这篇文章也是结构体的学习，不过，如果没有结构体 struct 基础的话，推荐先看 Golang 学习 —— 结构体 struct (一)。 今天主要记录 匿名结构体和匿名字段...','golang-learning-structure-2','<h2>Golang 中匿名结构体和匿名字段，结构体嵌套，模拟继承性学习</h2>\n\n<p>这篇文章也是结构体的学习，不过，如果没有结构体 <code>struct</code> 基础的话，推荐先看 <a href=\"https://blog.csdn.net/m0_47404181/article/details/105873757\">Golang 学习 —— 结构体 struct (一)</a>。</p>\n\n<p>今天主要记录 <span style=\"color:rgb(53,56,58);\">匿名结构体和匿名字段，结构体嵌套，模拟继承性</span>。</p>\n\n<p>一。匿名结构体和匿名字段</p>\n\n<h2>1. 匿名结构体</h2>\n\n<p>匿名结构体：即没有名字的结构体，在创建匿名结构体时，同时初始化结构体。<br />实例：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 没有结构体命名过程， 直接创建一个结构体，并初始化</span>\ns2 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span> \n    name <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    age  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>初始化时必须的， 不然会编译报错。实例中，我未具体初始化，使用了默认值。通常，这个语法在实际开发中使用较少，作为了解即可</p>\n\n<h2>2. 匿名字段</h2>\n\n<p>匿名字段：一个结构体的字段没有字段名</p>\n\n<p>我们定义一个 <span style=\"color:rgb(53,56,58);\">Worker</span> 结构体，有两个匿名字段，：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Worker <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//匿名字段</span>\n    <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>    \n    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//string  再次定义一个 string 匿名字段时编译报错</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>匿名字段，<span style=\"color:rgb(53,56,58);\">默认使用数据类型作为名字</span>，那么匿名字段的类型就不能重复，否则会冲突。</p>\n\n<p>通过<code>.</code> 操作正常访问字段，如下：</p>\n\n<pre><code>bob <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Worker<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Bob\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">22</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Bob <span class=\"token number\" style=\"color:rgb(0,224,224);\">22</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nBob\n<span class=\"token number\" style=\"color:rgb(0,224,224);\">22</span></code></pre>\n\n<p>在实际开发中几乎没有人会这么写的，但是我们仍然有必要了解一下，为模拟继承性打好基础。</p>\n\n<p>二。结构体嵌套</p>\n\n<p>结构体嵌套：一个结构体可能包含一个字段，而这个字段反过来就是一个结构体，这种结构被称为嵌套结构。</p>\n\n<p>类似 Java 中的对象的包含关系 <code>has a</code></p>\n\n<h2>1. 实例</h2>\n\n<p>定义图书， 学生结构体。其中，学生结构体嵌套了图书结构体</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义 Book 结构体</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Book <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    bookName <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    price <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> \n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义 Student 结构体，其中一个字段是 Book 类型</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Student <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    age  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n    book Book  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 嵌套 Book 结构体 </span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>初始化结构体：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 声明初始化 book</span>\nbook1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    bookName<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>  <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"三国演义\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    price<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">56.5</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 声明初始化 sutdent</span>\nstudent1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Tom\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    age<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>  <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> book1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"student1 结构体内容：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"访问 book1 中的字段，书名:%s，价格：%.2f\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>bookName<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>price<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>student1 结构体内容： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Tom <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>三国演义 <span class=\"token number\" style=\"color:rgb(0,224,224);\">56.5</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n访问 book1 中的字段，书名<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>三国演义，价格：<span class=\"token number\" style=\"color:rgb(0,224,224);\">56.50</span></code></pre>\n\n<p>外部结构体对象 (student1) 访问内部结构体对象 (book1) 中的字段时，不能直接 <code>student1.bookName</code>，这是不允许的， 因为两个结构体之间的关系是包含关系，二者的字段是相互独立的。</p>\n\n<p>那如果就是想 <code>student1.bookName</code> 来获取图书名称呢？这就涉及的结构体的继承性了。</p>\n\n<p>三。结构体模拟继承性</p>\n\n<p>在学习了前两小节后，可以顺利的学习 <span style=\"color:rgb(53,56,58);\">Golang</span> 中的继承，因为前两小节是学习继承的知识铺垫。</p>\n\n<p>其实 <span style=\"color:rgb(53,56,58);\">Golang</span> 并不是纯粹的面向对象的编程语言，但也可以实现继承关系，类似：</p>\n\n<ul><li><p>Java 中的 <code>class_sub extend class_father</code></p><ul><li>Python 中的 <code>class_father(class_sub)</code></li></ul></li></ul>\n\n<p>是一种 <code>is a</code> 的关系。</p>\n\n<h2>1. 实例</h2>\n\n<p><span style=\"color:rgb(53,56,58);\">Golang</span> 中通过<span style=\"color:rgb(53,56,58);\">嵌套匿名结构体</span>来实现继承，具体是什么样的呢？我们实例操作一下：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">//1.定义父类</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Person <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    age  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">//2.定义子类</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Student <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    Person        <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//模拟继承结构</span>\n    school <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//子类的新增属性</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>以上代码就实现了继承， 其中 <code>Student</code> 结构体中嵌套了 <code>Person</code> 结构体，且 <code>Person</code> 必须作为匿名字段。</p>\n\n<p>实例操作如下：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">//1.创建父类的对象</span>\np1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"张三\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> age<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">30</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"父类对象：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> p1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">//2.创建子类的对象</span>\ns1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"李四\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">17</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"清华大学\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s1：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>父类对象 p1： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>张三 <span class=\"token number\" style=\"color:rgb(0,224,224);\">30</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n子类对象 s1： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>李四 <span class=\"token number\" style=\"color:rgb(0,224,224);\">17</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> 清华大学<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>刚刚在 （二）小节中，想通过 <code>student1.bookName</code> 来直接访问书名是不允许，但是在本节学习了继承关系后，我们可以实现此操作了。</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 子类对象间接访问父类属性</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"王五\"</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>school <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"清华大学\"</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s3：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 子类对象直接访问父类属性</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Ruby\"</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s3：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>子类对象 s3： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>王五 <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> 清华大学<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n子类对象 s3： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Ruby <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> 清华大学<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>一般地，在实现了继承后，开发习惯通常都是直接<span style=\"color:rgb(53,56,58);\">子类对象。字段名</span>来获取属性值。</p>\n\n<p>但是如果有多重继承的情况，那就得指定访问哪个父类的属性。否则父类之间字段名重复的话，会引起访问歧义，编译会报错。</p>\n\n<p>我们新增一个 <code>Teenager</code> 结构体，其中 <code>age</code> 字段和 <code>Person</code> 的 <code>age</code> 字段完成相同，然后 <code>Student</code> 也继承它：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 新增一个青少年结构体，只有年龄属性</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Teenager <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    age <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 学生结构体中多了一个 Teenager 匿名字段，模拟多重继承</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Student <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    Person\n    Teenager <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 新增了一个匿名字段，是Teenager结构体</span>\n    school <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p><code>Teenager</code> 和 <code>Person</code> 结构体有个相同的字段 <code>age</code>，访问时需要显示指定是访问哪个父类下的 <code>age</code>。否则会编译报错。</p>\n\n<p>我们还是使用之前的直接访问属性的方式：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 子类对象直接访问父类属性</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Ruby\"</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">16</span>  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 重名的字段会报错</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s3：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>我们试着输出下报错信息：</p>\n\n<pre><code># command<span class=\"token operator\" style=\"color:rgb(0,224,224);\">-</span>line<span class=\"token operator\" style=\"color:rgb(0,224,224);\">-</span>arguments\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>\\demo09_struct_extend<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">go</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">51</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">4</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> ambiguous selector s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age  </code></pre>\n\n<p><code>ambiguous selector s3.age</code> 表明 <code>s3.age</code> 有歧义，因为我们 <code>Person</code> 和 <code>Teenager</code> 有完全相同的字段。</p>\n\n<h2>2. 结构体嵌套 <code>is a</code> 和 <code>has a</code> 区别</h2>\n\n<p>总结一下：<br /><span style=\"color:rgb(53,56,58);\">Golang</span> 结构体嵌套，会衍生出两种关系：<br />1. 模拟继承性 - &gt; <code>is a</code>，如下：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> A <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    field\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> B <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    A  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 匿名字段</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>2. 模拟聚合性 - &gt; <code>has a</code>，如下：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> C <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    field\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> D <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    c C  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 聚合关系</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> </code></pre>\n\n<p>语法上的区别就是：嵌套的结构体<span style=\"color:rgb(53,56,58);\">是否匿名</span></p>\n\n<p>结构体的记录暂时记录到这里，如果后续有新的知识，会持续更新。</p>',9,1,0,2,0,0,1,'2020-05-07 21:41:00','2020-05-13 19:21:03'),(46,'Golang 学习——结构体 struct (二)','Golang 中匿名结构体和匿名字段，结构体嵌套，模拟继承性学习 这篇文章也是结构体的学习，不过，如果没有结构体 struct 基础的话，推荐先看 Golang 学习 —— 结构体 struct (一)。 今天主要记录 匿名结构体和匿名字段...','golang-learning-structure-2','<h2>Golang 中匿名结构体和匿名字段，结构体嵌套，模拟继承性学习</h2>\n\n<p>这篇文章也是结构体的学习，不过，如果没有结构体 <code>struct</code> 基础的话，推荐先看 <a href=\"https://blog.csdn.net/m0_47404181/article/details/105873757\">Golang 学习 —— 结构体 struct (一)</a>。</p>\n\n<p>今天主要记录 <span style=\"color:rgb(53,56,58);\">匿名结构体和匿名字段，结构体嵌套，模拟继承性</span>。</p>\n\n<p>一。匿名结构体和匿名字段</p>\n\n<h2>1. 匿名结构体</h2>\n\n<p>匿名结构体：即没有名字的结构体，在创建匿名结构体时，同时初始化结构体。<br />实例：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 没有结构体命名过程， 直接创建一个结构体，并初始化</span>\ns2 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span> \n    name <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    age  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>初始化时必须的， 不然会编译报错。实例中，我未具体初始化，使用了默认值。通常，这个语法在实际开发中使用较少，作为了解即可</p>\n\n<h2>2. 匿名字段</h2>\n\n<p>匿名字段：一个结构体的字段没有字段名</p>\n\n<p>我们定义一个 <span style=\"color:rgb(53,56,58);\">Worker</span> 结构体，有两个匿名字段，：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Worker <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//匿名字段</span>\n    <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>    \n    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//string  再次定义一个 string 匿名字段时编译报错</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>匿名字段，<span style=\"color:rgb(53,56,58);\">默认使用数据类型作为名字</span>，那么匿名字段的类型就不能重复，否则会冲突。</p>\n\n<p>通过<code>.</code> 操作正常访问字段，如下：</p>\n\n<pre><code>bob <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Worker<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Bob\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">22</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>bob<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Bob <span class=\"token number\" style=\"color:rgb(0,224,224);\">22</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nBob\n<span class=\"token number\" style=\"color:rgb(0,224,224);\">22</span></code></pre>\n\n<p>在实际开发中几乎没有人会这么写的，但是我们仍然有必要了解一下，为模拟继承性打好基础。</p>\n\n<p>二。结构体嵌套</p>\n\n<p>结构体嵌套：一个结构体可能包含一个字段，而这个字段反过来就是一个结构体，这种结构被称为嵌套结构。</p>\n\n<p>类似 Java 中的对象的包含关系 <code>has a</code></p>\n\n<h2>1. 实例</h2>\n\n<p>定义图书， 学生结构体。其中，学生结构体嵌套了图书结构体</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义 Book 结构体</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Book <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    bookName <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    price <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> \n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义 Student 结构体，其中一个字段是 Book 类型</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Student <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    age  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n    book Book  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 嵌套 Book 结构体 </span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>初始化结构体：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 声明初始化 book</span>\nbook1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    bookName<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>  <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"三国演义\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    price<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">56.5</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 声明初始化 sutdent</span>\nstudent1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Tom\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    age<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>  <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> book1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"student1 结构体内容：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"访问 book1 中的字段，书名:%s，价格：%.2f\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>bookName<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> student1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>book<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>price<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>student1 结构体内容： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Tom <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>三国演义 <span class=\"token number\" style=\"color:rgb(0,224,224);\">56.5</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n访问 book1 中的字段，书名<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>三国演义，价格：<span class=\"token number\" style=\"color:rgb(0,224,224);\">56.50</span></code></pre>\n\n<p>外部结构体对象 (student1) 访问内部结构体对象 (book1) 中的字段时，不能直接 <code>student1.bookName</code>，这是不允许的， 因为两个结构体之间的关系是包含关系，二者的字段是相互独立的。</p>\n\n<p>那如果就是想 <code>student1.bookName</code> 来获取图书名称呢？这就涉及的结构体的继承性了。</p>\n\n<p>三。结构体模拟继承性</p>\n\n<p>在学习了前两小节后，可以顺利的学习 <span style=\"color:rgb(53,56,58);\">Golang</span> 中的继承，因为前两小节是学习继承的知识铺垫。</p>\n\n<p>其实 <span style=\"color:rgb(53,56,58);\">Golang</span> 并不是纯粹的面向对象的编程语言，但也可以实现继承关系，类似：</p>\n\n<ul><li><p>Java 中的 <code>class_sub extend class_father</code></p><ul><li>Python 中的 <code>class_father(class_sub)</code></li></ul></li></ul>\n\n<p>是一种 <code>is a</code> 的关系。</p>\n\n<h2>1. 实例</h2>\n\n<p><span style=\"color:rgb(53,56,58);\">Golang</span> 中通过<span style=\"color:rgb(53,56,58);\">嵌套匿名结构体</span>来实现继承，具体是什么样的呢？我们实例操作一下：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">//1.定义父类</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Person <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    age  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">//2.定义子类</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Student <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    Person        <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//模拟继承结构</span>\n    school <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//子类的新增属性</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>以上代码就实现了继承， 其中 <code>Student</code> 结构体中嵌套了 <code>Person</code> 结构体，且 <code>Person</code> 必须作为匿名字段。</p>\n\n<p>实例操作如下：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">//1.创建父类的对象</span>\np1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"张三\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> age<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">30</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"父类对象：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> p1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">//2.创建子类的对象</span>\ns1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Student<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"李四\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">17</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"清华大学\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s1：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>父类对象 p1： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>张三 <span class=\"token number\" style=\"color:rgb(0,224,224);\">30</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n子类对象 s1： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>李四 <span class=\"token number\" style=\"color:rgb(0,224,224);\">17</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> 清华大学<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>刚刚在 （二）小节中，想通过 <code>student1.bookName</code> 来直接访问书名是不允许，但是在本节学习了继承关系后，我们可以实现此操作了。</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 子类对象间接访问父类属性</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"王五\"</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>school <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"清华大学\"</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s3：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 子类对象直接访问父类属性</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Ruby\"</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s3：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>子类对象 s3： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>王五 <span class=\"token number\" style=\"color:rgb(0,224,224);\">19</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> 清华大学<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n子类对象 s3： <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>Ruby <span class=\"token number\" style=\"color:rgb(0,224,224);\">20</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> 清华大学<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>一般地，在实现了继承后，开发习惯通常都是直接<span style=\"color:rgb(53,56,58);\">子类对象。字段名</span>来获取属性值。</p>\n\n<p>但是如果有多重继承的情况，那就得指定访问哪个父类的属性。否则父类之间字段名重复的话，会引起访问歧义，编译会报错。</p>\n\n<p>我们新增一个 <code>Teenager</code> 结构体，其中 <code>age</code> 字段和 <code>Person</code> 的 <code>age</code> 字段完成相同，然后 <code>Student</code> 也继承它：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 新增一个青少年结构体，只有年龄属性</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Teenager <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    age <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 学生结构体中多了一个 Teenager 匿名字段，模拟多重继承</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Student <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    Person\n    Teenager <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 新增了一个匿名字段，是Teenager结构体</span>\n    school <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p><code>Teenager</code> 和 <code>Person</code> 结构体有个相同的字段 <code>age</code>，访问时需要显示指定是访问哪个父类下的 <code>age</code>。否则会编译报错。</p>\n\n<p>我们还是使用之前的直接访问属性的方式：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 子类对象直接访问父类属性</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Ruby\"</span>\ns3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">16</span>  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 重名的字段会报错</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"子类对象 s3：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>我们试着输出下报错信息：</p>\n\n<pre><code># command<span class=\"token operator\" style=\"color:rgb(0,224,224);\">-</span>line<span class=\"token operator\" style=\"color:rgb(0,224,224);\">-</span>arguments\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>\\demo09_struct_extend<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">go</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">51</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">4</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> ambiguous selector s3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>age  </code></pre>\n\n<p><code>ambiguous selector s3.age</code> 表明 <code>s3.age</code> 有歧义，因为我们 <code>Person</code> 和 <code>Teenager</code> 有完全相同的字段。</p>\n\n<h2>2. 结构体嵌套 <code>is a</code> 和 <code>has a</code> 区别</h2>\n\n<p>总结一下：<br /><span style=\"color:rgb(53,56,58);\">Golang</span> 结构体嵌套，会衍生出两种关系：<br />1. 模拟继承性 - &gt; <code>is a</code>，如下：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> A <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    field\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> B <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    A  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 匿名字段</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>2. 模拟聚合性 - &gt; <code>has a</code>，如下：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> C <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    field\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> D <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    c C  <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 聚合关系</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> </code></pre>\n\n<p>语法上的区别就是：嵌套的结构体<span style=\"color:rgb(53,56,58);\">是否匿名</span></p>\n\n<p>结构体的记录暂时记录到这里，如果后续有新的知识，会持续更新。</p>',9,1,0,1,0,0,1,'2020-05-07 21:41:01','2020-05-13 19:20:48'),(47,'Golang 学习——interface 接口学习（一）','Golang 中接口定义及实现，空接口，接口嵌套学习 在 Golang 中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与 OOP(面向对象编程) 非常相似。接口指定了类型应该具有的方法，类...','golang-learning-interface-learning-1','<h2>Golang 中接口定义及实现，空接口，接口嵌套学习</h2>\n\n<p>在 <span style=\"color:rgb(53,56,58);\">Golang</span> 中，接口是一组方法签名。当类型为接口中的所有方法提供定义时，它被称为实现接口。它与 <code>OOP(面向对象编程)</code> 非常相似。接口指定了类型应该具有的方法，类型决定了如何实现这些方法。</p>\n\n<p>如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。</p>\n\n<p>一。接口定义及实现</p>\n\n<h2>1. 定义接口</h2>\n\n<p>关键字 <code>interface</code> 用来定义接口，语法如下：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> interface_name <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n   <span class=\"token function\" style=\"color:#FFD700;\">method_name1</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>args <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span>arg_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>return_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span>\n   <span class=\"token function\" style=\"color:#FFD700;\">method_name2</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>args <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span>arg_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>return_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span>\n   <span class=\"token function\" style=\"color:#FFD700;\">method_name3</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>args <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span>arg_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>return_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span>\n   <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span>\n   <span class=\"token function\" style=\"color:#FFD700;\">method_namen</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>args <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span>arg_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>return_type<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>一个接口中可以定义多个方法，根据逻辑需要，自定义参数和返回值。</p>\n\n<h2>2. 实现接口</h2>\n\n<p>一个结构体实现了某个接口的所有方法，则此结构体就实现了该接口。</p>\n\n<p>我们定义一个 <code>Phone</code> 接口，包含两个方法 <code>call()</code> 和 <code>sendMessage()</code></p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Phone <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token function\" style=\"color:#FFD700;\">call</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token function\" style=\"color:#FFD700;\">seenMessage</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>声明结构体，用来实现接口：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Huawei <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    price <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Xiaomi <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name  <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span>\n    price <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>声明了 <code>Huawei</code> 和 <code>Xiaomi</code> 两个结构体，各包含 <code>name</code> 和 <code>price</code> 两个字段。</p>\n\n<p>接下来，实现 <code>Phone</code> 接口，我们先让 <code>Huawei</code> 结构体实现该接口所有方法：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>huawei Huawei<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">call</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"%s 有打电话功能.....\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> huawei<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>huawei Huawei<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">seenMessage</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"%s 有发短信功能.....\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> huawei<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>初始化 <code>Huawei</code> 结构体，测试接口的方法：</p>\n\n<pre><code>mate30 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Huawei<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>  <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Mate 30\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    price<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">6999</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nmate30<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">call</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nmate30<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">seenMessage</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>Mate <span class=\"token number\" style=\"color:rgb(0,224,224);\">30</span> 有打电话功能<span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>\nMate <span class=\"token number\" style=\"color:rgb(0,224,224);\">30</span> 有发短信功能<span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span></code></pre>\n\n<p><code>Huawei</code> 结构体实现了 <code>Phone</code> 接口的所有方法，那就认为，则 <code>Huawei</code> 结构体实现了 <code>Phone</code> 接口。</p>\n\n<p>那如何判断是否实现了该接口，可参考：<br /><a href=\"https://blog.csdn.net/m0_47404181/article/details/105882261\">Golang 学习 —— 如何判断 Golang 接口是否实现？</a></p>\n\n<p>我们具体也操作下，看看 <code>Xiaomi</code> 结构体若没有实现 <code>Phone</code> 接口会发生什么？</p>\n\n<p>实现 <code>Phone</code> 接口一个方法：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>xiaomi Xiaomi<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">seenMessage</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"%s 只有发短信功能.....\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> xiaomi<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p><code>Xiaomi</code> 只实现了 <code>Phone</code> 的 发短信方法，所以认为 <code>Xiaomi</code> 类型未实现了 <code>Phone</code> 接口。我们具体验证下：</p>\n\n<p>首先初始化 <code>Xiaomi</code> 结构体，并测试方法</p>\n\n<pre><code>xiaomi9 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Xiaomi<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>  <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"Xiao 9\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    price<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">4999</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nxiaomi9<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">seenMessage</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>Xiao <span class=\"token number\" style=\"color:rgb(0,224,224);\">9</span> 只有发短信功能<span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span></code></pre>\n\n<p><code>seenMessage()</code> 方法测试没问题，我们使用 <code>new()</code> 函数来测试下 <code>Xiaomi</code> 结构体是否实现了 <code>Phone</code> 接口：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">_</span> Phone <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token function\" style=\"color:#FFD700;\">new</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>Xiaomi<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>下图是我从自己的 IDE（Goland）截的图，为了方便记录，我将上下文的代码专门换行隔开了。</p>\n\n<p><img src=\"https://cdn.learnku.com/uploads/images/202005/05/62299/CMXP4vnhQB.png!large\" alt=\"在这里插入图片描述\" /></p>\n\n<p>从图中可以看到，<code>new</code> 下方有红线，鼠标浮上去会显示错误信息，大意就是：<code>Xiaomi</code> 未实现 <code>Phone</code> 接口的某些方法，如：<code>call()</code>，因此不能将 <code>Xiaomi</code> 用作电话类型。</p>\n\n<p>二。空接口</p>\n\n<p>空接口 <code>interface{}</code>：<br />不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值。</p>\n\n<p><code>fmt</code> 包下的 <code>Print</code> 系列函数，其参数大多是空接口类型，也可以说支持任意类型：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">Print</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>a <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>n <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> err <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">error</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>format <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> a <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>n <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> err <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">error</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>a <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>n <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> err <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">error</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<h2>1. 实例</h2>\n\n<p>我们定义一个空接口练习下：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义一个空接口</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Empyt_interface <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义一个入参为任意类型的函数</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">getInfo</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>arg Empyt_interface<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"getInfo 函数.....\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> arg<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 也可以写成如下形式，更推荐</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">getInfo2</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>arg <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"getInfo2 函数.....\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> arg<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p><code>Golang</code> 很多库的源代码都会以空接口作为参数，表示接受任意类型的参数</p>\n\n<p>我们自己也实战一下：</p>\n\n<p>定义一个值为任意类型的 <code>map</code></p>\n\n<pre><code>map1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token function\" style=\"color:#FFD700;\">make</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">map</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">string</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nmap1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"数字\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span>\nmap1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"字符串\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\"字符串\"</span>\nmap1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"布尔\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">false</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"map1 ...........\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> map1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>map1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">map</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span>字符串<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>字符串 布尔<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span><span class=\"token boolean\" style=\"color:rgb(0,224,224);\">false</span> 数字<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span></code></pre>\n\n<p>三。接口嵌套</p>\n\n<p>顾名思义，接口嵌套就是一个接口中包含了其他接口，如果要实现外部接口，那么就要把内部嵌套的接口对应的所有方法全实现了。</p>\n\n<h2>1. 实例</h2>\n\n<p>我们定义 3 个接口，其中有一个接口嵌套了另外两个：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义3个接口</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> A <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token function\" style=\"color:#FFD700;\">test1</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> B <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token function\" style=\"color:#FFD700;\">test2</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义嵌套接口</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> C <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    A\n    B\n    <span class=\"token function\" style=\"color:#FFD700;\">test3</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>接着我们在定义一个结构体，并实现所有方法：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Person <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token comment\" style=\"color:rgb(138,148,150);\">//如果想实现接口C，那不止要实现接口C的方法，还要实现接口A，B中的方法</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>p Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">test1</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"test1 方法................\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>p Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">test2</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"test2 方法................\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>p Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">test3</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"test3 方法................\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>初始化结构体，并测试方法：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> person Person <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> Person<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 实现 C 接口的所有方法</span>\nperson<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">test1</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nperson<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">test2</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nperson<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">test3</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code>test1 方法<span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>\ntest2 方法<span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>\ntest3 方法<span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">...</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span></code></pre>\n\n<p>以上就是 <span style=\"color:rgb(53,56,58);\">Golang</span> 接口的基础学习，总结了接口的定义及实现，空接口和嵌套接口的概念和使用。</p>',4,1,0,1,0,0,1,'2020-05-07 21:41:41','2020-05-13 19:10:22'),(48,'Golang 学习——interface 接口学习（二）','Golang 接口断言学习 在 Golang 中，空接口 interface{} 没有定义任何函数，因此 Golang 中所有类型都实现了空接口。当一个函数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。 一...','golang-learning-interface-learning-2','<h2>Golang 接口断言学习</h2>\n\n<p>在 <span style=\"color:rgb(53,56,58);\">Golang</span> 中，空接口 <code>interface{}</code> 没有定义任何函数，因此 <span style=\"color:rgb(53,56,58);\">Golang</span> 中所有类型都实现了空接口。当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p>\n\n<p>一。类型断言</p>\n\n<p>在学习接口断言之前，先了解一下类型断言，其实接口断言也是在判断类型。</p>\n\n<p><span style=\"color:rgb(53,56,58);\">类型断言</span>，通过它可以做到以下几件事情：</p>\n\n<ol><li>检查 i 是否为 <code>nil</code></li><li>检查 i 存储的值是否为<code>某个类型</code></li></ol>\n\n<p>通常有两种方式：<br />第一种：</p>\n\n<pre><code>t <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> i<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>T<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>这个表达式可以断言一个接口对象 <code>i</code> 里不是 <code>nil</code>，并且接口对象 <code>i</code> 存储的值的类型是 <code>T</code>，如果断言成功，就会返回值给 <code>t</code>，如果断言失败，就会触发 <code>panic</code>。</p>\n\n<p><code>t := i.(T)</code> 常用于 <code>switch</code> 结构。</p>\n\n<p>第二种：</p>\n\n<pre><code>t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ok<span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> i<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>T<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>这个表达式也是可以断言一个接口对象 <code>t</code> 里不是 <code>nil</code>，并且接口对象 <code>t</code> 存储的值的类型是 <code>T</code>;</p>\n\n<p>如果断言成功，就会返回其类型给 <code>t</code>，并且此时 <code>ok</code> 的值 为 <code>true</code>，表示断言成功。</p>\n\n<p>如果接口值的类型，并不是我们所断言的 <code>T</code>，就会断言失败，但和第一种表达式不同的事，这个不会触发 <code>panic</code>，而是将 ok 的值设为 <code>false</code> ，表示断言失败，此时 <code>t</code> 为 <code>T</code> 的零值。</p>\n\n<p><code>t, ok:= i.(T)</code> 常用于 <code>if else</code> 结构。</p>\n\n<p>二。接口断言</p>\n\n<h2>1.if else 结构 接口断言</h2>\n\n<p><code>t, ok := i.(T)</code> 断言在上一小节已经介绍过了，本小节，我们通过实战加深下理解。</p>\n\n<p>我们先创建一个 <code>Shape</code> 形状接口，两个结构体。</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义接口</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Shape <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token function\" style=\"color:#FFD700;\">perimeter</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 返回形状的周长</span>\n    <span class=\"token function\" style=\"color:#FFD700;\">area</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>      <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 返回形状的面积</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义结构体</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Circle <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    radius <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Triangle <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">struct</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    a<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> b<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> c <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>其中，<code>Shape</code> 接口有两个方法，分别是求形状的周长和面积。</p>\n\n<p>两个结构体分别定义了自己独有的属性：</p>\n\n<ul><li><code>Circle</code>(圆)，定义了半径</li><li><code>Triangle</code>(三角形)，定义了三条边</li></ul>\n\n<p>接下来，我们实现 <code>Shape</code> 接口中的方法：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 圆结构体 实现接口方法</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>c Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">perimeter</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">return</span> c<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>radius <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> math<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Pi <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>c Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">area</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">return</span> math<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Pow</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>c<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>radius<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> math<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Pi\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 三角形结构体 实现接口方法</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>t Triangle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">perimeter</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">return</span> t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>a <span class=\"token operator\" style=\"color:rgb(0,224,224);\">+</span> t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>b <span class=\"token operator\" style=\"color:rgb(0,224,224);\">+</span> t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>c\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>t Triangle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token function\" style=\"color:#FFD700;\">area</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token builtin\" style=\"color:rgb(171,227,56);\">float64</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    p <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">perimeter</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">/</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">2</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">return</span> math<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Sqrt</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>p <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>p <span class=\"token operator\" style=\"color:rgb(0,224,224);\">-</span> t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>a<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>p <span class=\"token operator\" style=\"color:rgb(0,224,224);\">-</span> t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>b<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>p <span class=\"token operator\" style=\"color:rgb(0,224,224);\">-</span> t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>c<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>其中三角形的面积计算使用了 <a href=\"https://baike.baidu.com/item/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F\">海伦公式</a></p>\n\n<p>接下来我们封装一个接口断言函数：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义接口断言函数</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">getInterfaceType</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>s Shape<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">if</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ok <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> s<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>Triangle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span> ok <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"是三角形，三边分别为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>a<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>b<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>c<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">else</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">if</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ok <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> s<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span> ok <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"是圆形，半径为；\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>radius<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">else</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">if</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ok <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> s<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span> ok <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"是圆形结构体指针，类型为：%T,存储的地址为：%p，指针自身的地址为：%p\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span>ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">else</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"无法判断类型...\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>该函数中不仅判断了值传递的类型，也判断了引用传递（指针类型）的类型。因为 <code>Struct</code> 是值类型，所以我们加入引用类型，使练习更严谨一点。</p>\n\n<p>接下来开始初始化结构体：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 初始化一个圆结构体</span>\nc1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>radius<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">10</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"==================圆结构体：==================\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"圆的周长为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> c1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">perimeter</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"圆的面积为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> c1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">area</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 初始化一个三角形结构体</span>\nt1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> Triangle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    a<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    b<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">4</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n    c<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">5</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"================三角形结构体：=================\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"三角形的周长为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> t1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">perimeter</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"三角形的面积为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> t1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">area</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n\n<span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 初始化一个圆形结构体指针</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> c2 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>Circle <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span>Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>radius<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">5</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"================圆形结构体指针：===============\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"圆的周长为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> c2<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">perimeter</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\nfmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"圆的面积为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> c2<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">area</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>圆结构体：<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>\n圆的周长为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">62.83185307179586</span>\n圆的面积为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">314.1592653589793</span>\n<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>三角形结构体：<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span>\n三角形的周长为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">12</span>\n三角形的面积为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">6</span>\n<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>圆形结构体指针：<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span>\n圆的周长为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">31.41592653589793</span>\n圆的面积为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">78.53981633974483</span></code></pre>\n\n<p>可以看到，以上结构体都实现了 <code>Shape</code> 接口， 接下来开始进行接口断言：</p>\n\n<pre><code>fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"==============t, ok:= i.(T) 开始接口断言====================\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token function\" style=\"color:#FFD700;\">getInterfaceType</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>c1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 判断该接口是否为 圆形结构体类型</span>\n<span class=\"token function\" style=\"color:#FFD700;\">getInterfaceType</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>t1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 判断该接口是否为 圆形结构体类型</span>\n<span class=\"token function\" style=\"color:#FFD700;\">getInterfaceType</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>c2<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 判断该接口是否为 圆形结构体指针类型</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>t<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ok<span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> i<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>T<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> 开始接口断言<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span>\n是圆形，半径为； <span class=\"token number\" style=\"color:rgb(0,224,224);\">10</span>\n是三角形，三边分别为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">4</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">5</span>\n是圆形结构体指针，类型为：<span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>main<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>存储的地址为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">0xc000006030</span>，指针自身的地\n址为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">0xc0000140e0</span></code></pre>\n\n<p>可以看到，我们的接口断言奏效了，并且输出了对应逻辑的结果。</p>\n\n<h2>2.switch 结构 接口断言</h2>\n\n<p>断言其实还有另一种形式，就是用在利用 <code>switch</code> 语句判断接口的类型。</p>\n\n<p>每一个 <code>case</code> 会被顺序地考虑。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句。</p>\n\n<p>因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p>\n\n<p>我们再封装一个 <code>switch</code> 逻辑的接口断言函数，逻辑和之前的一模一样，只是条件语句换成了 <code>switch....case</code>：</p>\n\n<pre><code><span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 定义接口断言函数,使用 switch</span>\n<span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">getInterfaceTypeSwitch</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>s Shape<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">switch</span> ins <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> s<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 首字母小写的 type</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">case</span> Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"是圆形，半径为；\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>radius<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">case</span> Triangle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"是三角形，三边分别为：\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>a<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>b<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>c<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">case</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Printf</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"是圆形结构体指针，类型为：%T,存储的地址为：%p，指针自身的地址为：%p\\n\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span>ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span> ins<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">default</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">:</span>\n        fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"无法判断类型...\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>接下来测试封装的函数：</p>\n\n<pre><code>fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token string\" style=\"color:rgb(171,227,56);\">\"==============t := i.(type) 开始接口断言====================\"</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token function\" style=\"color:#FFD700;\">getInterfaceTypeSwitch</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>c1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 判断该接口是否为 圆形结构体类型</span>\n<span class=\"token function\" style=\"color:#FFD700;\">getInterfaceTypeSwitch</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>t1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 判断该接口是否为 圆形结构体类型</span>\n<span class=\"token function\" style=\"color:#FFD700;\">getInterfaceTypeSwitch</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>c2<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// 判断该接口是否为 圆形结构体指针类型</span></code></pre>\n\n<p>输出：</p>\n\n<pre><code><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>t <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> i<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> 开始接口断言<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>\n是圆形，半径为； <span class=\"token number\" style=\"color:rgb(0,224,224);\">10</span>\n是三角形，三边分别为： <span class=\"token number\" style=\"color:rgb(0,224,224);\">3</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">4</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">5</span>\n是圆形结构体指针，类型为：<span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>main<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span>Circle<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>存储的地址为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">0xc000006038</span>，指针自身的地\n址为：<span class=\"token number\" style=\"color:rgb(0,224,224);\">0xc0000140e0</span></code></pre>\n\n<p>可以看到，<code>switch</code> 断言的逻辑也正常输出了。</p>\n\n<p>总结一下，今天主要记录了接口如何断言的，通常有两种方式：</p>\n\n<ol><li>方式一：<code>t, ok:= i.(T)</code></li></ol>\n\n<ul><li>断言成功，就会返回其类型给 <code>t</code>，并且此时 <code>ok</code> 的值 为 <code>true</code>，表示断言成功</li><li>断言失败，<code>ok</code> 为 <code>false</code>，<code>t</code> 为 <code>T</code> 的零值</li><li>通常用于 <code>if else</code> 结构</li></ul>\n\n<ol><li>方式二：<code>t := i.(T)</code></li></ol>\n\n<ul><li>断言一个接口对象 <code>i</code> 里不是 <code>nil</code>，并且接口对象 <code>i</code> 存储的值的类型是 <code>T</code></li><li>如果断言成功，就会返回值给 <code>t</code>，如果断言失败，就会触发 <code>panic</code></li><li>通常用于 <code>switch</code> 结构</li></ul>',4,1,0,1,0,0,1,'2020-05-07 21:42:21','2020-05-13 19:10:07'),(49,'Golang 学习——如何判断 Golang 接口是否实现？','前言 在看一个底层库的的时候，看到了一个比较奇怪的写法，于是乎有了本文。 主要探讨两个问题： 1. 利用编译来判断 Golang 接口是否实现2. 延伸出的 make 和 new 的区别 正文 1. 利用 new () 来判断 Golang 接口是...','golang-learning-how-to-determine-whether-the-golang-interface-is-implemented','<p>前言</p>\n\n<p>在看一个底层库的的时候，看到了一个比较奇怪的写法，于是乎有了本文。</p>\n\n<p>主要探讨两个问题：</p>\n\n<p>1. 利用编译来判断 Golang 接口是否实现<br />2. 延伸出的 make 和 new 的区别</p>\n\n<p>正文</p>\n\n<h2>1. 利用 new () 来判断 Golang 接口是否实现</h2>\n\n<p>看了一个底层通用链接池的库，有这么一行代码：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">_</span> Pooler <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token function\" style=\"color:#FFD700;\">new</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>WeightedRoundRobin<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>需要解释的是：Pooler 是一个接口类型。</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">type</span> Pooler <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">interface</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n       <span class=\"token comment\" style=\"color:rgb(138,148,150);\">// ...</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>刚开始看是疑惑的，为什么 new 了之后是要抛弃调？</p>\n\n<p>后面发现这个是为了验证某某接口是否被实现了？</p>\n\n<p>多看了一些代码后发现很多地方有类似这样的写法。</p>\n\n<p>至此 Get 到了。</p>\n\n<blockquote><p>解释：如果说次接口没有被实现，那么一方面 ide 会有红横线出现，另一方面在编译的时候会出现报错。两方面的提示来保证写底层代码的接口是有被实现的。</p></blockquote>\n\n<h2>2. 延伸出的 make 和 new 的区别</h2>\n\n<p>和小伙伴讨论期间，跑出了这么一个问题：“<span style=\"color:rgb(53,56,58);\">可以使用 go test 的方式，去_test.go 文件中定义一个接口，来判断就好了。上文判断会存在浪费内存的情况</span>”</p>\n\n<p>这边两个点：<br />1.go test 的方式肯定是可行的。<br />但是并没法保证程序员会真的记住去执行进行检测（非强制必须走的流程）。但是直接通过前文方式，是会在编译的时候抛错的，这个是必须走的流程，所以更推荐前文的方式。</p>\n\n<p>2.new 占内存？<br />new：申请了内存，但是不会将内存初始化，只会将内存置零，返回一个指针。</p>\n\n<p>make：申请了内存，返回已初始化的结构体的零值。<br /></p>\n\n<p><br /></p>\n\n<p>回到正文，虽然申请了内存，但占的内存其实并不多，并且在初始化后的一次 gc 中便会回收。所以还好。</p>\n\n<p>同时也不存在效率问题，编译型语言，你懂的。</p>\n\n<p>同时验证一个 new 和取地址和 make 的区别的代码：</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">func</span> <span class=\"token function\" style=\"color:#FFD700;\">main</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span>\n    a1 <span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token function\" style=\"color:#FFD700;\">new</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n    a2<span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&amp;</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">{</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span>\n    a3<span class=\"token operator\" style=\"color:rgb(0,224,224);\">:=</span> <span class=\"token function\" style=\"color:#FFD700;\">make</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">[</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">]</span><span class=\"token builtin\" style=\"color:rgb(171,227,56);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">0</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n\n    fmt<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">.</span><span class=\"token function\" style=\"color:#FFD700;\">Println</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>a1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>a2<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>a3<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>a1<span class=\"token operator\" style=\"color:rgb(0,224,224);\">==</span>a1<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">}</span></code></pre>\n\n<p>附录：<a href=\"https://www.jianshu.com/p/c173dab0e71c\">Golang new 和 make 的区别</a></p>\n\n<p>扩展<br />对于内存的占用，今天看到一种写法。</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">var</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">_</span> Tester <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span>Test<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token boolean\" style=\"color:rgb(0,224,224);\">nil</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span></code></pre>\n\n<p>这样写和 new 的区别在于：<span style=\"color:rgb(53,56,58);\">new 是编译的时候检查，这样写是运行的时候检查</span></p>\n\n<p>转载自：<a href=\"https://blog.csdn.net/u011957758/article/details/83445288\">如何判断 Golang 接口是否实现？</a></p>\n\n<p><br /> <a href=\"https://learnku.com/blog/xiangshou/tags/golang-learning_50679\">Golang 学习</a></p>',7,1,0,3,0,0,1,'2020-05-07 21:43:12','2020-05-13 19:50:01'),(50,'知识分享--消息队列','概述 什么场景用到了消息队列 说到消息队列你脑子就要想到异步、削峰、解耦，条件反射那种。 异步： 我们之前的场景里面有很多步骤都是在一个流程里面需要做完的，就比如说我的下单系统吧，本来我们业务简单，下单了...','knowledge-sharing-message-queuing','<p>概述</p>\n\n<h2>什么场景用到了消息队列</h2>\n\n<blockquote><p>说到消息队列你脑子就要想到<span style=\"color:rgb(53,56,58);\">异步、削峰、解耦</span>，条件反射那种。</p></blockquote>\n\n<h3>异步：</h3>\n\n<ul><li>我们之前的场景里面有很多步骤都是在一个流程里面需要做完的，就比如说我的下单系统吧，本来我们业务简单，下单了付了钱就好了，流程就走完了。</li><li>但是后面来了个产品经理，搞了个<span style=\"color:rgb(53,56,58);\">优惠券系统</span>，OK 问题不大，流程里面多 100ms 去扣减优惠券。</li><li>后来产品经理灵光一闪说我们可以搞个<span style=\"color:rgb(53,56,58);\">积分系统</span>啊，也行吧，流程里面多了 200ms 去增减积分。</li><li>再后来后来隔壁的产品老王说：下单成功后我们要给用户发短信，也将就吧，100ms 去发个短信。</li><li>你们可以看到这才加了三个，我可以<span style=\"color:rgb(53,56,58);\">斩钉截铁</span>的告诉你真正的下单流程涉及的系统绝对在 10 个以上（主流电商），越大的越多。</li><li>这个链路这样下去，<span style=\"color:rgb(53,56,58);\">时间长得一批</span>，用户发现我买个东西你特么要花几十秒，垃圾电商我不在你这里买了，不过要是都像<span style=\"color:rgb(53,56,58);\">并夕夕</span>这么便宜，<span style=\"color:rgb(53,56,58);\">真香</span>！</li><li>但是我们公司没有夕夕的那个经济实力啊，那只能优化系统了。</li><li>那链路长了就慢了，但是我们发现上面的流程其实可以<span style=\"color:rgb(53,56,58);\">同时做</span>的呀，你支付成功后，我去校验优惠券的同时我可以去增减积分啊，还可以同时发个短信啊。</li><li>那正常的流程我们是没办法实现的呀，怎么办，<span style=\"color:rgb(53,56,58);\">异步</span>。</li><li>你对比一下是不是发现，这样子最多只用 100 毫秒用户知道下单成功了，至于短信你迟几秒发给他他根本不在意是吧。</li></ul>\n\n<h3>解耦：</h3>\n\n<ul><li>为啥我们不能用线程去做，因为用线程去做，你是不是要写代码？</li><li>你一个订单流程，你扣积分，扣优惠券，发短信，扣库存。。。等等这么多业务要调用这么多的接口，<span style=\"color:rgb(53,56,58);\">每次加一个你要调用一个接口然后还要重新发布系统</span>，写一次两次还好，写多了你就说：老子不干了！</li><li>而且真的全部都写在一起的话，不单单是耦合这一个问题，你出问题排查也麻烦，流程里面随便一个地方出问题搞不好会影响到其他的点，小伙伴说我每个流程都 <span style=\"color:rgb(53,56,58);\">try catch</span> 不就行了，相信我别这么做，这样的代码就像个<span style=\"color:rgb(53,56,58);\">定时炸弹</span>，你不知道什么时候爆炸，平时不炸偏偏在你做活动的时候炸，你就领个 <span style=\"color:rgb(53,56,58);\">P0 故障</span>收拾书包<span style=\"color:rgb(53,56,58);\">提前回家过年</span>吧。</li><li>但是你用了<span style=\"color:rgb(53,56,58);\">消息队列</span>，耦合这个问题就迎刃而解了呀。</li><li>你下单了，你就把你 <span style=\"color:rgb(53,56,58);\">支付成功的消息告诉别的系统</span> ，他们收到了去处理就好了，你只用走完自己的流程，把自己的消息发出去，那后面要接入什么系统简单，直接订阅你发送的支付成功消息，你支付成功了我 <span style=\"color:rgb(53,56,58);\">监听就好了</span> 。</li></ul>\n\n<h3>削峰：</h3>\n\n<blockquote><p>平时流量很低，但是你要做秒杀活动 00 ：00 的时候流量疯狂怼进来，你的服务器，<span style=\"color:rgb(53,56,58);\">Redis</span>，<span style=\"color:rgb(53,56,58);\">MySQL</span> 各自的承受能力都不一样，你直接<span style=\"color:rgb(53,56,58);\">全部流量照单全收</span>肯定有问题啊，直接就打挂了。</p></blockquote>\n\n<ul><li>简单，把请求放到队列里面，然后至于每秒消费多少请求，就看自己的<span style=\"color:rgb(53,56,58);\">服务器处理能力</span>，你能处理 5000QPS 你就消费这么多，可能会比正常的慢一点，但是<span style=\"color:rgb(53,56,58);\">不至于打挂服务器</span>，等流量高峰下去了，你的服务也就没压力了。</li><li>你看阿里双十一 12：00 的时候这么多流量瞬间涌进去，他有时候是不是会慢一点，但是人家没挂啊，或者降级给你个友好的提示页面，等高峰过去了又是一条好汉了。</li></ul>\n\n<h2>问题</h2>\n\n<h4>系统复杂性</h4>\n\n<p>本来蛮简单的一个系统，我代码随便写都没事，现在你凭空接入一个中间件在那，我是不是要考虑去维护他，而且使用的过程中是不是要考虑各种问题，比如消息<span style=\"color:rgb(53,56,58);\">重复消费</span>、<span style=\"color:rgb(53,56,58);\">消息丢失</span>、<span style=\"color:rgb(53,56,58);\">消息的顺序消费</span>等等，反正用了之后就是贼烦。</p>\n\n<h4>数据一致性</h4>\n\n<ul><li>这个其实是分布式服务本身就存在的一个问题，<span style=\"color:rgb(53,56,58);\">不仅仅是消息队列的问题</span>，但是放在这里说是因为用了消息队列这个问题会暴露得比较严重一点。</li><li>你下单的服务自己保证自己的逻辑成功处理了，你成功发了消息，但是优惠券系统，积分系统等等这么多系统，<span style=\"color:rgb(53,56,58);\">他们成功还是失败你就不管了？</span></li><li>保证自己的业务数据对的就好了，其实还是比较不负责任的一种说法，这样就<span style=\"color:rgb(53,56,58);\">像个渣男，没有格局</span>，<span style=\"color:rgb(53,56,58);\">这样呀你的路会越走越窄的</span>。</li></ul>\n\n<p><span style=\"color:rgb(53,56,58);\">重复消费</span></p>\n\n<p>一般消息队列的使用，我们都是有<span style=\"color:rgb(53,56,58);\">重试机制</span>的，就是说我下游的业务发生异常了，我会抛出异常并且要求你<span style=\"color:rgb(53,56,58);\">重新发一次</span>。</p>\n\n<p>我这个活动这里发生错误，你要求重发肯定没问题。但是大家<span style=\"color:rgb(53,56,58);\">仔细想一下</span>问题在哪里？</p>\n\n<p>是的，不止你一个人监听这个消息啊，<span style=\"color:rgb(53,56,58);\">还有别的服务也在监听</span>，他们也会失败啊，他一失败他也要求重发，但是你这里其实是成功的，重发了，你的钱不就加了两次了？</p>\n\n<p>真实的情况其实重试是很正常的，服务的<span style=\"color:rgb(53,56,58);\">网络抖动</span>，<span style=\"color:rgb(53,56,58);\">开发人员代码 Bug</span>，还有<span style=\"color:rgb(53,56,58);\">数据问题</span>等都可能处理失败要求重发的。</p>\n\n<p>一般我们叫这样的处理叫接口<span style=\"color:rgb(53,56,58);\">幂等</span>。</p>\n\n<blockquote><p><span style=\"color:rgb(53,56,58);\">幂等（idempotent、idempotence）</span>是一个数学与计算机学概念，常见于抽象代数中。</p></blockquote>\n\n<p>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。</p>\n\n<p>幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。</p>\n\n<p>例如，“setTrue ()” 函数就是一个幂等函数，<span style=\"color:rgb(53,56,58);\">无论多次执行，其结果都是一样的.</span> 更复杂的操作幂等保证是利用唯一交易号 (流水号) 实现.</p>\n\n<p>一般<span style=\"color:rgb(53,56,58);\">幂等</span>，可以<span style=\"color:rgb(53,56,58);\">分场景去考虑</span>，看是<span style=\"color:rgb(53,56,58);\">强校验</span>还是<span style=\"color:rgb(53,56,58);\">弱校验</span>，比如跟金钱相关的场景那就很关键呀，就做强校验，别不是很重要的场景做弱校验。</p>\n\n<p><span style=\"color:rgb(53,56,58);\">所有的服务都成功才能算这一次下单是成功的</span>，那怎么才能保证数据一致性呢？</p>\n\n<p><span style=\"color:rgb(53,56,58);\">分布式事务</span>：把下单，优惠券，积分。。。都放在一个事务里面一样，要成功一起成功，要失败一起失败。</p>\n\n<h3>可用性</h3>\n\n<p>你搞个系统本身没啥问题，你现在突然接入一个中间件在那放着，万一挂了怎么办？我下个单 <span style=\"color:rgb(53,56,58);\">MQ 挂了</span>，优惠券不扣了，积分不减了，这不是杀一个程序员能搞定的吧，感觉得杀一片。</p>\n\n<h2>技术选型</h2>\n\n<p>市面上比较主流的消息队列中间件主要有，<span style=\"color:rgb(53,56,58);\">Kafka、ActiveMQ、RabbitMQ、RocketMQ</span> 等这几种</p>\n\n<p><span style=\"color:rgb(53,56,58);\">ActiveMQ</span> 和 <span style=\"color:rgb(53,56,58);\">RabbitMQ</span> 这两着因为吞吐量还有 <span style=\"color:rgb(53,56,58);\">GitHub</span> 的社区活跃度的原因，在各大互联网公司都已经基本上绝迹了，业务体量一般的公司会是有在用的，但是越来越多的公司更青睐 <span style=\"color:rgb(53,56,58);\">RocketMQ 和 Kafka</span> 这样的消息中间件了。</p>\n\n<p><span style=\"color:rgb(53,56,58);\">Kafka</span> 和 <span style=\"color:rgb(53,56,58);\">RocketMQ</span> 一直在各自擅长的领域发光发亮，不过写这篇文章的时候我问了蚂蚁金服，字节跳动和美团的朋友，好像大家用的都有点不一样，应该都是各自的中间件，可能做过修改，也可能是<span style=\"color:rgb(53,56,58);\">自研</span>的，大多<span style=\"color:rgb(53,56,58);\">没有开源</span>。</p>\n\n<p>就像我们公司就是是基于 <span style=\"color:rgb(53,56,58);\">Kafka</span> 和 <span style=\"color:rgb(53,56,58);\">RocketMQ</span> 两者的优点自研的消息队列中间件，吞吐量、可靠性、时效性等都很可观。</p>\n\n<p><br /></p>\n\n<p>就拿<span style=\"color:rgb(53,56,58);\">吞吐量</span>来说，早期比较活跃的 <span style=\"color:rgb(53,56,58);\">ActiveMQ</span> 和 <span style=\"color:rgb(53,56,58);\">RabbitMQ</span> 基本上不是后两者的对手了，在现在这样大数据的年代<span style=\"color:rgb(53,56,58);\">吞吐量是真的很重要</span>。</p>\n\n<p>比如现在突然爆发了一个超级热点新闻，你的 APP 注册用户高达亿数，你要想办法第一时间把突发全部推送到每个人手上，你没有<span style=\"color:rgb(53,56,58);\">大吞吐量的消息队列</span>中间件用啥去推？</p>\n\n<p>再说这些用户大量涌进来看了你的新闻产生了一系列的附带流量，你怎么应对这些数据，<span style=\"color:rgb(53,56,58);\">很多场景离开消息队列基本上难以为继</span>。</p>\n\n<p>就<span style=\"color:rgb(53,56,58);\">部署方式</span>而言前两者也是大不如后面两个<span style=\"color:rgb(53,56,58);\">天然分布式架构的哥哥</span>，都是高可用的分布式架构，而且数据多个副本的数据也能做到 0 丢失。</p>\n\n<p><span style=\"color:rgb(53,56,58);\">RabbitMQ</span> 这个中间件其实还行，但是这玩意开发语言居然是 <span style=\"color:rgb(53,56,58);\">erlang</span>，我敢说绝大部分工程师肯定不会为了一个中间件去刻意学习一门语言的，开发维护成本你想都想不到，出个问题查都查半天。</p>\n\n<p>至于 <span style=\"color:rgb(53,56,58);\">RocketMQ</span>（阿里开源的），git 活跃度还可以。基本上你 push 了自己的 bug 确认了有问题都有阿里大佬跟你试试解答并修复的，我个人推荐的也是这个，他的架构设计部分跟同样是阿里开源的一个 <span style=\"color:rgb(53,56,58);\">RPC</span> 框架是真的很像（<span style=\"color:rgb(53,56,58);\">Dubbo</span>）可能是因为师出同门的原因吧。</p>\n\n<p><span style=\"color:rgb(53,56,58);\">Kafka</span> 我放到最后说，你们也应该知道了，压轴的这是个大哥，大数据领域，公司的日志采集，实时计算等场景，都离不开他的身影，他基本上算得上是<span style=\"color:rgb(53,56,58);\">世界范围级别的消息队列标杆</span>了。</p>',2,1,0,1,0,0,1,'2020-05-07 21:46:36','2020-05-13 19:05:09'),(51,'知识分享--算法','基本数据结构 数组链表二叉树队列栈堆 排序算法 冒泡排序快速排序基数排序插入排序桶排序归并排序外部归并选择排序希尔排序堆排序还有很多都有独特的运用场景 搜索算法 字符串相关KMP最长公共子串最长公共子序列最长...','knowledge-sharing-algorithm','<h3>基本数据结构</h3>\n\n<ul><li>数组</li><li>链表</li><li>二叉树</li><li>队列</li><li>栈</li><li>堆</li></ul>\n\n<h3>排序算法</h3>\n\n<ul><li><p>冒泡排序</p></li><li><p>快速排序</p></li><li><p>基数排序</p></li><li><p>插入排序</p></li><li><p>桶排序</p></li><li><p>归并排序</p></li><li><p>外部归并</p></li><li><p>选择排序</p></li><li><p>希尔排序</p></li><li><p>堆排序</p><p>还有很多都有独特的运用场景</p></li></ul>\n\n<h3>搜索算法</h3>\n\n<ul><li>字符串相关<ul><li>KMP</li><li>最长公共子串</li><li>最长公共子序列</li><li>最长回文子串等等</li></ul></li><li>状态空间搜索<ul><li>二分查找</li><li>哈希查找</li><li>布隆过滤器 (Bloom filter)</li><li>深入优先</li><li>广度优先</li><li>贪心算法</li><li>A*</li><li>回溯</li><li>分支界定</li><li>遗传算法</li></ul></li></ul>\n\n<h3>树算法</h3>\n\n<ul><li>红黑树</li><li>2-3 查找树</li><li>Trie</li><li>AVL</li><li>B-Tree / B+ Tree</li><li>LSM Tree</li><li>Bitset</li></ul>\n\n<h3>随机算法</h3>\n\n<ul><li>蒙特卡洛算法</li><li>模拟退火</li><li>蚁群算法</li></ul>\n\n<h3>动态规划</h3>\n\n<ul><li>线性动规</li><li>区域动规</li><li>树形动规</li><li>背包问题</li></ul>',2,1,0,1,0,0,1,'2020-05-07 21:47:57','2020-05-13 19:04:56'),(52,'知识分享--云原生','DockerK8Sistioconsul Consul 架构介绍 High-Level 架构 prometheusgrafanaAPI Gateway 在选择 API Gateway 的时候，要面向未来，综合考虑性能，易用性和生态体系，总结一下目前的在 CNCF Cloud Native Interactive...','knowledge-sharing-cloud-native','<p>DockerK8Sistioconsul</p>\n\n<h2>Consul 架构介绍</h2>\n\n<p>High-Level 架构</p>\n\n<p>prometheusgrafanaAPI Gateway</p>\n\n<blockquote><p>在选择 API Gateway 的时候，要面向未来，综合考虑性能，易用性和生态体系，总结一下目前的在 CNCF Cloud Native Interactive Landscape 中出现的 API Gateway, 主要分以下几类：</p></blockquote>\n\n<ol><li>基于 Nginx 和 OpenResty 的<ol><li>APISIX</li><li>Kong</li><li>3Scale</li></ol></li><li>Java<ol><li>Sentinel</li><li>Mule</li></ol></li><li>Go<ol><li>Krakend</li><li>traefik</li><li>Tyk</li><li>Ambassador</li><li>Gloo</li></ol></li><li>Other<ol><li>Express gateway</li><li>Reactive Interaction Gateway</li></ol></li></ol>\n\n<p>Service Meshzookeeper</p>\n\n<p>Leader 选举是保证分布式数据一致性的关键所在。当 Zookeeper 集群中的一台服务器出现以下两种情况之一时，需要进入 Leader 选举。</p>\n\n<ul><li>(1) 服务器初始化启动。</li><li>(2) 服务器运行期间无法和 Leader 保持连接。</li></ul>\n\n<p>下面就两种情况进行分析讲解。</p>\n\n<p><span style=\"color:rgb(53,56,58);\">1. 服务器启动时期的 Leader 选举</span></p>\n\n<blockquote><p>若进行 Leader 选举，则至少需要两台机器，这里选取 3 台机器组成的服务器集群为例。在集群初始化阶段，当有一台服务器 Server1 启动时，其单独无法进行和完成 Leader 选举，当第二台服务器 Server2 启动时，此时两台机器可以相互通信，每台机器都试图找到 Leader，于是进入 Leader 选举过程。</p></blockquote>\n\n<p>选举过程如下</p>\n\n<ul><li><span style=\"color:rgb(53,56,58);\">(1) 每个 Server 发出一个投票</span>。由于是初始情况，Server1 和 Server2 都会将自己作为 Leader 服务器来进行投票，每次投票会包含所推举的服务器的 myid 和 ZXID，使用 (myid, ZXID) 来表示，此时 Server1 的投票为 (1, 0)，Server2 的投票为 (2, 0)，然后各自将这个投票发给集群中其他机器。</li><li><span style=\"color:rgb(53,56,58);\">(2) 接受来自各个服务器的投票</span>。集群的每个服务器收到投票后，<span style=\"color:rgb(53,56,58);\">首先判断该投票的有效性，如检查是否是本轮投票、是否来自 LOOKING 状态的服务器。</span></li><li><span style=\"color:rgb(53,56,58);\">(3) 处理投票</span>。针对每一个投票，服务器都需要将别人的投票和自己的投票进行 PK，PK 规则如下<ul><li>・优先检查 ZXID。ZXID 比较大的服务器优先作为 Leader。</li><li>・如果 ZXID 相同，那么就比较 myid。myid 较大的服务器作为 Leader 服务器。</li></ul></li></ul>\n\n<blockquote><p>对于 Server1 而言，它的投票是 (1, 0)，接收 Server2 的投票为 (2, 0)，首先会比较两者的 ZXID，均为 0，再比较 myid，此时 Server2 的 myid 最大，于是更新自己的投票为 (2, 0)，然后重新投票，对于 Server2 而言，其无须更新自己的投票，只是<span style=\"color:rgb(53,56,58);\">再次向集群中所有机器发出上一次投票信息即可。</span></p></blockquote>\n\n<ul><li><span style=\"color:rgb(53,56,58);\">(4) 统计投票</span>。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于 Server1、Server2 而言，都统计出集群中已经有两台机器接受了 (2, 0) 的投票信息，此时便认为已经选出了 Leader。</li><li><span style=\"color:rgb(53,56,58);\">(5) 改变服务器状态</span>。<span style=\"color:rgb(53,56,58);\">一旦确定了 Leader，每个服务器就会更新自己的状态，如果是 Follower，那么就变更为 FOLLOWING，如果是 Leader，就变更为 LEADING。</span></li></ul>\n\n<p><span style=\"color:rgb(53,56,58);\">2. 服务器运行时期的 Leader 选举</span></p>\n\n<blockquote><p>　　<span style=\"color:rgb(53,56,58);\">在 Zookeeper 运行期间，Leader 与非 Leader 服务器各司其职，即便当有非 Leader 服务器宕机或新加入，此时也不会影响 Leader，但是一旦 Leader 服务器挂了，那么整个集群将暂停对外服务，进入新一轮 Leader 选举，其过程和启动时期的 Leader 选举过程基本一致</span></p></blockquote>\n\n<p>假设正在运行的有 Server1、Server2、Server3 三台服务器，当前 Leader 是 Server2，若某一时刻 Leader 挂了，此时便开始 Leader 选举。选举过程如下</p>\n\n<ul><li><span style=\"color:rgb(53,56,58);\">(1) 变更状态</span>。<span style=\"color:rgb(53,56,58);\">Leader 挂后，余下的非 Observer 服务器都会讲自己的服务器状态变更为 LOOKING，然后开始进入 Leader 选举过程。</span></li><li><span style=\"color:rgb(53,56,58);\">(2) 每个 Server 会发出一个投票</span>。在运行期间，每个服务器上的 ZXID 可能不同，此时假定 Server1 的 ZXID 为 123，Server3 的 ZXID 为 122；在第一轮投票中，Server1 和 Server3 都会投自己，产生投票 (1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器。</li><li><span style=\"color:rgb(53,56,58);\">(3) 接收来自各个服务器的投票</span>。与启动时过程相同。</li><li><span style=\"color:rgb(53,56,58);\">(4) 处理投票</span>。与启动时过程相同，此时，Server1 将会成为 Leader。</li><li><span style=\"color:rgb(53,56,58);\">(5) 统计投票</span>。与启动时过程相同。</li><li><span style=\"color:rgb(53,56,58);\">(6) 改变服务器的状态</span>。与启动时过程相同。</li></ul>',2,1,0,1,0,0,1,'2020-05-07 21:49:00','2020-05-13 19:04:53'),(53,'知识分享--数据库','MySQL MySQL 中的索引 索引 索引常见的几种类型 索引常见的类型有哈希索引，有序数组索引，二叉树索引，跳表等等。主要探讨 MySQL 的默认存储引擎 InnoDB 的索引结构。 InnoDB 的索引结构 有两种常用的索引，B+ 树索...','knowledge-sharing-database','<p>MySQL</p>\n\n<h2>MySQL 中的索引</h2>\n\n<h3>索引</h3>\n\n<h4>索引常见的几种类型</h4>\n\n<blockquote><p>索引常见的类型有<span style=\"color:rgb(53,56,58);\">哈希索引，有序数组索引，二叉树索引，跳表</span>等等。主要探讨 MySQL 的默认存储引擎 <span style=\"color:rgb(53,56,58);\">InnoDB</span> 的索引结构。</p></blockquote>\n\n<h4>InnoDB 的索引结构</h4>\n\n<blockquote><p>有两种常用的索引，B+ 树索引和 Hash 索引</p></blockquote>\n\n<p>为什么使用 B+Tree?</p>\n\n<ul><li>索引的常见模型常见的有，哈希表、有序数组、搜索树。</li><li>有序数组，优点是等值查询，范围查询都非常快，缺点也很明显，就是插入效率太低，因为如果从中间插入，要移动后面所有的元素。</li><li>在 B + 树中是<span style=\"color:rgb(53,56,58);\">只有叶子结点会存储数据</span>，而且<span style=\"color:rgb(53,56,58);\">所有叶子结点会形成一个链表</span>。而在 InnoDB 中维护的是一个双向链表。</li><li><br /></li></ul>\n\n<ul><li>哈希结构只适用于等值查询（但这样速度非常快）。哈希结构不支持顺序检索例如’&lt;’、’&gt;’、”between and” 等，这种存储结构属于 “键值” 查询，符合这种需求可以考虑使用哈希索引。</li><li>优化器不能使用哈希索引来加快 order by 操作。(此类型的索引不能用于按顺序搜索下一个条目。</li><li>mysql 不能大致确定两个值之间有多少行 (范围优化器使用它来决定要使用哪个索引)。如果将 MyISAM 或 InnoDB 表更改为哈希索引的内存表，这可能会影响某些查询。</li></ul>\n\n<p>为什么使用 B + 树 而不使用二叉树或者 B 树？</p>\n\n<blockquote><p>首先，我们知道访问磁盘需要访问到指定块中，而访问指定块是需要 盘片旋转 和 磁臂移动 的，这是一个比较耗时的过程，如果<span style=\"color:rgb(53,56,58);\">增加树高那么就意味着你需要进行更多次的磁盘访问</span>，所以会采用 n 叉树。而使用 B + 树是因为如果使用 B 树在进行一个范围查找的时候每次都会进行重新检索，而在 B + 树中可以充分利用叶子结点的链表。</p></blockquote>\n\n<blockquote><p>在建表的时候你可能会添加多个索引，而 InnDB 会<span style=\"color:rgb(53,56,58);\">为每个索引建立一个 B + 树 进行存储索引</span>。</p></blockquote>\n\n<p>建立一个简单的测试表</p>\n\n<h4>索引维护</h4>\n\n<ul><li>我们知道索引是需要占用空间的，索引虽能提升我们的查询速度但是也是不能滥用。</li><li>比如我们在用户表里用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。也就是说如果我用整型后面维护了 4 个 g 的索引列表，那么用身份证将会是 20 个 g。</li><li>所以我们可以<span style=\"color:rgb(53,56,58);\">通过缩减索引的大小来减少索引所占空间</span>。</li><li>当然 B + 树为了维护索引的有序性会在删除，插入的时候进行一些必要的维护 (在 InnoDB 中删除会将节点标记为 “可复用” 以减少对结构的变动)。</li><li>比如在增加一个节点的时候可能会遇到<span style=\"color:rgb(53,56,58);\">数据页满了</span>的情况，这个时候就需要做<span style=\"color:rgb(53,56,58);\">页的分裂</span>，这是一个比较耗时的工作，而且页的分裂还会导致数据页的利用率变低，比如原来存放三个数据的数据页再次添加一个数据的时候需要做页分裂，这个时候就会将现有的四个数据分配到两个数据页中，这样就减少了数据页利用率。</li></ul>\n\n<h4>覆盖索引</h4>\n\n<blockquote><p>有时候我们查辅助索引的时候就已经满足了我们需要查的数据，这个时候 InnoDB 就会进行一个叫 <span style=\"color:rgb(53,56,58);\">覆盖索引</span> 的操作来提升效率，减少回表。</p></blockquote>\n\n<p>比如这个时候我们进行一个 select 操作</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">select</span> id <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">from</span> test <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">where</span> a <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">1</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span></code></pre>\n\n<blockquote><p>这个时候很明显我们走了 a 的索引直接能获取到 id 的值，这个时候就不需要进行回表，我们这个时候就使用了 <span style=\"color:rgb(53,56,58);\">覆盖索引</span>。</p></blockquote>\n\n<blockquote><p>简单来说 <span style=\"color:rgb(53,56,58);\">覆盖索引</span> 就是<span style=\"color:rgb(53,56,58);\">当我们走辅助索引的时候能获取到我们所需要的数据的时候不需要再次进行回表操作的操作</span>。</p></blockquote>\n\n<h4>联合索引</h4>\n\n<p>新建一个学生表</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">CREATE</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">TABLE</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>stu<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span>\n  <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>id<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">11</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">NOT</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">NULL</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n  <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>class<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">int</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">11</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">DEFAULT</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">NULL</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n  <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">varchar</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token number\" style=\"color:rgb(0,224,224);\">255</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">DEFAULT</span> <span class=\"token boolean\" style=\"color:rgb(0,224,224);\">NULL</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n  <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">PRIMARY</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">KEY</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>id<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span>\n  <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">KEY</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>class_name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span> <span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">(</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>class<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">,</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span>name<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">`</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">USING</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">BTREE</span>\n<span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">)</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">ENGINE</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">InnoDB</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">DEFAULT</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">CHARSET</span><span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span>utf8 </code></pre>\n\n<p>假如这个时候我们有一个需求，我们需要通过班级号去找对应的学生姓名，我们使用 class (班级号) 和 name 做一个 联合索引。</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">select</span> name <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">from</span> stu <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">where</span> class <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">102</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span></code></pre>\n\n<blockquote><p>这个时候我们就可以直接在 <span style=\"color:rgb(53,56,58);\">辅助索引</span> 上查找到学生姓名而不需要再次回表。</p></blockquote>\n\n<blockquote><p>总的来说，<span style=\"color:rgb(53,56,58);\">设计好索引，充分利用覆盖索引能很大提升检索速度</span>。</p></blockquote>\n\n<h4>最左前缀原则</h4>\n\n<blockquote><p>以 <span style=\"color:rgb(53,56,58);\">联合索引</span> 作为基础的，是一种联合索引的匹配规则。</p></blockquote>\n\n<p>我们有个学生迟到，但是他在门卫记录信息的时候只写了自己的名字张三而没有写班级，所以我们需要通过学生姓名去查找相应的班级号。</p>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">select</span> class <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">from</span> stu <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">where</span> name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\'张三\'</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span></code></pre>\n\n<p>这个时候因为<span style=\"color:rgb(53,56,58);\">最左匹配原则我们就不会走我们的联合索引了，而是进行了全表扫描</span>。</p>\n\n<p>当然最左匹配原则还有这些规则</p>\n\n<ul><li>全值匹配的时候优化器会改变顺序，也就是说你全值匹配时的顺序和原先的联合索引顺序不一致没有关系，优化器会帮你调好。</li><li>索引匹配从<span style=\"color:rgb(53,56,58);\">最左边的地方开始</span>，如果没有则会进行全表扫描，比如你设计了一个 (a,b,c) 的联合索引，然后你可以使用 (a),(a,b),(a,b,c) 而你使用 (b),(b,c),(c) 就用不到索引了。</li><li>遇到范围匹配会取消索引。比如这个时候你进行一个这样的 select 操作</li></ul>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">select</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">from</span> stu <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">where</span> class <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&gt;</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">100</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">and</span> name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\'张三\'</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span></code></pre>\n\n<blockquote><p>这个时候 InnoDB 就会放弃索引而进行全表扫描，因为这个时候 InnoDB 会<span style=\"color:rgb(53,56,58);\">不知道怎么进行遍历索引</span>，所以进行全表扫描。</p></blockquote>\n\n<h4>索引下推</h4>\n\n<blockquote><p>刚刚的操作在 MySQL5.6 版本以前是需要进行回表的，但是 5.6 之后的版本做了一个叫 <span style=\"color:rgb(53,56,58);\">索引下推</span> 的优化。</p></blockquote>\n\n<pre><code><span class=\"token keyword\" style=\"color:rgb(0,224,224);\">select</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">*</span> <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">from</span> stu <span class=\"token keyword\" style=\"color:rgb(0,224,224);\">where</span> class <span class=\"token operator\" style=\"color:rgb(0,224,224);\">&gt;</span> <span class=\"token number\" style=\"color:rgb(0,224,224);\">100</span> <span class=\"token operator\" style=\"color:rgb(0,224,224);\">and</span> name <span class=\"token operator\" style=\"color:rgb(0,224,224);\">=</span> <span class=\"token string\" style=\"color:rgb(171,227,56);\">\'张三\'</span><span class=\"token punctuation\" style=\"color:rgb(254,254,254);\">;</span></code></pre>\n\n<p>如何优化的呢？因为刚刚的<span style=\"color:rgb(53,56,58);\">最左匹配原则</span>我们放弃了索引，后面我们紧接着会通过回表进行判断 name，这个时候我们所要做的操作应该是这样的</p>',2,1,0,1,0,0,1,'2020-05-07 21:50:02','2020-05-13 19:04:16'),(54,'知识分享--前端','CSS 基础 Fundamentals文档流块级元素和内联元素盒子盒模型四大金刚line-height 和 vertical-align流的脱离floatclearBFC绝对定位层叠规则弹性布局网格布局文本控制::first-lettertext-transformword-spacingwhite-s...','knowledge-sharing-front-end','<p>CSS</p>\n\n<ul><li>基础 Fundamentals<ul><li>文档流</li><li>块级元素和内联元素</li><li>盒子</li><li>盒模型四大金刚</li><li>line-height 和 vertical-align</li><li>流的脱离<ul><li>float</li><li>clear</li><li>BFC</li><li>绝对定位</li></ul></li><li>层叠规则</li><li>弹性布局</li><li>网格布局</li><li>文本控制<ul><li>::first-letter</li><li>text-transform</li><li>word-spacing</li><li>white-space</li><li>*text-align: justify<br />* 为两端对齐。除了实现文字的两端对齐，还能用来做一些两端对齐的布局</li></ul></li><li>元素显示和隐藏</li></ul></li><li>Media Query</li><li>Selector 选择器</li><li>Rules 规则</li><li>Layout<ul><li>Float</li><li>Positioning</li><li>Display</li><li>Box Model</li><li>Grid</li><li>Flex box</li></ul></li><li>动画 Animation 和 Effect 效果<ul><li>Transition and Animation (位移和动画)</li><li>2D/3D Transform (变换)</li><li>Filter 过滤器</li><li>Shape (形状) 和 Mask</li></ul></li><li>Font 字体<ul><li>安全字体</li><li>Google Fonts</li><li>Web Fonts<ul><li>不同字体的区别<ul><li>TTF</li><li>OTF</li><li>WOFF</li><li>SVG Fonts/Shapes</li><li>EOT</li></ul></li><li>Font Awesome</li></ul></li></ul></li><li>Color Model 色彩模型 &amp; Gradient 渐变</li><li>响应式设计<ul><li>Media Query</li><li>Viewport</li><li>移动友好 (mobile friendly)</li></ul></li><li>CSS 增强<ul><li>Preprocessor<ul><li>LESS</li><li>SASS</li></ul></li><li>PostProcessor<ul><li>PostCSS</li></ul></li><li>CSS 架构<ul><li>Atomic CSS</li><li>OOCSS</li><li>ITCSS</li></ul></li></ul></li><li>CSS 框架<ul><li>重量级<ul><li>Bootstrap</li><li>Material Design</li><li>Metro UI / Fluent UI</li></ul></li><li>轻量级<ul><li>Picnic</li><li>PureCSS</li><li>Primer</li></ul></li><li>超轻<ul><li>Milligram</li><li>Skeleton</li></ul></li></ul></li><li>Grid 框架<ul><li>Gridly</li><li>Flexbox Grid</li></ul></li><li>CSS 修正<ul><li>Modenizr</li><li>NormalCSS</li><li>HTML Boilerplate</li></ul></li></ul>\n\n<p>HTML</p>\n\n<ul><li>基础</li><li>SEO<ul><li>Keyword and Alt 内容</li><li>Meta</li><li>Search Engines</li></ul></li><li>浏览器<ul><li>Chrome</li><li>Safari</li><li>Firefox</li><li>Edge</li><li>IE</li><li>Other</li></ul></li><li>HTML5<ul><li>可用性 (Accessiblity)<ul><li>ARIA 属性</li><li>回退内容 (Fallback content)</li></ul></li><li>语义化标签<ul><li>section elements</li><li>grouping elements</li><li>text-level elements</li><li>interaction elements</li></ul></li><li>input type=text/search/tel/email / url / date / month / week /time / datetime-local / number /range / color / checkbox / image / file<ul><li>input 验证</li></ul></li><li>FORM 和 验证</li><li>HTML 编辑相关 API 和知识</li><li>Media<ul><li>图片</li><li>视频</li><li>音频</li><li>WebRTC</li><li>优化工具</li></ul></li><li>脚本加载<ul><li>加载顺序</li><li>async/defer</li></ul></li><li>CSS 加载</li><li>位置 API</li><li>拖放 (Drag-and-drop) API</li><li>File API</li><li>通信<ul><li>XMLHTTPRequest2</li><li>WebSocket</li><li>Post Message</li></ul></li><li>Web Components<ul><li>Custom Element</li><li>Shadow DOM</li><li>HTML Template</li><li>HTML Import</li></ul></li><li>Canvas<ul><li>2D graphics</li><li>3D/WebGL</li></ul></li><li>安全<ul><li>WebAuth API</li><li>Web Cryptography API</li><li>CORS</li><li>Content Security Policy</li></ul></li></ul></li></ul>\n\n<p>Javascript</p>\n\n<ul><li><p>基础 Basics</p><ul><li><p>浏览器加载机制</p></li><li><p>ES5 (和传统 JS)</p><ul><li>Lambda 和回调</li><li>Object 和 Prototype</li><li>Ajax 和 XMLHttpRequest</li><li>事件和绑定</li><li>正则表达式</li><li>数据类型</li><li>作用域<ul><li>This</li><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ul></li><li>闭包</li><li>高阶函数</li><li>继承</li><li>深拷贝 / 浅拷贝</li><li>DOM 管理<ul><li>传统方式<ul><li>getElementById</li><li>getElementsByClassName</li><li>getElementsByTagName</li></ul></li><li>现代方式<ul><li>querySelector/querySelectorAll</li></ul></li><li>Library 库<ul><li>Virtual DOM<ul><li>Virtual-Dom</li><li>MoquetteJS</li></ul></li><li>Qwery</li></ul></li></ul></li></ul></li><li><p>ES6</p><ul><li>Promises</li><li>Proxy</li><li>Arrow Function</li><li>Class</li><li>Set/Map</li><li>Module</li><li>Let/Const</li><li>模板字符串</li><li>函数默认参数</li></ul></li><li><p>ES7,8,9</p><ul><li><p>async/await</p></li><li><p>SharedArrayBuffer</p></li><li><p>异步迭代</p></li><li><p>Promise.finally()</p></li><li><p>Rest/Spread 属性</p></li><li><p>正则表达式增强</p></li><li><p>更友好的 JSON.stringify</p></li><li><p>Array 的 <code>flat()</code> 方法和 <code>flatMap()</code> 方法</p></li><li><p>Object.fromEntries()</p></li><li><p>Symbol、BigInt 基本数据类型</p></li></ul></li></ul></li><li><p>进阶</p><ul><li><p>同步异步执行原理</p><ul><li>setTimeout/setInterval 原理</li><li>promise 原理</li><li>async/await</li></ul></li><li><p>重绘和回流</p></li><li><p>防抖和节流</p></li><li><p>继承的原理</p></li><li><p>V8 JS 引擎的垃圾回收机制</p></li><li><p>Typescript</p></li><li><p>模块化</p><ul><li>ES6 Import/Export</li><li>RequireJS/AMD</li><li>CommonJS</li></ul></li><li><p>代码质量</p><ul><li>ESLint</li><li>JSLInt</li></ul></li><li><p>测试和 mock</p><ul><li>Mocha</li><li>Jest</li></ul></li><li><p>HTML5/JS API</p><ul><li>Multimedia<ul><li>Canvas API</li><li>Audio/Video API</li><li>Web Animation API</li><li>Web RTC</li></ul></li><li>Device<ul><li>Battery API (电池)</li><li>Geoloation API (位置)</li><li>Gamepad</li><li>Vibration</li></ul></li><li>交互<ul><li>Payment</li><li>Notification</li><li>WebSocket</li><li>Drag-and-Drop API</li></ul></li><li>Performance<ul><li>Web Worker</li><li>Navigation Timing</li><li>Web Assembly</li></ul></li><li>Storage<ul><li>File API</li><li>Fetch API</li><li>Local/SessionStorage</li><li>IndexDB</li></ul></li><li>Security<ul><li>WebAuth API</li><li>Web Cryptography API</li></ul></li></ul></li></ul></li></ul>\n\n<p>框架和应用浏览器</p>\n\n<ul><li><p>事件机制</p></li><li><p>跨域</p><ul><li><p>JSONP</p></li><li><p>CORS</p></li><li><p>document.domain</p></li><li><p>postMessage</p></li></ul></li><li><p>Event Loop</p><ul><li>主流程</li><li>Macro-Task</li><li>Micro-Task</li></ul></li><li><p>存储</p></li><li><p>安全性设置</p></li><li><p>排版 / 渲染流程</p></li></ul>',2,1,0,1,0,0,1,'2020-05-07 21:51:45','2020-05-13 19:04:14'),(55,'PHP 爬取起点网免费章节','&lt;?php      function doCurlGetRequest($url){          if($url == \'\'){             return false;          }          $con = curl_init();          curl_setopt($con, CURLOPT_URL, $url);          curl_s...','php-crawls-the-free-chapter-of-the-starting-site','<pre><code>&lt;?php \n\n    function doCurlGetRequest($url){\n         if($url == \'\'){\n            return false;\n         }\n         $con = curl_init();\n         curl_setopt($con, CURLOPT_URL, $url);\n         curl_setopt($con, CURLOPT_RETURNTRANSFER, 1);\n         curl_setopt($con, CURLOPT_SSL_VERIFYPEER, FALSE);\n         $header[] = \"Content-type:application/json;charset=utf-8\";\n         if (!empty($header)) {\n            curl_setopt($con, CURLOPT_HTTPHEADER, $header);\n        }\n            curl_setopt($con, CURLOPT_HTTPGET, true);\n            $data = curl_exec($con);\n            curl_close($con);//关闭cURL会话\n            return $data;\n\n    }\n\n    function xiaoshuo($url){\n        $info1=doCurlGetRequest($url);\n        $info=json_decode($info1,true);\n        if($info[\'code\']==0 &amp;&amp; $info[\'msg\']==\"成功\"){\n            $data=$info[\'data\'];\n            $bookId=$data[\'bookInfo\'][\'bookId\'];\n            $chapterId=$data[\'chapterInfo\'][\'chapterId\'];\n            $chapterName=$data[\'chapterInfo\'][\'chapterName\'];\n            $next=$data[\'chapterInfo\'][\'next\'];\n            $prev=$data[\'chapterInfo\'][\'prev\'];\n            $content=$data[\'chapterInfo\'][\'content\'];\n            file_put_contents(\"info.txt\",$chapterName,FILE_APPEND);\n            $content=preg_replace(\"/&lt;p&gt;/\",\"\\n\",$content);\n            file_put_contents(\"info.txt\",\"    \".$content.\"\\n\",FILE_APPEND);\n            if($next!=-1){\n                $next_url=\"https://m.qidian.com/majax/chapter/getChapterInfo?bookId=\".$bookId.\"&amp;chapterId=\".$next;\n                return $next_url;\n            }else{\n                return false;\n            }\n        }\n    }\n       $url=\"https://m.qidian.com/majax/chapter/getChapterInfo?bookId=1003354631&amp;chapterId=306873415\";\n       //获取小说前150章的内容\n       for ($x=1;$x &lt;= 150;$x++) {\n               if($url){\n                   $url=xiaoshuo($url); \n               }\n       }\n?&gt;<br /></code></pre>\n\n<p> </p>',2,3,0,2,0,0,1,'2020-05-07 21:54:22','2020-05-13 19:03:46'),(56,'Laravel 整合 Workerman 做聊天室','在很多时候我们需要做这种聊天室的时候需要实时响应，所以今天介绍一下workerman，如果没有听过workerman的小伙伴，传送门：workerman文档 ，官网 本篇文章是整合laravel 5.8的，使用artisan 命令去管理workerman。...','laravel-integrates-workerman-to-make-chat-room','<p>在很多时候我们需要做这种聊天室的时候需要实时响应，所以今天介绍一下workerman，如果没有听过workerman的小伙伴，传送门：<a href=\"http://doc.workerman.net/\">workerman文档</a> ，<a href=\"https://www.workerman.net/\">官网</a></p>\n\n<p>本篇文章是整合<code>laravel 5.8</code>的，使用<code>artisan</code> 命令去管理<code>workerman</code>。</p>\n\n<p>如果觉得<code>workerman</code>不好搞，也可以直接使用<code>GatewayWorker</code>，传送门：<a href=\"http://doc2.workerman.net/\">GatewayWorker手册</a> ， <a href=\"https://learnku.com/articles/13151/using-laravel-to-carry-out-socket-communication-in-workerman\">在 Laravel 中使用 GatewayWorker 进行 socket 通讯</a></p>\n\n<h4> </h4>',2,1,0,2,0,0,1,'2020-05-07 21:56:15','2020-05-13 18:28:27'),(57,'MySQL 查询重复的数据','我想查询name重复数据有多少条，并且是哪个name重复了 SELECT `name`,COUNT(*) FROM tables GROUP BY `name` HAVING COUNT(*)&gt;1; 我想要知道具体是那些数据重复了 SELECT * FROM tables WHERE `name` IN (SELECT...','mysql-queries-duplicate-data','<p><span style=\"color:rgb(136,136,136);\">我想查询</span><code>name</code><span style=\"color:rgb(136,136,136);\">重复数据有多少条，并且是哪个</span><code>name</code><span style=\"color:rgb(136,136,136);\">重复了</span><br /></p>\n\n<pre><code>SELECT `name`,COUNT(*) FROM tables GROUP BY `name` HAVING COUNT(*)&gt;1;<br /></code></pre>\n\n<p><span style=\"color:rgb(136,136,136);\">我想要知道具体是那些数据重复了</span><br /></p>\n\n<pre><code>SELECT * FROM tables WHERE `name` IN (SELECT `name` FROM tables GROUP BY `name` HAVING COUNT(*)&gt;1) ORDER BY `name` ASC;<br /></code></pre>\n\n<p><span style=\"color:rgb(136,136,136);\">我想查出所有重复数据，并排除最小id</span><br /></p>\n\n<pre><code>SELECT * FROM tables WHERE `name` IN (SELECT `name` FROM tables GROUP BY `name` HAVING COUNT(*)&gt;1) AND id NOT IN (SELECT MIN(id) FROM tables GROUP BY `name` HAVING COUNT(*)&gt;1) ORDER BY `name` ASC;<br /></code></pre>',2,1,0,2,0,0,1,'2020-05-07 21:57:53','2020-05-13 18:27:45'),(58,'论程序员如何优雅的听歌','现在听歌还要版权 网上各种破解软件要在下 安装 烦！！！ so Gayhub 帮助你我他 git clone https://github.com/nondanee/UnblockNeteaseMusic.git cd UnblockNeteaseMusic ping music.163.com node app.js -p 2345 -...','on-how-programmers-listen-to-songs-gracefully','<p><span style=\"color:rgb(99,107,111);\">现在听歌还要版权 网上各种破解软件要在下 安装 烦！！！</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">so Gayhub 帮助你我他</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\"><br /></span></p>\n\n<pre><code>git clone https://github.com/nondanee/UnblockNeteaseMusic.git\n\ncd UnblockNeteaseMusic\n\nping music.163.com\n\nnode app.js -p 2345 -f 59.111.181.38  # 精髓都在这行代码<br /></code></pre>',2,3,0,1,0,0,1,'2020-05-07 21:59:09','2020-05-13 18:27:23'),(59,'关于小程序框架的选择','小程序目前拥有很多个开源框架，比如Taro、mpvue、wepy 大家都有什么选择？ 目前我用 Taro 框架写了几个小程序，之所以使用 Taro，是因为可拓展性好，可以代替 React Native 的开发，对于小团队来说还是蛮有吸引力，...','on-the-selection-of-applet-framework','<blockquote><p><span style=\"color:rgb(209,210,210);\">小程序目前拥有很多个开源框架，比如Taro、mpvue</span><span style=\"color:rgb(209,210,210);font-size:inherit;\">、wepy</span></p></blockquote>\n\n<p>大家都有什么选择？</p>\n\n<p>目前我用 Taro 框架写了几个小程序，之所以使用 Taro，是因为可拓展性好，可以代替 React Native 的开发，对于小团队来说还是蛮有吸引力，因为之前也写过 RN，所以用 React 写东西还是舒服的</p>\n\n<p>wepy 算是微信官方自己的框架了，类 vuejs 的语法，但是只能生成微信小程序，拓展性不高</p>\n\n<p>mpvue 是美团的框架，可以生成 H5 和小程序，也还蛮不错</p>\n\n<p>也欢迎探讨小程序未来的发展是什么样子的，我作为一个小程序外包开发者，明显感受到小程序的开发需求是降低了，也许是各方面的 SaaS 系统比较完善了，有赞之类的成熟方案可以提供不错的体验。不知道小程序未来的发展是怎么样的。</p>',2,1,0,3,0,0,1,'2020-05-07 22:01:12','2020-05-13 18:26:55'),(60,'你究竟有多想成功','曾经有一个年轻人，他想赚很多很多的钱 。所以他找到了一位他视为偶像的大师，并告诉大师他想成为像大师一样强大的人。大师说，如果你想成为像我一样的人，那么明天早晨来海滩见我。 所以那个年轻人四点的时候就赶到...','how-much-do-you-want-to-succeed','<p><span style=\"color:rgb(99,107,111);\">曾经有一个年轻人，他想赚很多很多的钱 。所以他找到了一位他视为偶像的大师，并告诉大师他想成为像大师一样强大的人。大师说，如果你想成为像我一样的人，那么明天早晨来海滩见我。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">所以那个年轻人四点的时候就赶到了，想显得自己信心满满，西装革履，他当时应该穿着短裤。大师走过来摸着他的头问：“你有多想成功呢？” 年轻人说：“我真的很想！” 接着大师让他走下水。所以他就这样走进海里。海水差不多淹到年轻人的腰际。此时的他就像一个疯子一样。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">年轻人心里想：“我只想赚钱，他却只教我游泳。我可不想成为一个救生员。我只想成功！”</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">大师察觉到这一点。所以他就对年轻人说：“再走远一点。” 然后年轻人又走远了一些。这时候水差不多已经淹到他们肩膀附近了。年轻人心里想：“这老家伙真是个疯子，他很会赚钱但却是个疯子。”</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">而大师却就一直说：“再走远一点，再远一点。” 这时候水已经快要淹没他的嘴了。此时大师让年轻人往回走，这家伙一定疯了。大师这时候说：“你告诉我你想成功的。” 年轻人回答道：“是的！” 大师让他又走远了一点。这时候大师走进年轻人，把他的头按倒水里，再提起来，再按倒水里。就在年轻人快不行的时候，大师把他拎了起来。他对年轻人说我有话要告诉你，他对年轻人说：当你对成功的欲望足以与对呼吸的欲望媲美的时候，你就会成功。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">我不知道在看视频的你们有多少人有过哮喘的体验？如果你曾经有过这种体验，你感到气息不足，你就会像这样深呼吸并喘气。这时候你唯一要做的，就是去吸取新鲜空气。此时的你不会在意 NBA 停摆，不会在意电视正在播什么，不会在意有没有人给你打电话，不会在意派对的琐事！这时候你在意的只是在呼吸的时候吸取一些新鲜空气，这就是全部了！当你理解到自己对成功的渴望就像对呼吸的渴望一样时，你就会取得成功！让我来告诉你：第一：你们好多人都说自己想要成功，但实际上没有那么想，只是有点想而已。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">你们对成功的渴望甚至不如对派对的渴望，不如对耍帅的渴望。你们中的大多数人对成功的渴望甚至比不上对睡懒觉的渴望。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">你们中的一些人甚至更愿意睡懒觉。我要告诉你，如果你是一个生来就要成功的人，你需要乐意去放弃睡觉的权利。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">你会愿意放弃两小时甚至是三小时的睡眠时间！如果你真的很想成功，某些时候，你将会连续三天熬夜。因为如果你这时候去睡觉，你也许会失去一些成功的机会。这正是考验你有多想成功的时刻。你会经历一些不眠之夜，听着，你甚至会因为成功而忘记吃饭。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">碧昂斯说过，她曾经忙于一些失误以至于三天过去了，她竟然忘记自己都没有吃过饭。她太过于用心了！</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">我记得当 50cent 第一次当电影导演的时候，我采访过他！他当时说他如果不在做电影的时候，也一定是在做他的录音带！然后就有人问他：50cent，你什么时候睡觉？</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">50cent 说：睡觉？只有破产的人才睡觉，我不睡觉，因为我现在有了一个实现梦想的机会！</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">不要哭泣不要想到放弃！你已经感受过疼痛，已经受过伤，争取得到奖赏吧！不要去睡觉，那是一种不成功的表现。小子，听着，我今天告诉你：50cent 你可以做自己想做的任何事，你可以随意的逛来逛去，花钱的时候你也可以花得很兴奋。但如果你没有狠狠地逼自己一把的话，你就不是成功的。</span></p>\n\n<p><span style=\"color:rgb(99,107,111);\">直到你不会再安慰自己说，其实我不需要那些钱，我已经拥有了我想要的一切！</span></p>',2,5,0,2,0,0,1,'2020-05-07 22:02:04','2020-05-13 18:25:29'),(61,'大规格文件的上传优化','在开发过程中，收到这样一个问题反馈，在网站上传 100 MB 以上的文件经常失败，重试也要等老半天，这就难为需要上传大规格文件的用户了。那么应该怎么做才能快速上传，就算失败了再次发送也能从上次中断的地方继续上...','upload-optimization-of-large-size-files','<blockquote><p><span style=\"color:rgb(102,102,102);\">在开发过程中，收到这样一个问题反馈，在网站上传 100 MB 以上的文件经常失败，重试也要等老半天，这就难为需要上传大规格文件的用户了。那么应该怎么做才能快速上传，就算失败了再次发送也能从上次中断的地方继续上传呢？下文为你揭晓答案~</span><br /></p></blockquote><p>整体思路</p>\n\n<p>第一步是结合项目背景，调研比较优化的解决方案。文件上传失败是老生常谈的问题，常用方案是将一个大文件切片成多个小文件，并行请求接口进行上传，所有请求得到响应后，在服务器端合并所有的分片文件。当分片上传失败，可以在重新上传时进行判断，只上传上次失败的部分，减少用户的等待时间，缓解服务器压力。这就是分片上传文件。</p>\n\n<p> </p>\n\n<ul><li><a href=\"https://juejin.im/post/5ebb4346e51d451ef53793ad#heading-1\">大文件上传</a><ul><li><a href=\"https://juejin.im/post/5ebb4346e51d451ef53793ad#heading-2\">1. 文件 MD5 加密</a></li><li><a href=\"https://juejin.im/post/5ebb4346e51d451ef53793ad#heading-3\">2. 查询文件状态</a></li><li><a href=\"https://juejin.im/post/5ebb4346e51d451ef53793ad#heading-4\">3. 文件分片</a></li><li><a href=\"https://juejin.im/post/5ebb4346e51d451ef53793ad#heading-5\">4. 上传分片</a></li><li><a href=\"https://juejin.im/post/5ebb4346e51d451ef53793ad#heading-6\">5. 上传进度</a></li><li><a href=\"https://juejin.im/post/5ebb4346e51d451ef53793ad#heading-7\">6. 合并分片</a></li></ul></li></ul>\n\n<p>本文讲述了大规格文件上传优化的一些做法，总结为以下 4 点：</p>\n\n<ol><li>Blob.slice 将文件切片，并发上传多个切片，所有切片上传后告知服务器合并，实现大文件分片上传；</li><li>原生 XMLHttpRequest 的 onprogress 对切片上传进度的监听，实时获取文件上传进度；</li><li>spark-md5 根据文件内容算出文件 MD5，得到文件唯一标识，与文件上传状态绑定；</li><li>分片上传前通过文件 MD5 查询已上传切片列表，上传时只上传未上传过的切片，实现断点续传。</li></ol>\n\n<p> </p>',10,1,0,0,0,0,1,'2020-05-13 19:25:49','2020-05-13 19:25:49'),(62,'前端必备的 web 安全知识手记','前端必备的 web 安全知识手记 前言 安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持...','the-essential-knowledge-of-web-security-in-the-front-end','<p>前端必备的 web 安全知识手记</p>\n\n<h2>前言</h2>\n\n<p>安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持、SQL 注入和上传问题等（下文以小王代指攻击者），话不多说，我们直接开车?（附带的例子浅显易懂哦?）。</p>\n\n<p><br /></p>\n\n<h2>XSS（Cross-site scripting）</h2>\n\n<p>XSS 中文叫做跨站脚本攻击。<br />一句话解释：小王在网页中注入恶意代码，当用户访问页面时，代码会自动运行。<br />具体点说：凡是在页面中可输入的地方（如地址栏、搜索框和评论区等等）都有隐藏的风险，小王可以在这些地方输入一些特殊的代码（形如 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>），于是乎本来只是单纯的文本变成了可执行的代码，从而造成了攻击。你可能会觉得 <code>alert(1)</code> 能有多大点事，但把它换成别的威力就不一样了，它可以重定向到一个由小王控制的页面、冒充用户发送请求、窃取用户信息发送到小王的服务器上等等。当然了，这还不够具体，例子才是最直白的?。</p>\n\n<h3>举个栗子</h3>\n\n<p>因为 XSS 攻击有反射型、存储型和 DOM 型三种类型，所以我们每种都举个简单的栗子?：</p>\n\n<h4>反射型</h4>\n\n<p>反射型 XSS 主要有以下两个步骤：</p>\n\n<ol><li>假设我们访问一个 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a></code> 页面，后端会把其中的 <code>name</code> 参数取出来并拼接到 html 中（形如 <code>&lt;p&gt;你好啊，hh&lt;/p&gt;</code>）返回给用户。</li><li>这时如果我们访问 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a>&lt;script&gt;alert(1)&lt;/script&gt;</code> 页面，此时后端会返回形如 <code>&lt;p&gt;你好啊，hh&lt;script&gt;alert(1)&lt;/script&gt;&lt;/p&gt;</code> 这样的一个 html，其中的 script 脚本就会在我们的浏览器上加载执行，从而造成攻击。</li></ol>\n\n<p>你可能会觉得这种 url 看起来就有嫌疑，我们一般不访问，但如果把这个 url 转成一个短网址（所谓短网址就是把 url 转成一个 看起来简约又正常的链接），并在网上散播（通常伴随一些美女图片、外挂和金钱?等一些具有诱惑力的内容），从而骗取用户点击这个 url，造成攻击。所以日常生活中不要乱扫二维码、乱点链接。</p>\n\n<p> </p>\n\n<h4>存储型</h4>\n\n<p>这种类型一般出现在评论区、论坛、留言等类似的地方，基本流程是小王提交了一个恶意评论（就是包含一些恶意代码，和上面类似，形如这样的评论 <code>&lt;img src=\"1\" onerror=\"alert(1)\" /&gt;</code>），只不过该评论被保存到了数据库中，而评论对大家又都是可见的，所以任何用户访问该页面时，恶意代码就会从数据库中取出，拼接在 html 中返回给用户，页面加载评论的同时也执行了其中的恶意代码。与反射型相比，存储型的辐射范围更加广泛，处理起来也较为麻烦，有时还需要查好多库删好几张表。</p>\n\n<p> </p>\n\n<h4>DOM 型</h4>\n\n<p>典型的例子就是你连接了一个公共 wifi，浏览页面的时候在底部或者四周有时会有一些小广告的出现，因为这种网络劫持会动态修改页面的内容，比如在 html 中追加一些广告或暗链（暗链就是偷偷加入几个 a 标签，一般可用来增加搜索排名），要注意的是这种攻击是不涉及到服务器的，它的核心是动态修改 dom。</p>\n\n<h3>小小总结</h3>\n\n<p>总的来说就是页面可输入或拼接显示的地方就可能会有潜在的风险。 <span style=\"color:rgb(51,51,51);\">作为前端平时要注意 innerHTML 等一些有字符串拼接并展示的地方。</span></p>\n\n<p><span style=\"color:rgb(51,51,51);\"><br /></span></p>\n\n<h3>防御措施</h3>\n\n<h4>转义和过滤：</h4>\n\n<p>一般来可以使用编码或转义的方式来防御 XSS 攻击。<span style=\"color:rgb(51,51,51);\">对于富文本内容，因为其需要保留 html，所以不好直接使用转义的方法，通常使用白名单过滤（就是允许特定的 html 标签和属性），以抵御 XSS 攻击。当然了更不要相信用户的任何输入，对用户的输入进行特殊字符（如尖括号）的检查也是有必要的。</span></p>',9,1,0,0,0,0,1,'2020-05-13 19:39:25','2020-05-13 19:39:25'),(63,'前端必备的 web 安全知识手记','前端必备的 web 安全知识手记 前言 安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持...','the-essential-knowledge-of-web-security-in-the-front-end','<p>前端必备的 web 安全知识手记</p>\n\n<h2>前言</h2>\n\n<p>安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持、SQL 注入和上传问题等（下文以小王代指攻击者），话不多说，我们直接开车?（附带的例子浅显易懂哦?）。</p>\n\n<p><br /></p>\n\n<h2>XSS（Cross-site scripting）</h2>\n\n<p>XSS 中文叫做跨站脚本攻击。<br />一句话解释：小王在网页中注入恶意代码，当用户访问页面时，代码会自动运行。<br />具体点说：凡是在页面中可输入的地方（如地址栏、搜索框和评论区等等）都有隐藏的风险，小王可以在这些地方输入一些特殊的代码（形如 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>），于是乎本来只是单纯的文本变成了可执行的代码，从而造成了攻击。你可能会觉得 <code>alert(1)</code> 能有多大点事，但把它换成别的威力就不一样了，它可以重定向到一个由小王控制的页面、冒充用户发送请求、窃取用户信息发送到小王的服务器上等等。当然了，这还不够具体，例子才是最直白的?。</p>\n\n<h3>举个栗子</h3>\n\n<p>因为 XSS 攻击有反射型、存储型和 DOM 型三种类型，所以我们每种都举个简单的栗子?：</p>\n\n<h4>反射型</h4>\n\n<p>反射型 XSS 主要有以下两个步骤：</p>\n\n<ol><li>假设我们访问一个 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a></code> 页面，后端会把其中的 <code>name</code> 参数取出来并拼接到 html 中（形如 <code>&lt;p&gt;你好啊，hh&lt;/p&gt;</code>）返回给用户。</li><li>这时如果我们访问 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a>&lt;script&gt;alert(1)&lt;/script&gt;</code> 页面，此时后端会返回形如 <code>&lt;p&gt;你好啊，hh&lt;script&gt;alert(1)&lt;/script&gt;&lt;/p&gt;</code> 这样的一个 html，其中的 script 脚本就会在我们的浏览器上加载执行，从而造成攻击。</li></ol>\n\n<p>你可能会觉得这种 url 看起来就有嫌疑，我们一般不访问，但如果把这个 url 转成一个短网址（所谓短网址就是把 url 转成一个 看起来简约又正常的链接），并在网上散播（通常伴随一些美女图片、外挂和金钱?等一些具有诱惑力的内容），从而骗取用户点击这个 url，造成攻击。所以日常生活中不要乱扫二维码、乱点链接。</p>\n\n<p> </p>\n\n<h4>存储型</h4>\n\n<p>这种类型一般出现在评论区、论坛、留言等类似的地方，基本流程是小王提交了一个恶意评论（就是包含一些恶意代码，和上面类似，形如这样的评论 <code>&lt;img src=\"1\" onerror=\"alert(1)\" /&gt;</code>），只不过该评论被保存到了数据库中，而评论对大家又都是可见的，所以任何用户访问该页面时，恶意代码就会从数据库中取出，拼接在 html 中返回给用户，页面加载评论的同时也执行了其中的恶意代码。与反射型相比，存储型的辐射范围更加广泛，处理起来也较为麻烦，有时还需要查好多库删好几张表。</p>\n\n<p> </p>\n\n<h4>DOM 型</h4>\n\n<p>典型的例子就是你连接了一个公共 wifi，浏览页面的时候在底部或者四周有时会有一些小广告的出现，因为这种网络劫持会动态修改页面的内容，比如在 html 中追加一些广告或暗链（暗链就是偷偷加入几个 a 标签，一般可用来增加搜索排名），要注意的是这种攻击是不涉及到服务器的，它的核心是动态修改 dom。</p>\n\n<h3>小小总结</h3>\n\n<p>总的来说就是页面可输入或拼接显示的地方就可能会有潜在的风险。 <span style=\"color:rgb(51,51,51);\">作为前端平时要注意 innerHTML 等一些有字符串拼接并展示的地方。</span></p>\n\n<p><span style=\"color:rgb(51,51,51);\"><br /></span></p>\n\n<h3>防御措施</h3>\n\n<h4>转义和过滤：</h4>\n\n<p>一般来可以使用编码或转义的方式来防御 XSS 攻击。<span style=\"color:rgb(51,51,51);\">对于富文本内容，因为其需要保留 html，所以不好直接使用转义的方法，通常使用白名单过滤（就是允许特定的 html 标签和属性），以抵御 XSS 攻击。当然了更不要相信用户的任何输入，对用户的输入进行特殊字符（如尖括号）的检查也是有必要的。</span></p>',9,1,0,0,0,0,1,'2020-05-13 19:39:38','2020-05-13 19:39:38'),(64,'前端必备的 web 安全知识手记','前端必备的 web 安全知识手记 前言 安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持...','the-essential-knowledge-of-web-security-in-the-front-end','<p>前端必备的 web 安全知识手记</p>\n\n<h2>前言</h2>\n\n<p>安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持、SQL 注入和上传问题等（下文以小王代指攻击者），话不多说，我们直接开车?（附带的例子浅显易懂哦?）。</p>\n\n<p><br /></p>\n\n<h2>XSS（Cross-site scripting）</h2>\n\n<p>XSS 中文叫做跨站脚本攻击。<br />一句话解释：小王在网页中注入恶意代码，当用户访问页面时，代码会自动运行。<br />具体点说：凡是在页面中可输入的地方（如地址栏、搜索框和评论区等等）都有隐藏的风险，小王可以在这些地方输入一些特殊的代码（形如 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>），于是乎本来只是单纯的文本变成了可执行的代码，从而造成了攻击。你可能会觉得 <code>alert(1)</code> 能有多大点事，但把它换成别的威力就不一样了，它可以重定向到一个由小王控制的页面、冒充用户发送请求、窃取用户信息发送到小王的服务器上等等。当然了，这还不够具体，例子才是最直白的?。</p>\n\n<h3>举个栗子</h3>\n\n<p>因为 XSS 攻击有反射型、存储型和 DOM 型三种类型，所以我们每种都举个简单的栗子?：</p>\n\n<h4>反射型</h4>\n\n<p>反射型 XSS 主要有以下两个步骤：</p>\n\n<ol><li>假设我们访问一个 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a></code> 页面，后端会把其中的 <code>name</code> 参数取出来并拼接到 html 中（形如 <code>&lt;p&gt;你好啊，hh&lt;/p&gt;</code>）返回给用户。</li><li>这时如果我们访问 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a>&lt;script&gt;alert(1)&lt;/script&gt;</code> 页面，此时后端会返回形如 <code>&lt;p&gt;你好啊，hh&lt;script&gt;alert(1)&lt;/script&gt;&lt;/p&gt;</code> 这样的一个 html，其中的 script 脚本就会在我们的浏览器上加载执行，从而造成攻击。</li></ol>\n\n<p>你可能会觉得这种 url 看起来就有嫌疑，我们一般不访问，但如果把这个 url 转成一个短网址（所谓短网址就是把 url 转成一个 看起来简约又正常的链接），并在网上散播（通常伴随一些美女图片、外挂和金钱?等一些具有诱惑力的内容），从而骗取用户点击这个 url，造成攻击。所以日常生活中不要乱扫二维码、乱点链接。</p>\n\n<p> </p>\n\n<h4>存储型</h4>\n\n<p>这种类型一般出现在评论区、论坛、留言等类似的地方，基本流程是小王提交了一个恶意评论（就是包含一些恶意代码，和上面类似，形如这样的评论 <code>&lt;img src=\"1\" onerror=\"alert(1)\" /&gt;</code>），只不过该评论被保存到了数据库中，而评论对大家又都是可见的，所以任何用户访问该页面时，恶意代码就会从数据库中取出，拼接在 html 中返回给用户，页面加载评论的同时也执行了其中的恶意代码。与反射型相比，存储型的辐射范围更加广泛，处理起来也较为麻烦，有时还需要查好多库删好几张表。</p>\n\n<p> </p>\n\n<h4>DOM 型</h4>\n\n<p>典型的例子就是你连接了一个公共 wifi，浏览页面的时候在底部或者四周有时会有一些小广告的出现，因为这种网络劫持会动态修改页面的内容，比如在 html 中追加一些广告或暗链（暗链就是偷偷加入几个 a 标签，一般可用来增加搜索排名），要注意的是这种攻击是不涉及到服务器的，它的核心是动态修改 dom。</p>\n\n<h3>小小总结</h3>\n\n<p>总的来说就是页面可输入或拼接显示的地方就可能会有潜在的风险。 <span style=\"color:rgb(51,51,51);\">作为前端平时要注意 innerHTML 等一些有字符串拼接并展示的地方。</span></p>\n\n<p><span style=\"color:rgb(51,51,51);\"><br /></span></p>\n\n<h3>防御措施</h3>\n\n<h4>转义和过滤：</h4>\n\n<p>一般来可以使用编码或转义的方式来防御 XSS 攻击。<span style=\"color:rgb(51,51,51);\">对于富文本内容，因为其需要保留 html，所以不好直接使用转义的方法，通常使用白名单过滤（就是允许特定的 html 标签和属性），以抵御 XSS 攻击。当然了更不要相信用户的任何输入，对用户的输入进行特殊字符（如尖括号）的检查也是有必要的。</span></p>',9,1,0,0,0,0,1,'2020-05-13 19:40:15','2020-05-13 19:40:15'),(65,'前端必备的 web 安全知识手记','前端必备的 web 安全知识手记 前言 安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持...','the-essential-knowledge-of-web-security-in-the-front-end','<p>前端必备的 web 安全知识手记</p>\n\n<h2>前言</h2>\n\n<p>安全这种东西就是不发生则已，一发生则惊人。作为前端，平时对这方面的知识没啥研究，最近了解了下，特此沉淀。文章内容包括以下几个典型的 web 安全知识点：XSS、CSRF、点击劫持、SQL 注入和上传问题等（下文以小王代指攻击者），话不多说，我们直接开车?（附带的例子浅显易懂哦?）。</p>\n\n<p><br /></p>\n\n<h2>XSS（Cross-site scripting）</h2>\n\n<p>XSS 中文叫做跨站脚本攻击。<br />一句话解释：小王在网页中注入恶意代码，当用户访问页面时，代码会自动运行。<br />具体点说：凡是在页面中可输入的地方（如地址栏、搜索框和评论区等等）都有隐藏的风险，小王可以在这些地方输入一些特殊的代码（形如 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code>），于是乎本来只是单纯的文本变成了可执行的代码，从而造成了攻击。你可能会觉得 <code>alert(1)</code> 能有多大点事，但把它换成别的威力就不一样了，它可以重定向到一个由小王控制的页面、冒充用户发送请求、窃取用户信息发送到小王的服务器上等等。当然了，这还不够具体，例子才是最直白的?。</p>\n\n<h3>举个栗子</h3>\n\n<p>因为 XSS 攻击有反射型、存储型和 DOM 型三种类型，所以我们每种都举个简单的栗子?：</p>\n\n<h4>反射型</h4>\n\n<p>反射型 XSS 主要有以下两个步骤：</p>\n\n<ol><li>假设我们访问一个 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a></code> 页面，后端会把其中的 <code>name</code> 参数取出来并拼接到 html 中（形如 <code>&lt;p&gt;你好啊，hh&lt;/p&gt;</code>）返回给用户。</li><li>这时如果我们访问 <code><a href=\"http://www.a.com/?name=hh\">www.a.com/?name=hh</a>&lt;script&gt;alert(1)&lt;/script&gt;</code> 页面，此时后端会返回形如 <code>&lt;p&gt;你好啊，hh&lt;script&gt;alert(1)&lt;/script&gt;&lt;/p&gt;</code> 这样的一个 html，其中的 script 脚本就会在我们的浏览器上加载执行，从而造成攻击。</li></ol>\n\n<p>你可能会觉得这种 url 看起来就有嫌疑，我们一般不访问，但如果把这个 url 转成一个短网址（所谓短网址就是把 url 转成一个 看起来简约又正常的链接），并在网上散播（通常伴随一些美女图片、外挂和金钱?等一些具有诱惑力的内容），从而骗取用户点击这个 url，造成攻击。所以日常生活中不要乱扫二维码、乱点链接。</p>\n\n<p> </p>\n\n<h4>存储型</h4>\n\n<p>这种类型一般出现在评论区、论坛、留言等类似的地方，基本流程是小王提交了一个恶意评论（就是包含一些恶意代码，和上面类似，形如这样的评论 <code>&lt;img src=\"1\" onerror=\"alert(1)\" /&gt;</code>），只不过该评论被保存到了数据库中，而评论对大家又都是可见的，所以任何用户访问该页面时，恶意代码就会从数据库中取出，拼接在 html 中返回给用户，页面加载评论的同时也执行了其中的恶意代码。与反射型相比，存储型的辐射范围更加广泛，处理起来也较为麻烦，有时还需要查好多库删好几张表。</p>\n\n<p> </p>\n\n<h4>DOM 型</h4>\n\n<p>典型的例子就是你连接了一个公共 wifi，浏览页面的时候在底部或者四周有时会有一些小广告的出现，因为这种网络劫持会动态修改页面的内容，比如在 html 中追加一些广告或暗链（暗链就是偷偷加入几个 a 标签，一般可用来增加搜索排名），要注意的是这种攻击是不涉及到服务器的，它的核心是动态修改 dom。</p>\n\n<h3>小小总结</h3>\n\n<p>总的来说就是页面可输入或拼接显示的地方就可能会有潜在的风险。 <span style=\"color:rgb(51,51,51);\">作为前端平时要注意 innerHTML 等一些有字符串拼接并展示的地方。</span></p>\n\n<p><span style=\"color:rgb(51,51,51);\"><br /></span></p>\n\n<h3>防御措施</h3>\n\n<h4>转义和过滤：</h4>\n\n<p>一般来可以使用编码或转义的方式来防御 XSS 攻击。<span style=\"color:rgb(51,51,51);\">对于富文本内容，因为其需要保留 html，所以不好直接使用转义的方法，通常使用白名单过滤（就是允许特定的 html 标签和属性），以抵御 XSS 攻击。当然了更不要相信用户的任何输入，对用户的输入进行特殊字符（如尖括号）的检查也是有必要的。</span></p>',9,1,0,0,0,0,1,'2020-05-13 19:43:41','2020-05-13 19:43:41'),(66,'一位前端小姐姐的进阶笔记','三、写一个简易的打包工具 1. 前言 不知道有没有人和我一样，不管看了几遍文档，还是不会自己写 webpack，只能在别人写的配置上修修补补，更别提什么优化了。于是我痛定思痛，决定从源头上解决这个问题！为了更好地...','advanced-notes-of-a-front-end-little-sister','<p>三、写一个简易的打包工具</p>\n\n<h2>1. 前言</h2>\n\n<p>不知道有没有人和我一样，不管看了几遍文档，还是不会自己写 webpack，只能在别人写的配置上修修补补，更别提什么优化了。<br />于是我痛定思痛，决定从源头上解决这个问题！为了更好地应用 webpack，我们应该了解它背后的工作原理。<br />因此，我阅读了 <a href=\"https://github.com/ronami/minipack/blob/master/src/minipack.js\">miniwebpack</a> 这个仓库。这个仓库实现了一个最简单的打包工具。接下来我会按照我的理解来解释一下怎么实现一个简单的打包工具</p>\n\n<h2>2. 主要思路</h2>\n\n<ol><li>代码处理。我们平常写代码的时候，用的可能是ES6、ES7等高版本的语法，我们需要将它们转换成浏览器能运行的语法</li><li>打包。需要根据一个 entry 来输出一个 output，我们通过维护一个依赖关系图来解决这个问题</li></ol>\n\n<p><img alt=\"图1：流程图.png\" src=\"https://user-gold-cdn.xitu.io/2020/5/11/172044237fa8f4bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" /></p>\n\n<h2>3. 代码处理</h2>\n\n<ol><li>解析（parse）。将源代码变成AST。</li><li>转换（transform）。操作AST，这也是我们可以操作的部分，去改变代码。</li><li>生成（generate）。将更改后的AST，再变回代码。</li></ol>\n\n<blockquote><p>参考：<a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-stages-of-babel\">Babel用户手册</a></p></blockquote>\n\n<p>下面我将介绍一些这个过程中需要用到的工具。</p>\n\n<h3>3.1 解析器 babylon</h3>\n\n<p>用来将源代码转换为 AST。<br />（不了解 AST 的，可以先看看<a href=\"https://astexplorer.net/\">在线AST转换器</a>。）</p>\n\n<h4>3.1.1 安装</h4>\n\n<pre><code>npm install --save babylon\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>3.1.2  使用</h4>\n\n<pre><code><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> babylon <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"babylon\"</span>;\n\nbabylon.parse(code, [options])\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h3>3.2 转换器 babel-traverse</h3>\n\n<p>用来操作 AST</p>\n\n<h4>3.2.1 安装</h4>\n\n<pre><code>npm install --save babel-traverse\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>3.2.2 使用</h4>\n\n<p>该模块仅暴露出一个 traverse 方法。traverse 方法是一个遍历方法， path 封装了每一个节点，并且还提供容器 container ，作用域 scope 这样的字段。提供个更多关于节点的相关的信息，让我们更好的操作节点。<br />示例：</p>\n\n<pre><code><span class=\"hljs-comment\">// </span>\n<span class=\"hljs-keyword\">import</span> traverse <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"babel-traverse\"</span>;\n\ntraverse(ast, {\n  enter(path) {\n    <span class=\"hljs-keyword\">if</span> (path.node.type === <span class=\"hljs-string\">\"Identifier\"</span>\n      &amp;&amp; path.node.name === <span class=\"hljs-string\">\'text\'</span>) {\n      path.node.name = <span class=\"hljs-string\">\'alteredText\'</span>;\n    }\n  }\n})\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h3>3.3 生成器 babel-generator</h3>\n\n<p>可以根据 AST 生成代码</p>\n\n<h4>3.3.1 安装</h4>\n\n<pre><code>npm install --save babel-generator\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>3.3.2 使用</h4>\n\n<pre><code><span class=\"hljs-keyword\">import</span> generate <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"babel-generator\"</span>;\n\n<span class=\"hljs-keyword\">const</span> genCode = generate(ast, {}, code);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>4. 实现细节</h2>\n\n<h3>4.1 第一步，提取某文件的依赖</h3>\n\n<p>最开始我们提到，需要构建一个依赖关系图。那么我们先从第一步开始，实现根据某个文件（输入绝对路径）提取依赖。大致可以分成以下几步：</p>\n\n<ol><li>读取文件内容</li><li>生成 AST</li><li>遍历 AST 来理解这个模块依赖哪些模块</li><li>为该模块分配唯一标识符</li><li>使代码支持所有浏览器</li></ol>\n\n<h4>4.1.1 读取文件内容</h4>\n\n<p>我们用 node.js 的 <code>fs</code> 模块就可以</p>\n\n<pre><code><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'fs\'</span>);\n<span class=\"hljs-keyword\">const</span> content = fs.readFileSync(filename, <span class=\"hljs-string\">\'utf-8\'</span>);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>4.1.2 生成 AST</h4>\n\n<p>用到我们之前提到的 babylon</p>\n\n<pre><code><span class=\"hljs-keyword\">const</span> ast = babylon.parse(content, {\n  <span class=\"hljs-attr\">sourceType</span>: <span class=\"hljs-string\">\'module\'</span>,\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>4.1.3 遍历 AST 来试着理解这个模块依赖哪些模块</h4>\n\n<p>这里我们需要操作 AST，所以用到 babel-traverse</p>\n\n<pre><code><span class=\"hljs-keyword\">const</span> dependencies = [];\n<span class=\"hljs-comment\">// 要做到这一点,我们检查`ast`中的每个 `import` 声明.</span>\ntraverse(ast, {\n<span class=\"hljs-comment\">// `Ecmascript`模块相当简单,因为它们是静态的. 这意味着你不能`import`一个变量,</span>\n<span class=\"hljs-comment\">// 或者有条件地`import`另一个模块. </span>\n<span class=\"hljs-comment\">// 每次我们看到`import`声明时,我们都可以将其数值视为`依赖性`.</span>\n  ImportDeclaration: <span class=\"hljs-function\">(<span class=\"hljs-params\">{node}</span>) =&gt;</span> {\n    dependencies.push(node.source.value);\n  },\n});\n\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>4.1.4 为模块分配唯一标识符</h4>\n\n<p>我们简单地用 id 表示</p>\n\n<pre><code>// 递增简单计数器\nconst id = ID++;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>4.1.5 使代码支持所有浏览器</h4>\n\n<p>使用 <a href=\"https://www.babeljs.cn/docs/\">babel</a></p>\n\n<pre><code><span class=\"hljs-keyword\">const</span> {transformFromAst} = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'babel-core\'</span>);\n\n<span class=\"hljs-comment\">// 该`presets`选项是一组规则,告诉`babel`如何传输我们的代码. </span>\n<span class=\"hljs-comment\">// 我们用`babel-preset-env``将我们的代码转换为浏览器可以运行的东西. </span>\n<span class=\"hljs-keyword\">const</span> {code} = transformFromAst(ast, <span class=\"hljs-literal\">null</span>, {\n  <span class=\"hljs-attr\">presets</span>: [<span class=\"hljs-string\">\'env\'</span>],\n});\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>那么 code 到底长什么样呢</p>\n\n<blockquote><ol><li>首先，babel 能将 es6 等更新的代码转成浏览器能执行的低版本代码，这个之前一直在强调的</li><li>其次，对于模块的转换。Babel 对 ES6 模块转码就是转换成 CommonJS 规范<br />Babel 对于模块输出的转换，就是把所有输出都赋值到 exports 对象的属性上，并加上 ESModule: true 的标识。表示这个模块是由 ESModule 转换来的 CommonJS 输出输入就是 require</li></ol></blockquote>\n\n<p>例如，对于以下文件</p>\n\n<pre><code><span class=\"hljs-comment\">// entry.js</span>\n<span class=\"hljs-keyword\">import</span> message <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./message.js\'</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(message);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<pre><code><span class=\"hljs-comment\">// message.js</span>\n<span class=\"hljs-keyword\">import</span> {name} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./name.js\'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-string\">`hello <span class=\"hljs-subst\">${name}</span>!`</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>按照上面的规范，转换后的代码大概是这样大概是这样：</p>\n\n<pre><code><span class=\"hljs-comment\">// entry.js</span>\n<span class=\"hljs-meta\">\"use strict\"</span>;\n<span class=\"hljs-keyword\">var</span> _message = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./message.js\"</span>);\n<span class=\"hljs-keyword\">var</span> _message2 = _interopRequireDefault(_message);\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_interopRequireDefault</span>(<span class=\"hljs-params\">obj</span>) </span>{ \n  <span class=\"hljs-keyword\">return</span> obj &amp;&amp; obj.__esModule ? obj : { <span class=\"hljs-attr\">default</span>: obj }; \n}\n<span class=\"hljs-built_in\">console</span>.log(_message2.default);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<pre><code><span class=\"hljs-comment\">// message.js</span>\n<span class=\"hljs-meta\">\"use strict\"</span>;\n\n<span class=\"hljs-comment\">// 加上 ESModule: true 的标识</span>\n<span class=\"hljs-built_in\">Object</span>.defineProperty(exports, <span class=\"hljs-string\">\"__esModule\"</span>, {\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">true</span>\n});\n<span class=\"hljs-keyword\">var</span> _name = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./name.js\"</span>);\n\n<span class=\"hljs-comment\">// 把所有输出都赋值到 exports 对象的属性上</span>\nexports.default = <span class=\"hljs-string\">\"hello \"</span> + _name.name + <span class=\"hljs-string\">\"!\"</span>; \n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>4.1.6 返回模块信息</h4>\n\n<pre><code><span class=\"hljs-keyword\">return</span> {\n  id,\n  filename,\n  dependencies,\n  code,\n};\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>以上，我们就处理好了一个模块。包含着以下 4 项信息</p>\n\n<ul><li>模块 id</li><li>文件的绝对路径</li><li>该模块的依赖。保存着的是依赖们的相对路径</li><li>该模块内部代码（浏览器可运行）</li></ul>\n\n<h3>4.2 第二步，生成依赖图</h3>\n\n<p>通过第一步，我们已经能生成某个模块的依赖了。接下来，我们就可以顺藤摸瓜，从入口文件开始，生成入口文件的依赖，再生成入口文件的依赖的依赖，再生成入口文件的依赖的依赖依...（禁止套娃），直到所有模块处理完毕</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\'path\'</span>);\n\n<span class=\"hljs-comment\">// entry 为入口文件的路径</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createGraph</span>(<span class=\"hljs-params\">entry</span>) </span>{\n\n  <span class=\"hljs-comment\">// createAsset 是我们在【第一步，提取某文件的依赖】中实现的函数</span>\n  <span class=\"hljs-comment\">// mainAsset 就是入口模块的信息了</span>\n  <span class=\"hljs-keyword\">const</span> mainAsset = createAsset(entry);\n\n  <span class=\"hljs-comment\">// 使用一个队列，刚开始只有入口模块</span>\n  <span class=\"hljs-keyword\">const</span> queue = [mainAsset];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> asset <span class=\"hljs-keyword\">of</span> queue) {\n    \n    <span class=\"hljs-comment\">// mapping 用来将【依赖的相对路径】映射到【该依赖的模块 id】</span>\n    asset.mapping = {};\n\n    <span class=\"hljs-comment\">// 这个模块所在的目录. </span>\n    <span class=\"hljs-keyword\">const</span> dirname = path.dirname(asset.filename);\n\n    <span class=\"hljs-comment\">// 遍历每一个依赖。</span>\n    asset.dependencies.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">relativePath</span> =&gt;</span> {\n\n      <span class=\"hljs-comment\">// 得到依赖的绝对路径</span>\n      <span class=\"hljs-keyword\">const</span> absolutePath = path.join(dirname, relativePath);\n\n      <span class=\"hljs-comment\">// 得到 child 的模块信息</span>\n      <span class=\"hljs-keyword\">const</span> child = createAsset(absolutePath);\n\n      <span class=\"hljs-comment\">// 将【依赖的相对路径】映射到【该依赖的模块 id】</span>\n      <span class=\"hljs-comment\">// 因为如果不做映射。最终打包到一个文件后，编码时的相对路径就不管用了。我们就没法知道像 require(\'./child\') 这种代码到底应该加载哪一个模块</span>\n      asset.mapping[relativePath] = child.id;\n\n      <span class=\"hljs-comment\">// 把这个子模块也放进队列里面</span>\n      queue.push(child);\n    });\n  }\n\n<span class=\"hljs-comment\">// 到这一步,队列 就是一个包含目标应用中 每个模块 的数组</span>\n<span class=\"hljs-comment\">// 实际上这个就是我们最终的依赖关系图了</span>\n  <span class=\"hljs-keyword\">return</span> queue;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>对于以下文件</p>\n\n<pre><code><span class=\"hljs-comment\">// ./example/entry.js</span>\n<span class=\"hljs-keyword\">import</span> message <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./message.js\'</span>;\n\n<span class=\"hljs-built_in\">console</span>.log(message);\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<pre><code><span class=\"hljs-comment\">// ./example/message.js</span>\n<span class=\"hljs-keyword\">import</span> {name} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./name.js\'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-string\">`hello <span class=\"hljs-subst\">${name}</span>!`</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<pre><code><span class=\"hljs-comment\">// ./example/name.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">\'world\'</span>;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>我们处理后的依赖关系图应该是这样的</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n[{\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">\'./example/entry.js\'</span>,\n    <span class=\"hljs-attr\">dependencies</span>: [<span class=\"hljs-string\">\'./message.js\'</span>],\n    <span class=\"hljs-attr\">code</span>: ,<span class=\"hljs-comment\">// 略</span>\n    mapping: {\n        <span class=\"hljs-string\">\'./message.js\'</span>: <span class=\"hljs-number\">1</span>\n    }\n}, {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">\'./example/message.js\'</span>,\n    <span class=\"hljs-attr\">dependencies</span>: [<span class=\"hljs-string\">\'./name.js\'</span>],\n    <span class=\"hljs-attr\">code</span>: ,<span class=\"hljs-comment\">// 略</span>\n    mapping: {\n        <span class=\"hljs-string\">\'./name.js\'</span>: <span class=\"hljs-number\">2</span>\n    }\n}, {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">filename</span>: <span class=\"hljs-string\">\'./example/name.js\'</span>,\n    <span class=\"hljs-attr\">dependencies</span>: [],\n    <span class=\"hljs-attr\">code</span>: ,<span class=\"hljs-comment\">// 略</span>\n    mapping: {}\n}]\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h3>4.3 第三步，根据依赖图生成代码</h3>\n\n<p>目前，我们已经有了依赖图</p>\n\n<pre><code>graph: Module[]\n\n<span class=\"hljs-keyword\">interface</span> Module {\n  id: <span class=\"hljs-built_in\">number</span> <span class=\"hljs-comment\">// 模块id；在【提取某文件的依赖】这一步中我们使用的是一个递增的 id</span>\n  filename: <span class=\"hljs-built_in\">string</span> \n  dependencies: Module[]\n  code: <span class=\"hljs-built_in\">string</span> <span class=\"hljs-comment\">// 该模块的代码（经过转换的，能在浏览器中运行） </span>\n  mapping: Record&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>&gt; <span class=\"hljs-comment\">// 将依赖的相对路径转换成id。是我们在【生成依赖图】这一步所做的工作</span>\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>既然已经到了这一步了，就说明我们得处理一下 <code>code</code> 了。在【使代码支持所有浏览器】这一步中，我们已经知道了，<code>code</code> 是符合 CommonJS 规范的。但CommonJS 中有以下几个东西，是浏览器中没有的：</p>\n\n<ul><li>require</li><li>module</li><li>exports</li></ul>\n\n<p>那么接下来就是我们自己实现这3个东西！</p>\n\n<p>首先把咱目前的模块信息整合一下：</p>\n\n<ul><li>mapping 是肯定要的。因为我们模块的被转换后会通过相对路径来调用 require() ，而我们需要知道对应去加载哪个模块</li><li>code 需要稍微改一下。每个模块的作用域应该是独立的。所以我们改成这样：<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">require, module, exports</span>) </span>{ \n  {code}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre></li></ul>\n\n<p>最终把所有这样的模块放在 modules 中，大概是这样：</p>\n\n<pre><code><span class=\"hljs-comment\">/*\n  {0: [\n    function (require, module, exports) { \n      {code}\n    },\n    mapping: {\n      \'./message.js\': 1\n    }\n  ]}\n*/</span>\nmodules: Record&lt;<span class=\"hljs-built_in\">number</span>, [<span class=\"hljs-function\">(<span class=\"hljs-params\"><span class=\"hljs-built_in\">require</span>, <span class=\"hljs-built_in\">module</span>, exports</span>) =&gt;</span> <span class=\"hljs-built_in\">any</span>, Record&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">number</span>&gt;]&gt;\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>接下来我们写主程序，我们主程序要做的工作有</p>\n\n<ol><li>实现 <code>require</code>, <code>module</code>, <code>exports</code></li><li>默认调用入口文件</li><li>自执行</li></ol>\n\n<pre><code>微信公众号：世界上有意思的事\n\n(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">modules</span>) </span>{\n  \n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">require</span>(<span class=\"hljs-params\">id</span>) </span>{ \n    <span class=\"hljs-comment\">// 从 modules 拿到 【执行函数】和【mapping】</span>\n    <span class=\"hljs-keyword\">const</span> [fn, mapping] = modules[id];\n\n    <span class=\"hljs-comment\">// 自己实现的 require，可以根据相对路径加载依赖</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">localRequire</span>(<span class=\"hljs-params\">name</span>) </span>{ \n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">require</span>(mapping[name]); \n    }\n     \n    <span class=\"hljs-comment\">// // 自己实现的 module 和 exports</span>\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">module</span> = { <span class=\"hljs-attr\">exports</span> : {} };\n\n    fn(localRequire, <span class=\"hljs-built_in\">module</span>, <span class=\"hljs-built_in\">module</span>.exports); \n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">module</span>.exports;\n  }\n\n  <span class=\"hljs-comment\">// 调用入口文件</span>\n  <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-number\">0</span>);\n  \n})(modules)</code></pre>\n\n<p>作者：何时夕</p>\n\n<p>链接：<a href=\"https://juejin.im/post/5eb96904f265da7bac22503d\">https://juejin.im/post/5eb96904f265da7bac22503d</a></p>\n\n<p>来源：掘金</p>\n\n<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n\n<p><a href=\"https://thelastto.github.io/\">小姐姐的个人博客</a><br /></p>\n\n<p><br /></p><p>一、apply/call/bind 一网打尽</p>\n\n<p>首先，这三个方法是用来改变 this 指向的，接下来我们看一下它们的异同。</p>\n\n<h2>1. apply</h2>\n\n<ul><li>调用一个对象的一个方法，用另一个对象替换当前对象。例如：<code>B.apply(A, arguments)</code>; 即 A 对象应用 B 对象的方法。</li><li>要注意的是第一个参数，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，而其他原始值则会被相应的包装对象（wrapper object）所替代。</li></ul>\n\n<h3>1.1 如何实现一个apply</h3>\n\n<p>回顾一下 apply 的效果，我们可以大致按以下思路走</p>\n\n<ol><li>实现第一个参数的功能，改变 this 指向</li><li>实现第二个参数的功能。第二个参数是作为调用函数的参数</li><li>返回值：使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。</li></ol>\n\n<p>接下来，我们按以上思路来实现一下。</p>\n\n<h4>1.1.1 第一步，绑定 this</h4>\n\n<pre><code>微信公众号：世界上有意思的事\n\nf.apply(o);\n\n<span class=\"hljs-comment\">// 与下面代码的功能类似（假设对象o中预先不存在名为m的属性）。</span>\no.m=f; <span class=\"hljs-comment\">//将f存储为o的临时方法</span>\no.m(); <span class=\"hljs-comment\">//调用它，不传入参数</span>\n<span class=\"hljs-keyword\">delete</span> o.m;<span class=\"hljs-comment\">//将临时方法删除</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>(以上代码摘录自犀牛书)<br />依样画葫芦，我们可以这么写：</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-built_in\">Function</span>.prototype.apply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) </span>{\n    <span class=\"hljs-comment\">// context 就是需要绑定的对象，相当于上面的 o</span>\n    <span class=\"hljs-comment\">// this 就是调用了 apply 的函数，相当于 f</span>\n    context.__fn = <span class=\"hljs-keyword\">this</span> <span class=\"hljs-comment\">// 假设原先没有__fn</span>\n    context.__fn()\n    <span class=\"hljs-keyword\">delete</span> context.__fn\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>1.1.2 第二步，给函数传递参数</h4>\n\n<p>接下来我们想办法实现一下 apply 的第二个参数。其实我最快想到的是 ES6 的方法。用<code>...</code> 直接展开就行了。不过 apply 才 ES3?，还是再想想老的办法吧。</p>\n\n<p>难点是这个数组的长度是不确定的，也就是说我们没办法很准确地给函数一个个传参。我们所能做的处理也就是把<code>arguments</code>转成字符串形式<code>\'arguments[1], arguments[2], ...\'</code>。那么如何让字符串能运行起来呢？？答案就是 <code>eval</code>！</p>\n\n<p>稍稍总结一下, 目前想到的 2 种方法</p>\n\n<blockquote><ol><li>es6。<code>context.__fn(...arguments)</code></li><li>把 arguments 转换成string，放到 eval 里面运行 <code>eval(\'context.__fn(\'+ \'arguments[1], arguments[2]\' +\')\')</code></li></ol></blockquote>\n\n<p>以下是第二种思路的代码：</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-built_in\">Function</span>.prototype.apply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context, others</span>) </span>{\n    <span class=\"hljs-comment\">// context 就是需要绑定的对象，相当于上面的 o</span>\n    <span class=\"hljs-comment\">// this 就是调用了 apply 的函数，相当于 f</span>\n    context.__fn = <span class=\"hljs-keyword\">this</span> <span class=\"hljs-comment\">// 假设原先没有__fn</span>\n\n    <span class=\"hljs-keyword\">var</span> args = [];\n    <span class=\"hljs-comment\">// args: \'others[0], others[1], others[2], ...\'</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>, len = others.length; i &lt; len; i++) {\n        args.push(<span class=\"hljs-string\">\'others[\'</span> + i + <span class=\"hljs-string\">\']\'</span>);\n    }\n\n    <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\'context.__fn(\'</span> + args.toString() + <span class=\"hljs-string\">\')\'</span>)\n\n    <span class=\"hljs-keyword\">delete</span> context.__fn\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>1.1.3 第三步，返回值</h4>\n\n<p>返回函数调用后的结果就行：</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-built_in\">Function</span>.prototype.apply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context, others</span>) </span>{\n    <span class=\"hljs-comment\">// context 就是需要绑定的对象，相当于上面的 o</span>\n    <span class=\"hljs-comment\">// this 就是调用了 apply 的函数，相当于 f</span>\n    context.__fn = <span class=\"hljs-keyword\">this</span> <span class=\"hljs-comment\">// 假设原先没有__fn</span>\n\n    <span class=\"hljs-keyword\">var</span> result;\n\n    <span class=\"hljs-keyword\">var</span> args = [];\n    <span class=\"hljs-comment\">// args: \'others[0], others[1], others[2], ...\'</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>, len = others.length; i &lt; len; i++) {\n        args.push(<span class=\"hljs-string\">\'others[\'</span> + i + <span class=\"hljs-string\">\']\'</span>);\n    }\n\n    result = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\'context.__fn(\'</span> + args.toString() + <span class=\"hljs-string\">\')\'</span>)\n\n    <span class=\"hljs-keyword\">delete</span> context.__fn\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>1.1.4 更进一步，严格模式下的 this</h4>\n\n<p>我们之前有提到：第一个参数，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，而其他原始值则会被相应的包装对象（wrapper object）所替代</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-built_in\">Function</span>.prototype.apply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context, others</span>) </span>{\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> argsArray === <span class=\"hljs-string\">\'undefined\'</span> || argsArray === <span class=\"hljs-literal\">null</span>) {\n        context = <span class=\"hljs-built_in\">window</span>\n    }\n\n    <span class=\"hljs-comment\">// context 是一个 object</span>\n    context = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Object</span>(context)\n\n    <span class=\"hljs-comment\">// context 就是需要绑定的对象，相当于上面的 o</span>\n    <span class=\"hljs-comment\">// this 就是调用了 apply 的函数，相当于 f</span>\n    context.__fn = <span class=\"hljs-keyword\">this</span> <span class=\"hljs-comment\">// 假设原先没有__fn</span>\n\n    <span class=\"hljs-keyword\">var</span> result;\n\n    <span class=\"hljs-keyword\">var</span> args = [];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>, len = others.length; i &lt; len; i++) {\n        args.push(<span class=\"hljs-string\">\'others[\'</span> + i + <span class=\"hljs-string\">\']\'</span>);\n    }\n\n    result = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\'context.__fn(\'</span> + args.toString() + <span class=\"hljs-string\">\')\'</span>)\n\n    <span class=\"hljs-keyword\">delete</span> context.__fn\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>1.1.5 再进一步，确保 __fn 不存在</h4>\n\n<p>我们之前的代码都是建立在 <code>__fn</code> 不存在的情况下，那么万一存在呢？因此我们接下来就要找一个 <code>context</code> 中没有存在过的属性。<br />?我们很快可以想到 ES6 的 symbol。</p>\n\n<pre><code><span class=\"hljs-comment\">// 像这样</span>\n<span class=\"hljs-keyword\">var</span> __fn = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Symbol</span>()\ncontext[__fn] = <span class=\"hljs-keyword\">this</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>?如果不用 ES6，那么另一种方法，是根据 <a href=\"https://juejin.im/post/5bf6c79bf265da6142738b29#heading-4\">这篇文章</a>中提到的，自己用 Math.random() 模拟实现独一无二的 key。面试时可以直接用生成时间戳即可。</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-comment\">// 生成 UUID 通用唯一识别码</span>\n<span class=\"hljs-comment\">// 大概生成 这样一串 \'18efca2d-6e25-42bf-a636-30b8f9f2de09\'</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">generateUUID</span>()</span>{\n    <span class=\"hljs-keyword\">var</span> i, random;\n    <span class=\"hljs-keyword\">var</span> uuid = <span class=\"hljs-string\">\'\'</span>;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">32</span>; i++) {\n        random = <span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-number\">16</span> | <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">if</span> (i === <span class=\"hljs-number\">8</span> || i === <span class=\"hljs-number\">12</span> || i === <span class=\"hljs-number\">16</span> || i === <span class=\"hljs-number\">20</span>) {\n            uuid += <span class=\"hljs-string\">\'-\'</span>;\n        }\n        uuid += (i === <span class=\"hljs-number\">12</span> ? <span class=\"hljs-number\">4</span> : (i === <span class=\"hljs-number\">16</span> ? (random &amp; <span class=\"hljs-number\">3</span> | <span class=\"hljs-number\">8</span>) : random))\n            .toString(<span class=\"hljs-number\">16</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> uuid;\n}\n<span class=\"hljs-comment\">// 简单实现</span>\n<span class=\"hljs-comment\">// \'__\' + new Date().getTime();</span>\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>如果这个key万一这对象中还是有，为了保险起见，可以做一次缓存操作(就是先把之前的值保存起来)</p>\n\n<pre><code><span class=\"hljs-comment\">// 像这样</span>\n<span class=\"hljs-keyword\">var</span> originalvalue = context.__fn\n<span class=\"hljs-keyword\">var</span> hasOriginalValue = context.hasOwnProperty(<span class=\"hljs-string\">\'__fn\'</span>)\ncontext.__fn = <span class=\"hljs-keyword\">this</span>\n\n<span class=\"hljs-keyword\">if</span>(hasOriginalValue){\n    context.__fn = originalvalue;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>2. call</h2>\n\n<ul><li><p>和 apply 的作用是一样的，只是 <code>call()</code> 方法接受的是一个参数列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p></li><li><p>例如 <code>func.apply(obj, [1,2])</code> 相当于 <code>func.call(obj, 1, 2)</code></p></li></ul>\n\n<p>思路和 apply 一样。唯一区别就在于参数形式。我们按照 call 的要求来处理参数就可以了：</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-built_in\">Function</span>.prototype.apply = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) </span>{\n    <span class=\"hljs-comment\">// context 就是需要绑定的对象，相当于上面的 o</span>\n    <span class=\"hljs-comment\">// this 就是调用了 apply 的函数，相当于 f</span>\n    context.__fn = <span class=\"hljs-keyword\">this</span> <span class=\"hljs-comment\">// 假设原先没有__fn</span>\n\n    <span class=\"hljs-keyword\">var</span> result;\n\n    <span class=\"hljs-keyword\">var</span> args = [];\n    <span class=\"hljs-comment\">// 我们从 arguments[1] 开始拼就好了</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>, len = <span class=\"hljs-built_in\">arguments</span>.length; i &lt; len; i++) {\n        args.push(<span class=\"hljs-string\">\'arguments[\'</span> + i + <span class=\"hljs-string\">\']\'</span>);\n    }\n\n    result = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">\'context.__fn(\'</span> + args.toString() + <span class=\"hljs-string\">\')\'</span>)\n\n    <span class=\"hljs-keyword\">delete</span> context.__fn\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>3. bind</h2>\n\n<p>我们常将 bind 和以上两个方法区分开，是因为 bind 是 ECMAScript 5 中的方法，且除了将函数绑定至一个对象外还多了一些特点。</p>\n\n<ul><li><p><strong>bind() 方法创建一个新的函数</strong>，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的初始参数，供调用时使用。</p><pre><code>func.apply(obj, [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])\n<span class=\"hljs-comment\">// 相当于</span>\nfunc.call(obj, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-comment\">// 相当于</span>\n<span class=\"hljs-keyword\">var</span> boundFun = func.bind(obj, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\nboundFun()\n<span class=\"hljs-comment\">// 也可以这样</span>\n<span class=\"hljs-keyword\">var</span> boundFun = func.bind(obj, <span class=\"hljs-number\">1</span>)\nboundFun(<span class=\"hljs-number\">2</span>)\n<span class=\"copy-code-btn\">复制代码</span></code></pre></li><li><p><strong>绑定函数也可以使用 new 运算符构造</strong>，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。</p></li></ul>\n\n<p>我们还是先大致思考一下该怎么做：</p>\n\n<ol><li>实现第一个参数的功能，改变 this 指向。这个和 apply/call 是一样的。</li><li>返回值：返回一个新的函数。</li><li>实现其它参数。其它参数将作为新函数的初始参数，供调用时使用。这个和 call 有些相似。</li><li>使用 new 操作符时，应该忽略第一个参数</li></ol>\n\n<p>后续的步骤我会用 apply/call 来实现bind。如果不想直接用 apply/call，也可以按照上文先实现一个 apply/call。</p>\n\n<h4>3.1.1 第一步，返回一个绑定了 this 的新函数</h4>\n\n<pre><code><span class=\"hljs-built_in\">Function</span>.prototype.bind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        <span class=\"hljs-keyword\">return</span> self.apply(context);\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>3.1.2 第二步，给新函数设定初始参数</h4>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-built_in\">Function</span>.prototype.bind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// 获取 bind 函数从第二个参数到最后一个参数</span>\n    <span class=\"hljs-keyword\">var</span> initialArgs = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">1</span>);\n    \n    <span class=\"hljs-comment\">// 返回一个绑定好 this 的新函数</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> () </span>{\n        <span class=\"hljs-comment\">// 这个是调用新函数时传入的参数</span>\n        <span class=\"hljs-keyword\">var</span> boundArgs = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>);\n        <span class=\"hljs-comment\">// 最终的参数应该是初始参数+新函数的参数</span>\n        <span class=\"hljs-keyword\">return</span> self.apply(context, args.concat(bindArgs));\n    }\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h4>3.1.3 第三步，作为构造函数调用时，忽略要绑定的 this</h4>\n\n<p>这里的难点是怎么知道是由 new 调用的。<br />先说一下答案吧</p>\n\n<pre><code><span class=\"hljs-comment\">// 假如有以下函数</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> () </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<blockquote><p>对于 <code>var gioia = new Person()</code> 来说<br />使用 new 时，this 会指向 gioia，并且 gioia 是 Person 的实例。因此，如果 <code>this instance Person</code>，就说明是 new 调用的</p></blockquote>\n\n<p>new 这一部分这里先不展开讲，有兴趣的可以看一下 <a href=\"https://github.com/mqyqingfeng/Blog/issues/13\">JavaScript深入之new的模拟实现</a><br />接下来我们可以写代码了：</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-built_in\">Function</span>.prototype.bind = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n\n    <span class=\"hljs-comment\">// 获取 bind 函数从第二个参数到最后一个参数</span>\n    <span class=\"hljs-keyword\">var</span> initialArgs = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">1</span>);\n    \n    <span class=\"hljs-comment\">// 返回一个绑定好 this 的新函数</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Bound</span>() </span>{\n        <span class=\"hljs-comment\">// 这个是调用新函数时传入的参数</span>\n        <span class=\"hljs-keyword\">var</span> boundArgs = <span class=\"hljs-built_in\">Array</span>.prototype.slice.call(<span class=\"hljs-built_in\">arguments</span>);\n        <span class=\"hljs-comment\">// 最终的参数应该是初始参数+新函数的参数</span>\n        <span class=\"hljs-keyword\">return</span> self.apply(<span class=\"hljs-keyword\">this</span> instance Bound ? <span class=\"hljs-keyword\">this</span> : context, args.concat(bindArgs));\n    }\n\n    Bound.prototype = <span class=\"hljs-keyword\">this</span>.prototype\n    <span class=\"hljs-keyword\">return</span> Bound\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>二、如何实现一个深拷贝</p>\n\n<p>这部分我是看了 <a href=\"https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L11087\">lodash</a> 的相关源码，它真的实现得非常完整！<br />总结成一句话，就是需要考虑很多数据类型，然后针对这些数据类型拷贝就行了?</p>\n\n<p>对于引用类型来说，我们基本可以按照以下思路走：</p>\n\n<ol><li>初始化。即调用相应的构造函数</li><li>递归地赋值</li><li>有循环引用的话需要处理一下</li></ol>\n\n<h2>1. 拷贝基本类型</h2>\n\n<p>基本类型直接赋值就可以。</p>\n\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepClone</span> (<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-comment\">// 基本类型</span>\n    <span class=\"hljs-keyword\">if</span> (!isObject(value)) {\n        <span class=\"hljs-keyword\">return</span> value\n    }\n}\n\n<span class=\"hljs-comment\">// 判断是不是对象</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isObject</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> type = <span class=\"hljs-keyword\">typeof</span> value\n    <span class=\"hljs-keyword\">return</span> value != <span class=\"hljs-literal\">null</span> &amp;&amp; (type === <span class=\"hljs-string\">\'object\'</span> || type === <span class=\"hljs-string\">\'function\'</span>)\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>接下来是怎么拷贝引用类型。我会按照以下顺序来介绍：</p>\n\n<ol><li>数组</li><li>函数</li><li>对象</li><li>特殊类型。Boolean、Date、Map、Number 等等</li></ol>\n\n<p>另外，lodash 还实现了 Buffer（node.js）等拷贝，但我实际用得不多，就不展开了，有兴趣的可以去看看源码。</p>\n\n<p> </p>\n\n<h2>2. 拷贝数组</h2>\n\n<h3>2.1 初始化</h3>\n\n<p>先初始化一个长度为原数组长度的数组</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepClone</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> result\n\n    <span class=\"hljs-comment\">// 基本类型</span>\n    <span class=\"hljs-keyword\">if</span> (!isObject(value)) {\n      <span class=\"hljs-keyword\">return</span> value\n    }\n\n    <span class=\"hljs-keyword\">const</span> isArr = <span class=\"hljs-built_in\">Array</span>.isArray(value)\n    \n    <span class=\"hljs-comment\">// 数组</span>\n    <span class=\"hljs-keyword\">if</span> (isArr) {\n        result = initCloneArray(value)\n    }\n    <span class=\"hljs-comment\">// 待续</span>\n}\n\n<span class=\"hljs-keyword\">const</span> hasOwnProperty = <span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty\n\n<span class=\"hljs-comment\">// 数组初始化</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initCloneArray</span>(<span class=\"hljs-params\">array</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> { length } = array\n    <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> array.constructor(length)\n\n    <span class=\"hljs-comment\">// 因为 RegExp.prototype.exec() 会返回一个数组或 null，这个数组里有两个特殊的属性：input、index</span>\n    <span class=\"hljs-comment\">// 类似 [\"foo\", index: 6, input: \"table football, foosball\", groups: undefined]</span>\n    <span class=\"hljs-comment\">// 所以需要进行特殊处理</span>\n    <span class=\"hljs-keyword\">if</span> (length &amp;&amp; <span class=\"hljs-keyword\">typeof</span> array[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">\'string\'</span> &amp;&amp; hasOwnProperty.call(array, <span class=\"hljs-string\">\'index\'</span>)) {\n        result.index = array.index\n        result.input = array.input\n    }\n    <span class=\"hljs-keyword\">return</span> result\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h3>2.2 赋值</h3>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepClone</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> result\n\n    <span class=\"hljs-comment\">// 基本类型</span>\n    <span class=\"hljs-keyword\">if</span> (!isObject(value)) {\n      <span class=\"hljs-keyword\">return</span> value\n    }\n\n    <span class=\"hljs-keyword\">const</span> isArr = <span class=\"hljs-built_in\">Array</span>.isArray(value)\n    \n    <span class=\"hljs-comment\">// 数组</span>\n    <span class=\"hljs-keyword\">if</span> (isArr) {\n        result = initCloneArray(value)\n    }\n\n    <span class=\"hljs-comment\">// 赋值</span>\n    <span class=\"hljs-keyword\">if</span> (isArr) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i&lt; value.length; i++) {\n            result[i] = deepClone(value[i])\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> result\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>3. 拷贝函数</h2>\n\n<p>函数的拷贝的话，我们还是返回之前的引用。</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepClone</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> result\n\n    <span class=\"hljs-comment\">// 基本类型</span>\n    <span class=\"hljs-keyword\">if</span> (!isObject(value)) {\n      <span class=\"hljs-keyword\">return</span> value\n    }\n\n    <span class=\"hljs-keyword\">const</span> isArr = <span class=\"hljs-built_in\">Array</span>.isArray(value)\n    \n    <span class=\"hljs-comment\">// 数组</span>\n    <span class=\"hljs-keyword\">if</span> (isArr) {\n        result = initCloneArray(value)\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">const</span> isFunc = <span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">\'function\'</span>\n        <span class=\"hljs-comment\">// 函数</span>\n        <span class=\"hljs-keyword\">if</span> (isFunc) {\n            <span class=\"hljs-keyword\">return</span> value\n        }\n    }\n\n    <span class=\"hljs-comment\">// 赋值</span>\n    <span class=\"hljs-keyword\">if</span> (isArr) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i&lt; value.length; i++) {\n            result[i] = deepClone(value[i])\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> result\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>4. 拷贝对象</h2>\n\n<p>初始化一个对象，然后赋值。<br />要注意的是这个拷贝后的对象和原对象的原型链是一样的</p>\n\n<pre><code>微信公众号：世界上有意思的事\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">deepClone</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">let</span> result\n    \n    <span class=\"hljs-comment\">// 基本类型</span>\n    <span class=\"hljs-keyword\">if</span> (!isObject(value)) {\n        <span class=\"hljs-keyword\">return</span> value\n    }\n    \n    <span class=\"hljs-keyword\">const</span> isArr = <span class=\"hljs-built_in\">Array</span>.isArray(value)\n    <span class=\"hljs-keyword\">const</span> tag = getTag(value)\n\n    <span class=\"hljs-comment\">// 数组</span>\n    <span class=\"hljs-keyword\">if</span> (isArr) {\n        result = initCloneArray(value)\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">const</span> isFunc = <span class=\"hljs-keyword\">typeof</span> value === <span class=\"hljs-string\">\'function\'</span>\n        <span class=\"hljs-comment\">// 函数</span>\n        <span class=\"hljs-keyword\">if</span> (isFunc) {\n            <span class=\"hljs-keyword\">return</span> value\n        }\n\n        <span class=\"hljs-comment\">// 对象或 arguments</span>\n        <span class=\"hljs-keyword\">if</span> (tag == <span class=\"hljs-string\">\'[object Object]\'</span> || tag == <span class=\"hljs-string\">\'[object Arguments]\'</span>) {\n            result = initCloneObject(value)\n        }\n    }\n\n    <span class=\"hljs-keyword\">if</span> (isArr) {\n        <span class=\"hljs-comment\">// 数组赋值</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i&lt; value.length; i++) {\n            result[i] = deepClone(value[i])\n        }\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// 对象赋值</span>\n        <span class=\"hljs-built_in\">Object</span>.keys(<span class=\"hljs-built_in\">Object</span>(value)).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">k</span> =&gt;</span> {\n            result[k] = deepClone(value[k])\n        })\n    }\n\n    <span class=\"hljs-keyword\">return</span> result\n\n}\n\n<span class=\"hljs-comment\">// 能更细致地判断是什么类型</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getTag</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (value == <span class=\"hljs-literal\">null</span>) {\n        <span class=\"hljs-keyword\">return</span> value === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-string\">\'[object Undefined]\'</span> : <span class=\"hljs-string\">\'[object Null]\'</span>\n    }\n    <span class=\"hljs-keyword\">return</span> toString.call(value)\n}\n\n<span class=\"hljs-keyword\">const</span> objectProto = <span class=\"hljs-built_in\">Object</span>.prototype\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isPrototype</span>(<span class=\"hljs-params\">value</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> Ctor = value &amp;&amp; value.constructor\n    <span class=\"hljs-keyword\">const</span> proto = (<span class=\"hljs-keyword\">typeof</span> Ctor === <span class=\"hljs-string\">\'function\'</span> &amp;&amp; Ctor.prototype) || objectProto\n  \n    <span class=\"hljs-keyword\">return</span> value === proto\n}\n\n<span class=\"hljs-comment\">// 初始化对象</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">initCloneObject</span>(<span class=\"hljs-params\">object</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">typeof</span> object.constructor === <span class=\"hljs-string\">\'function\'</span> &amp;&amp; !isPrototype(object))\n      ? <span class=\"hljs-built_in\">Object</span>.create(<span class=\"hljs-built_in\">Object</span>.getPrototypeOf(object))\n      : {}\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2> </h2>',8,1,0,0,0,0,1,'2020-05-13 19:47:01','2020-05-13 19:47:01'),(67,'kill -9 的原理都不知道就敢去线上执行？明天不用来了！','相信很多程序员对于Linux系统都不陌生，即使自己的日常开发机器不是Linux，那么线上服务器也大部分都是的，所以，掌握常用的Linux命令也是程序员必备的技能。 但是，怕就怕很多人对于部分命令只是一知半解，使用不当...','do-you-dare-to-go-online-without-knowing-the-principle-of-kill-9-dont-come-tomorrow','<p>相信很多程序员对于Linux系统都不陌生，即使自己的日常开发机器不是Linux，那么线上服务器也大部分都是的，所以，掌握常用的Linux命令也是程序员必备的技能。</p>\n\n<p>但是，怕就怕很多人对于部分命令只是一知半解，使用不当就能导致线上故障。</p>\n\n<p>前段时间，我们的线上应用报警，频繁FGC，需要紧急处理问题，于是有同事去线上重启机器（正常程序应该是先采集堆dump，然后再重启，方便排查是否存在内存泄露等问题）。</p>\n\n<p>但是在重启过程中，同事发现正常的重启命令应用无反应，然后尝试使用kill命令\"杀\"掉Java进程，但是仍然无效。于是他私自决定使用 \"kill -9\"结束了进程的生命。</p>\n\n<p>虽然应用进程被干掉了，但是随之而来带来了很多问题，首先是上游系统突然发生大量报警，对应开发找过来说调用我们的RPC服务无响应，频繁超时。</p>\n\n<p>后来，我们又发现系统中存在部分脏数据，有些在同一个事务中需要完整更新的数据，只跟新了一半...</p>\n\n<p>为什么正常的kill无法\"杀掉\"进程，而<code>kill -9</code>就可以？为什么<code>kill -9</code>会引发这一连串连锁反应？正常的kill执行时，JVM会如何处理的呢？</p>\n\n<p>要搞清楚这些问题，我们要先从kill命令说起。</p>\n\n<p> </p>\n\n<h3>kill 命令</h3>\n\n<p>我们都知道，想要在Linux中终止一个进程有两种方式，如果是前台进程可以使用Ctrl+C键进行终止；如果是后台进程，那么需要使用kill命令来终止。（其实Ctrl+C也是kill命令）</p>\n\n<p>kill命令的格式是：</p>\n\n<pre><code>kill[参数][进程号]\n\n如：\nkill 21121\nkill -9 21121\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p>其中[参数]是可选的，进程号可以通过jps/ps/pidof/pstree/top等工具获取。</p>\n\n<p>kill的命令参数有以下几种：</p>\n\n<blockquote><p>-l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</p><p>-a 当处理当前进程时，不限制命令名和进程号的对应关系</p><p>-p 指定kill 命令只打印相关进程的进程号，而不发送任何信号</p><p>-s 指定发送信号</p><p>-u 指定用户</p></blockquote>\n\n<p>通常情况下，我们使用的<code>-l</code>(信号)的时候比较多，如我们前文提到的<code>kill -9</code>中的<code>9</code>就是信号。</p>\n\n<p>信号如果没有指定的话，默认会发出终止信号(15)。常用的信号如下：</p>\n\n<blockquote><p>HUP 1 终端断线</p><p>INT 2 中断（同 Ctrl + C）</p><p>QUIT 3 退出（同 Ctrl + \\）</p><p>TERM 15 终止</p><p>KILL 9 强制终止</p><p>CONT 18 继续（与STOP相反， fg/bg命令）</p><p>STOP 19 暂停（同 Ctrl + Z）</p></blockquote>\n\n<p>比较常用的就是<code>强制终止信号：9</code>和<code>终止信号：15</code>，另外，<code>中断信号：2</code>其实就是我们前文提到的Ctrl + C结束前台进程。</p>\n\n<p>那么，<code>kill -9</code> 和 <code>kill -15</code>到底有什么区别呢？该如何选择呢？</p>\n\n<p> </p>\n\n<p><br /></p>\n\n<h3>kill -9 和 kill -15的区别</h3>\n\n<p>kill命令默认的信号就是15，首先来说一下这个默认的<code>kill -15</code>信号。</p>\n\n<p>当使用<code>kill -15</code>时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。</p>\n\n<p>这时候，应用程序可以选择：</p>\n\n<ul><li><p>1、立即停止程序</p></li><li><p>2、释放响应资源后停止程序</p></li><li><p>3、忽略该信号，继续执行程序</p></li></ul>\n\n<p>因为<code>kill -15</code>信号只是通知对应的进程要进行\"安全、干净的退出\"，程序接到信号之后，退出前一般会进行一些\"准备工作\"，如资源释放、临时文件清理等等，如果准备工作做完了，再进行程序的终止。</p>\n\n<p>但是，如果在\"准备工作\"进行过程中，遇到阻塞或者其他问题导致无法成功，那么应用程序可以选择忽略该终止信号。</p>\n\n<p>这也就是为什么我们有的时候使用kill命令是没办法\"杀死\"应用的原因，因为<strong>默认的kill信号是SIGTERM（15），而SIGTERM（15）的信号是可以被阻塞和忽略的。</strong></p>\n\n<p>和<code>kill -15</code>相比，<code>kill -9</code>就相对强硬一点，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。</p>\n\n<p>所以，<strong>相比于<code>kill -15</code>命令，<code>kill -9</code>在执行时，应用程序是没有时间进行\"准备工作\"的，所以这通常会带来一些副作用，数据丢失或者终端无法恢复到正常状态等。</strong></p>\n\n<p> </p>',7,1,0,0,0,0,1,'2020-05-13 19:52:30','2020-05-13 19:52:30'),(68,'数据库面试题(开发者必看)','  什么是存储过程？有哪些优缺点？ 什么是存储过程？有哪些优缺点？ 存储过程就像我们编程语言中的函数一样，封装了我们的代码(PLSQL、T-SQL)。 存储过程的优点： 能够将代码封装起来保存在数据库之中让编程语言进行...','database-interview-questions-required-for-developers','<p> <img alt=\"Image\" src=\"https://user-gold-cdn.xitu.io/2018/3/5/161f3dcd8a20045c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" width=\"1200\" height=\"801\" /></p>\n\n<p><img alt=\"Image\" src=\"https://user-gold-cdn.xitu.io/2018/3/5/161f3dd44e3b3d59?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" width=\"1200\" height=\"573\" /><br /></p>\n\n<p><br /></p>\n\n<h2>什么是存储过程？有哪些优缺点？</h2>\n\n<blockquote><p>什么是存储过程？有哪些优缺点？</p></blockquote>\n\n<p><strong>存储过程就像我们编程语言中的函数一样，封装了我们的代码(PLSQL、T-SQL)</strong>。</p>\n\n<p>存储过程的优点：</p>\n\n<ul><li><strong>能够将代码封装起来</strong></li><li><strong>保存在数据库之中</strong></li><li><strong>让编程语言进行调用</strong></li><li><strong>存储过程是一个预编译的代码块，执行效率比较高</strong></li><li><strong>一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率</strong></li></ul>\n\n<p>存储过程的缺点：</p>\n\n<ul><li><strong>每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）</strong></li><li><strong>业务逻辑放在数据库上，难以迭代</strong></li></ul>\n\n<p> </p>\n\n<h2>三个范式是什么</h2>\n\n<ul><li>首先要明确的是：<strong>满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式</strong></li><li>第一范式：<strong>字段是最小的的单元不可再分</strong><ul><li>学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的</li></ul></li><li>第二范式：满足第一范式,<strong>表中的字段必须完全依赖于全部主键而非部分主键。</strong><ul><li><strong>其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的</strong></li><li>学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。</li></ul></li><li>第三范式：满足第二范式，<strong>非主键外的所有字段必须互不依赖</strong><ul><li><strong>就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖</strong></li><li>比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。</li></ul></li></ul>\n\n<p> </p>\n\n<h2>什么是视图？以及视图的使用场景有哪些？</h2>\n\n<p>视图是一种基于数据表的一种<strong>虚表</strong></p>\n\n<ul><li>（1）视图是一种虚表</li><li>（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表</li><li>（3）<strong>向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句</strong></li><li>（4）视图向用户提供基表数据的另一种表现形式</li><li>（5）视图没有存储真正的数据，真正的数据还是存储在基表中</li><li>（6）程序员虽然操作的是视图，但最终视图还会转成操作基表</li><li>（7）一个基表可以有0个或多个视图</li></ul>\n\n<p>有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段...</p>\n\n<p>那么把全部的字段都都显示给他们看，这是不合理的。</p>\n\n<p>我们应该做到：<strong>他们想看到什么样的数据，我们就给他们什么样的数据...一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来...</strong></p>\n\n<p> </p>\n\n<p>我们在查询数据的时候，常常需要编写非常长的SQL语句，几乎每次都要写很长很长....上面已经说了，<strong>视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便</strong>...</p>\n\n<p>值得注意的是：<strong>使用视图可以让我们专注与逻辑，但不提高查询效率</strong></p>\n\n<p> </p>\n\n<h2>drop、delete与truncate分别在什么场景之下使用？</h2>\n\n<p>我们来对比一下他们的区别：</p>\n\n<p>drop table</p>\n\n<ul><li>1)属于DDL</li><li>2)不可回滚</li><li>3)不可带where</li><li>4)表内容和结构删除</li><li>5)删除速度快</li></ul>\n\n<p>truncate table</p>\n\n<ul><li>1)属于DDL</li><li>2)不可回滚</li><li>3)不可带where</li><li>4)表内容删除</li><li>5)删除速度快</li></ul>\n\n<p>delete from</p>\n\n<ul><li><p>1)属于DML</p></li><li><p>2)可回滚</p></li><li><p>3)可带where</p></li><li><p>4)表结构在，表内容要看where执行的情况</p></li><li><p>5)删除速度慢,需要逐行删除</p></li></ul>\n\n<p>区别</p>\n\n<ul><li><p><b>不再需要一张表</b>的时候，用<b>drop</b></p></li><li><p>想删除<b>部分数据</b>行时候，用delete，并且带上where子句</p></li><li><p><b>保留表</b>而删除所有数据的时候用truncate</p></li></ul>\n\n<p><a href=\"https://juejin.im/post/5a9ca0d6518825555c1d1acd\">https://juejin.im/post/5a9ca0d6518825555c1d1acd</a><br /></p>',6,2,0,0,0,0,1,'2020-05-13 20:01:23','2020-05-13 20:01:23'),(69,'后端必备 Nginx 配置','https://juejin.im/post/5d7e3f51f265da03a31d687b 概要 防盗链根据文件类型设置过期时间静态资源访问日志配置日志字段说明access_log 访问日志error_log 日志日志切割反向代理禁止指定user_agentnginx访问控制负载...','back-end-required-nginx-configuration','<h2><a href=\"https://juejin.im/post/5d7e3f51f265da03a31d687b\">https://juejin.im/post/5d7e3f51f265da03a31d687b</a><br /></h2>\n\n<h2>概要</h2>\n\n<ul><li>防盗链<br /></li><li>根据文件类型设置过期时间<br /></li><li>静态资源访问<br /></li><li>日志配置<br /><ul><li>日志字段说明<br /></li><li>access_log 访问日志<br /></li><li>error_log 日志<br /></li><li>日志切割<br /></li></ul></li><li>反向代理<br /></li><li>禁止指定user_agent<br /></li><li>nginx访问控制<br /></li><li>负载均衡</li></ul>\n\n<h2>防盗链</h2>\n\n<pre><code>location ~* \\.(gif|jpg|png)$ {\n    # 只允许 192.168.0.1 请求资源\n    valid_referers none blocked 192.168.0.1;\n    if ($invalid_referer) {\n       rewrite ^/ http://$host/logo.png;\n    }\n}<br /></code></pre>\n\n<h2>根据文件类型设置过期时间</h2>\n\n<pre><code>location ~.*\\.css$ {\n    expires 1d;\n    break;\n}\nlocation ~.*\\.js$ {\n    expires 1d;\n    break;\n}\n\nlocation ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$ {\n    access_log off;\n    expires 15d;    #保存15天\n    break;\n}\n\n# curl -x127.0.0.1:80 http://www.test.com/static/image/common/logo.png -I #测试图片的max-age\n<br /></code></pre>\n\n<h2>静态资源访问<br /></h2>\n\n<pre><code><span class=\"hljs-section\">http</span> {\n    <span class=\"hljs-comment\"># 这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，</span>\n    <span class=\"hljs-comment\"># 建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。</span>\n    <span class=\"hljs-attribute\">open_file_cache</span> max=<span class=\"hljs-number\">204800</span> inactive=<span class=\"hljs-number\">20s</span>;\n\n    <span class=\"hljs-comment\"># open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，</span>\n    <span class=\"hljs-comment\"># 如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个</span>\n    <span class=\"hljs-comment\"># 文件在inactive 时间内一次没被使用，它将被移除。</span>\n    <span class=\"hljs-attribute\">open_file_cache_min_uses</span> <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-comment\"># 这个是指多长时间检查一次缓存的有效信息</span>\n    <span class=\"hljs-attribute\">open_file_cache_valid</span> <span class=\"hljs-number\">30s</span>;\n\n    <span class=\"hljs-comment\"># 默认情况下，Nginx的gzip压缩是关闭的， gzip压缩功能就是可以让你节省不</span>\n    <span class=\"hljs-comment\"># 少带宽，但是会增加服务器CPU的开销哦，Nginx默认只对text/html进行压缩 ，</span>\n    <span class=\"hljs-comment\"># 如果要对html之外的内容进行压缩传输，我们需要手动来设置。</span>\n    <span class=\"hljs-attribute\">gzip</span> <span class=\"hljs-literal\">on</span>;\n    <span class=\"hljs-attribute\">gzip_min_length</span> <span class=\"hljs-number\">1k</span>;\n    <span class=\"hljs-attribute\">gzip_buffers</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">16k</span>;\n    <span class=\"hljs-attribute\">gzip_http_version</span> <span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-attribute\">gzip_comp_level</span> <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-attribute\">gzip_types</span> text/plain application/x-javascript text/css application/xml;\n\n\n    <span class=\"hljs-section\">server</span> {\n        <span class=\"hljs-attribute\">listen</span>       <span class=\"hljs-number\">80</span>;\n        <span class=\"hljs-attribute\">server_name</span> www.test.com;\n        <span class=\"hljs-attribute\">charset</span> utf-<span class=\"hljs-number\">8</span>;\n        <span class=\"hljs-attribute\">root</span>   /data/www.test.com;\n        <span class=\"hljs-attribute\">index</span>  index.html index.htm;\n    }\n}<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p> </p>\n\n<h2>日志配置</h2>\n\n<h3>日志字段说明</h3>\n\n<table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>remote_addr 和 http_x_forwarded_for</td><td>客户端 IP 地址</td></tr><tr><td>remote_user</td><td>客户端用户名称</td></tr><tr><td>request</td><td>请求的 URI 和 HTTP 协议</td></tr><tr><td>status</td><td>请求状态</td></tr><tr><td>body_bytes_sent</td><td>返回给客户端的字节数，不包括响应头的大小</td></tr><tr><td>bytes_sent</td><td>返回给客户端总字节数</td></tr><tr><td>connection</td><td>连接的序列号</td></tr><tr><td>connection_requests</td><td>当前同一个 TCP 连接的的请求数量</td></tr><tr><td>msec</td><td>日志写入时间。单位为秒，精度是毫秒</td></tr><tr><td>pipe</td><td>如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”</td></tr><tr><td>http_referer</td><td>记录从哪个页面链接访问过来的</td></tr><tr><td>http_user_agent</td><td>记录客户端浏览器相关信息</td></tr><tr><td>request_length</td><td>请求的长度（包括请求行，请求头和请求正文）</td></tr><tr><td>time_iso8601</td><td>ISO8601标准格式下的本地时间</td></tr><tr><td>time_local</td><td>记录访问时间与时区</td></tr></tbody></table>\n\n<h3>access_log 访问日志</h3>\n\n<pre><code><span class=\"hljs-section\">http</span> {\n    <span class=\"hljs-attribute\">log_format</span>  access  <span class=\"hljs-string\">\'<span class=\"hljs-variable\">$remote_addr</span> - <span class=\"hljs-variable\">$remote_user</span> [<span class=\"hljs-variable\">$time_local</span>] <span class=\"hljs-variable\">$host</span> \"<span class=\"hljs-variable\">$request</span>\" \'</span>\n                  <span class=\"hljs-string\">\'<span class=\"hljs-variable\">$status</span> <span class=\"hljs-variable\">$body_bytes_sent</span> \"<span class=\"hljs-variable\">$http_referer</span>\" \'</span>\n                  <span class=\"hljs-string\">\'\"<span class=\"hljs-variable\">$http_user_agent</span>\" \"<span class=\"hljs-variable\">$http_x_forwarded_for</span>\" \"<span class=\"hljs-variable\">$clientip</span>\"\'</span>;\n    <span class=\"hljs-attribute\">access_log</span>  /srv/log/nginx/talk-fun.access.log  access;\n}<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h3>error_log 日志</h3>\n\n<pre><code><span class=\"hljs-attribute\">error_log</span>  /srv/log/nginx/nginx_error.log  <span class=\"hljs-literal\">error</span>;\n<span class=\"hljs-comment\"># error_log /dev/null; # 真正的关闭错误日志</span>\n<span class=\"hljs-section\">http</span> {\n    <span class=\"hljs-comment\"># ...</span>\n}<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h3>日志切割</h3>\n\n<pre><code><span class=\"hljs-meta\">#</span><span class=\"bash\"> 和apache不同的是，nginx没有apache一样的工具做切割，需要编写脚本实现。<span class=\"hljs-comment\"># 在/usr/local/sbin下写脚本</span></span>\n<span class=\"hljs-meta\">\n\n#</span><span class=\"bash\">!/bin/bash</span>\ndd=$(date -d \'-1 day\' +%F)[ -d /tmp/nginx_log ] || mkdir /tmp/nginx_log\nmv /tmp/nginx_access.log /tmp/nginx_log/$dd.log\n/etc/init.d/nginx reload &gt; /dev/null\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>反向代理</h2>\n\n<pre><code><span class=\"hljs-section\">http</span> {\n    <span class=\"hljs-attribute\">include</span> mime.types;\n    <span class=\"hljs-attribute\">server_tokens</span> <span class=\"hljs-literal\">off</span>;\n\n    <span class=\"hljs-comment\">## 配置反向代理的参数</span>\n    <span class=\"hljs-section\">server</span> {\n        <span class=\"hljs-attribute\">listen</span>    <span class=\"hljs-number\">8080</span>;\n\n        <span class=\"hljs-comment\">## 1. 用户访问 http://ip:port，则反向代理到 https://github.com</span>\n        <span class=\"hljs-attribute\">location</span> / {\n            <span class=\"hljs-attribute\">proxy_pass</span>  https://github.com;\n            <span class=\"hljs-attribute\">proxy_redirect</span>     <span class=\"hljs-literal\">off</span>;\n            <span class=\"hljs-attribute\">proxy_set_header</span>   Host             <span class=\"hljs-variable\">$host</span>;\n            <span class=\"hljs-attribute\">proxy_set_header</span>   X-Real-IP        <span class=\"hljs-variable\">$remote_addr</span>;\n            <span class=\"hljs-attribute\">proxy_set_header</span>   X-Forwarded-For  <span class=\"hljs-variable\">$proxy_add_x_forwarded_for</span>;\n        }\n\n        <span class=\"hljs-comment\">## 2.用户访问 http://ip:port/README.md，则反向代理到</span>\n        <span class=\"hljs-comment\">##   https://github.com/zibinli/blog/blob/master/README.md</span>\n        <span class=\"hljs-attribute\">location</span> /README.md {\n            <span class=\"hljs-attribute\">proxy_set_header</span>  X-Real-IP  <span class=\"hljs-variable\">$remote_addr</span>;\n            <span class=\"hljs-attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"hljs-variable\">$proxy_add_x_forwarded_for</span>;\n            <span class=\"hljs-attribute\">proxy_pass</span> https://github.com/zibinli/blog/blob/master/README.md;\n        }\n    }\n}<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>禁止指定user_agent</h2>\n\n<pre><code><span class=\"hljs-comment\">#虚拟主机的配置文件里加入：</span>\n\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable\">$http_user_agent</span> ~* <span class=\"hljs-string\">\'baidu|360|sohu\'</span>) <span class=\"hljs-comment\">#禁止useragent为baidu、360和sohu，~*表示不区分大小写匹配</span>\n{\n   <span class=\"hljs-built_in\">return</span> 403;\n}\n\nlocation /  和  location  ~ /  优先级是不一样的。 \n结合这个文章研究一下吧 http://blog.itpub.net/27181165/viewspace-777202/\ncurl -A <span class=\"hljs-string\">\"baidu\"</span> -x127.0.0.1:80 www.test.com/forum.php -I    该命令指定百度为user_agent,返回403\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>nginx访问控制</h2>\n\n<pre><code><span class=\"hljs-comment\"># 可以设置一些配置禁止一些ip的访问</span>\n\ndeny 127.0.0.1;     <span class=\"hljs-comment\">#全局定义限制，location里的是局部定义的。如果两者冲突，以location这种精确地优先，</span>\n\nlocation ~ .*admin\\.php$ {\n    <span class=\"hljs-comment\">#auth_basic \"cct auth\";</span>\n    <span class=\"hljs-comment\">#auth_basic_user_file /usr/local/nginx/conf/.htpasswd;</span>\n\n    allow 127.0.0.1;  只允许127.0.0.1的访问，其他均拒绝\n    deny all;\n\n    include fastcgi_params;\n    fastcgi_pass unix:/tmp/www.sock;\n    fastcgi_index index.php;\n    fastcgi_param SCRIPT_FILENAME /data/www<span class=\"hljs-variable\">$fastcgi_script_name</span>;\n}\n<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<h2>负载均衡</h2>\n\n<pre><code>http {\n    upstream test.net {\n        ip_hash;\n        server 192.168.10.13:80;\n        server 192.168.10.14:80  down;\n        server 192.168.10.15:8009  max_fails=3  fail_timeout=20s;\n        server 192.168.10.16:8080;\n    }\n    server {\n        location / {\n            proxy_pass  http://test.net;\n        }\n    }\n}<span class=\"copy-code-btn\">复制代码</span></code></pre>\n\n<p> </p>',5,1,0,0,0,0,1,'2020-05-13 20:04:28','2020-05-13 20:04:52'),(70,'HTTP----HTTP缓存机制','前言 缓存机制无处不在，有客户端缓存，服务端缓存，代理服务器缓存等。在HTTP中具有缓存功能的是浏览器缓存。HTTP缓存作为web性能优化的重要手段，对于从事web开发的朋友有重要的意义。本文将围绕以下几个方面来整...','http-http-caching-mechanism','<p>前言</p>\n\n<p>缓存机制无处不在，有客户端缓存，服务端缓存，代理服务器缓存等。在HTTP中具有缓存功能的是浏览器缓存。HTTP缓存作为web性能优化的重要手段，对于从事web开发的朋友有重要的意义。本文将围绕以下几个方面来整理HTTP缓存：</p>\n\n<ul><li>缓存的规则</li><li>缓存的方案</li><li>缓存的优点</li><li>不同刷新的请求执行过程</li></ul>\n\n<h2>缓存的规则</h2>\n\n<p>我们知道HTTP的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。下面我将分别详细的介绍这两种缓存的缓存规则。</p>\n\n<h3>强制缓存</h3>\n\n<p>当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。</p>\n\n<p> </p>\n\n<h3>协商缓存</h3>\n\n<p>又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。</p>\n\n<p><br /></p>\n\n<h4>小贴士：</h4>\n\n<p>两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。</p>\n\n<p><br /></p>\n\n<h2>缓存的方案</h2>\n\n<p>上面的内容让我们大概了解了缓存机制是怎样运行的，但是，服务器是如何判断缓存是否失效呢？我们知道浏览器和服务器进行交互的时候会发送一些请求数据和响应数据，我们称之为HTTP报文。报文中包含首部header和主体部分body。与缓存相关的规则信息就包含在header中。boby中的内容是HTTP请求真正要传输的部分。 </p>\n\n<p><br /></p>\n\n<h3>强制缓存</h3>\n\n<p>对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。</p>\n\n<h4>Expires</h4>\n\n<p>Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。</p>\n\n<h4>Cache-Control</h4>\n\n<p>Cache-Control有很多属性，不同的属性代表的意义也不同。private：客户端可以缓存public：客户端和代理服务器都可以缓存max-age=t：缓存内容将在t秒后失效no-cache：需要使用协商缓存来验证缓存数据no-store：所有内容都不会缓存。</p>\n\n<p> </p>\n\n<h3>协商缓存</h3>\n\n<p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。</p>\n\n<h4>Last-Modified</h4>\n\n<p>Last-Modified：服务器在响应请求时，会告诉浏览器资源的最后修改时间。</p>\n\n<p>if-Modified-Since:浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。从字面上看，就是说：从某个时间节点算起，是否文件被修改了</p>\n\n<ol><li>如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK</li><li>如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified</li></ol>\n\n<p>if-Unmodified-Since:从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改</p>\n\n<ol><li>如果没有被修改:则开始`继续\'传送文件: 服务器返回: 200 OK</li><li>如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)</li></ol>\n\n<p>这两个的区别是一个是修改了才下载一个是没修改才下载。Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。</p>\n\n<p> </p>\n\n<h4>Etag</h4>\n\n<p>Etag：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）</p>\n\n<p>If-None-Match：再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。</p>\n\n<ol><li>不同，说明资源被改动过，则响应整个资源内容，返回状态码200。</li><li>相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304.</li></ol>\n\n<p>但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。</p>\n\n<p><br /></p>\n\n<p> </p>',4,1,0,0,0,0,1,'2020-05-13 20:12:22','2020-05-13 20:12:22'),(71,'操作系统面试重难点总结','一、面试问题总结 操作系统的四个特性。操作系统的主要功能。进程的有哪几种状态，状态转换图，及导致转换的事件。4.进程与线程的区别。5.进程通信的几种方式。6.进程同步的几种方式7.用户态和核心态的区别。8.死锁...','summary-of-key-and-difficult-points-in-operating-system-interview','<h3>一、面试问题总结</h3>\n\n<ol><li>操作系统的四个特性。</li><li>操作系统的主要功能。</li><li>进程的有哪几种状态，状态转换图，及导致转换的事件。<br />4.进程与线程的区别。<br />5.进程通信的几种方式。<br />6.进程同步的几种方式<br />7.用户态和核心态的区别。<br />8.死锁的概念，导致死锁的原因.<br />9.导致死锁的四个必要条件。<br />10.处理死锁的四个方式。<br />11.预防死锁的方法、避免死锁的方法。<br />12.进程调度算法。<br />13.内存连续分配方式采用的几种算法及各自优劣。<br />14.基本分页储存管理方式。<br />15.基本分段储存管理方式。<br />16.分段分页方式的比较各自优缺点。<br />17.几种页面置换算法，会算所需换页数<br />18.虚拟内存的定义及实现方式。</li></ol>\n\n<h3>二、重难点总结</h3>\n\n<h5>1. 操作系统的四个特性</h5>\n\n<p>并发：同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)<br />共享：系统中的资源可以被内存中多个并发执行的进线程共同使用<br />虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个<br />异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进</p>\n\n<h5>2.操作系统的主要功能</h5>\n\n<p>处理机管理：处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度<br />存储器管理（或者内存管理）：内存分配，内存保护，地址映射，内存扩充<br />设备管理：管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用<br />文件管理：管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护<br />提供用户接口：程序接口（如API）和用户接口（如GUI）</p>\n\n<p><a href=\"https://juejin.im/entry/592257b62f301e006b183b95\">https://juejin.im/entry/592257b62f301e006b183b95</a><br /></p>',3,2,0,0,0,0,1,'2020-05-13 20:18:19','2020-05-13 20:18:19'),(72,'一致性 Hash 算法的实际应用','先来看看一致性 Hash 算法的一些特点： 构造一个 0 ~ 2^32-1 大小的环。服务节点经过 hash 之后将自身存放到环中的下标中。客户端根据自身的某些数据 hash 之后也定位到这个环中。通过顺时针找到离他最近的一个节点...','practical-application-of-consistent-hash-algorithm','<p>先来看看一致性 Hash 算法的一些特点：</p>\n\n<ul><li>构造一个 <code>0 ~ 2^32-1</code> 大小的环。</li><li>服务节点经过 hash 之后将自身存放到环中的下标中。</li><li>客户端根据自身的某些数据 hash 之后也定位到这个环中。</li><li>通过顺时针找到离他最近的一个节点，也就是这次路由的服务节点。</li><li>考虑到服务节点的个数以及 hash 算法的问题导致环中的数据分布不均匀时引入了虚拟节点</li></ul>\n\n<p> </p><p>自定义有序 Map</p>\n\n<p>根据这些客观条件我们很容易想到通过自定义一个<strong>有序</strong>数组来模拟这个环。</p>\n\n<p>这样我们的流程如下：</p>\n\n<ol><li>初始化一个长度为 N 的数组。</li><li>将服务节点通过 hash 算法得到的正整数，同时将节点自身的数据（hashcode、ip、端口等）存放在这里。</li><li>完成节点存放后将整个数组进行排序（排序算法有多种）。</li><li>客户端获取路由节点时，将自身进行 hash 也得到一个正整数；</li><li>遍历这个数组直到找到一个数据大于等于当前客户端的 hash 值，就将当前节点作为该客户端所路由的节点。</li><li>如果没有发现比客户端大的数据就返回第一个节点（满足环的特性）。</li></ol>\n\n<p>先不考虑排序所消耗的时间，单看这个路由的时间复杂度：</p>\n\n<ul><li>最好是第一次就找到，时间复杂度为<code>O(1)</code>。</li><li>最差为遍历完数组后才找到，时间复杂度为<code>O(N)</code>。</li></ul>\n\n<p> </p>',2,1,0,0,0,0,1,'2020-05-13 20:19:52','2020-05-13 20:19:52'),(73,'主流 PHP 框架性能评测','主要涉及到的框架有 CodeIgniter 老品牌易用性框架yaf 鸟哥用c写的php扩展，高性能框架yii 自动生成代码（gii）laravel 号称最优雅的框架swoole framework 支持swoole扩展的框架kohana 脱身与CI 2，基于hmvc模式的框...','performance-evaluation-of-mainstream-php-framework','<h3>主要涉及到的框架有</h3>\n\n<p>CodeIgniter 老品牌易用性框架<br />yaf 鸟哥用c写的php扩展，高性能框架<br />yii 自动生成代码（gii）<br />laravel 号称最优雅的框架<br />swoole framework 支持swoole扩展的框架<br />kohana 脱身与CI 2，基于hmvc模式的框架<br />thinkphp 国产易用工具<br />自定义框架（只提供route、autoload、db、redis、mvc、config及其他常见类库封装）</p>\n\n<p>以上框架使用的均为最新版本</p>\n\n<p><br /></p>\n\n<h3>安装</h3>\n\n<p>ci和kohana使用的还是熟悉的安装方式，解压zip，安装使用起来毫无问题</p>\n\n<p>yaf使用phpize安装也毫无难度</p>\n\n<p>关于YII 2，让我惊讶无比，不得不拿出来单独说一下</p>\n\n<p>安装 深深的感觉自己的智商已欠费</p>\n\n<p>1. 官网推荐composer安装一个basic版，由于国内环境，时间过长，附带一堆乱七八糟的东西看着烦<br />2. 抽出独立的yii-soft失败，提示错误，暂时未找到解决方案(最后发现是layout的问题，已解决)<br />3. basic版本安装完成后给我看你的那么复杂的欢迎页是几个意思？<br />4. 我改了controller和view，为什么还被侵入了你的样式(后查推测跟view中的layout目录有关，查文档得知需要手动layout=false)<br />5. layout关了为什么压测性能下降了那么多</p>\n\n<p><br /></p>\n\n<p><br /></p>\n\n<h3>关于框架的思考</h3>\n\n<p>通过这些年的工作和项目经验，我认为框架只要提供好几个功能点就足够了</p>\n\n<p>1<b>. autoload</b><br />2. dev/pro分离（包括config自动载入不同目录下）<br />3. <b>mvc</b>（不需要所谓的Smarty等模板引擎，php语法足够优秀易懂）<br />4. db/redis/<b>orm</b>（ORM可以实现读写分离，锦上添花而已，毕竟有中间层可以更专业的解决这个问题）<br />5. router</p>\n\n<p>有大神指点，还需要di、面向接口实现类、完整的单元测试</p>\n\n<p>像脚手架一类的东西，真的是框架该做的么？就算提供了，公司级别的项目又是否用得到，是否敢信任框架帮你生成的代码。</p>\n\n<p>基于上述思考，我才自己开发了simple框架（git:<a href=\"https://github.com/bingxuecandong/simple/tree/new_simple\">github.com/bingxuecand…</a> 欢迎提供建议及吐槽），提供自己日常编码、项目使用已经足够，开发效率并不低，跟其他主流开源框架一起评测也是聊以慰藉了。</p>\n\n<p><br /></p>\n\n<p><a href=\"https://juejin.im/entry/578ef4d6d342d30058e17d98\">https://juejin.im/entry/578ef4d6d342d30058e17d98</a><br /></p>',2,1,0,0,0,0,1,'2020-05-13 20:32:34','2020-05-13 20:32:34'),(74,'字节跳动靠谱内推','字节跳动靠谱内推 北京、杭州、武汉、广州、深圳、上海，等众多城市等你来投～感兴趣的朋友可以私我咨询&amp;内推，也可以通过链接直接投递！飞书海量 HC：www.feishu.cn/hr/feishu_s…社招所有职位: job.toutiao.com...','byte-jitter-push-in-the-spectrum','<p>字节跳动靠谱内推</p>\n\n<blockquote><p>北京、杭州、武汉、广州、深圳、上海，等众多城市等你来投～</p><p>感兴趣的朋友可以私我咨询&amp;内推，也可以通过链接直接投递！</p><p>飞书海量 HC：<a href=\"https://www.feishu.cn/hr/feishu_social_recruitment?token=MzsxNTg5MDA4NDMxMTY1OzY2ODc3OTI2MTcwODM5MTM3Mzk7MA\">www.feishu.cn/hr/feishu_s…</a></p><p>社招所有职位: <a href=\"https://job.toutiao.com/s/EjLtyC\">job.toutiao.com/s/EjLtyC</a></p><p>校招所有职位: <a href=\"https://job.toutiao.com/campus/%EF%BC%8C%E6%A0%A1%E6%8B%9B%E5%86%85%E6%8E%A8%E7%A0%81:\">job.toutiao.com/campus/，校招内…</a> M8KN3K4</p><p>为了更好地帮助你了解岗位详情、准备面试、同步进度，可通过搜索 625783482 加我个人微信（需要备注：字节内推-职位-真名，例如：字节内推-Android-张三，否则不加），我拉你进内推群来一起交流。</p><p>校招暂时停止招聘，目前只有日常实习生岗位（在社招页面选择招聘类型为日常实习生即可，后续可转正）</p></blockquote>\n\n<p>前提：<strong>必须是从上面我发的链接进入投递</strong>，否则不算是我的内推。</p>\n\n<p>首先，我确保内推是靠谱的，不会让你遇到简历石沉大海，面试杳无音讯的场景，只要你投递了，即便不合适也会给予你答复。下面我简单介绍下操作：</p>\n\n<p>通过上面的链接筛选出<strong>一个</strong>你心仪的职位（因为投递多个面试也只能进入一个，面试未通过想尝试其他岗位，那可以继续投递其他岗位），对职位有问题的话可以咨询我，我可以帮你向 HR 打听更多信息，如果没问题那就直接点击职位下方的「投递」并填写完简历信息提交即可，我这边也会同时收到你的投递，后续的进度都可以来咨询我，如果不巧未通过面试，想知道自己的不足，我也可以帮你向 HR 索要相关的面试评价，方便你改进。</p>\n\n<p>面试的整体流程是：简历筛选 -&gt; 简历评估 -&gt; 预约面试和面试（根据岗位会有多轮，HR 终面）-&gt; 喜提 offer。</p>\n\n<p>为助你更顺利地拿到 offer，以下是我精心为你准备的干货（其他岗位的同学如果觉得有好的资源也欢迎补充）：</p>\n\n<ul><li>技术人员可参考：<a href=\"https://github.com/geekcompany/ResumeSample\">如何写出一份专业的技术简历</a>（PS：简历中自己拿得出手的部分可以加粗来吸引面试官眼球）；</li><li>Android 同学可参考：<a href=\"https://github.com/Blankj/AndroidOfferKiller\">AndroidOfferKiller</a>（其他技术同学也可参考）；</li><li>技术人员一定要**「好好刷算、好好刷算法、好好刷算法」**，难度到 LeetCode 中等即可，可参考我之前总结的 <a href=\"https://github.com/Blankj/awesome-java-leetcode\">awesome-java-leetcode</a>；</li></ul>\n\n<p>我所了解的字节：</p>\n\n<ul><li>只要你有实力，薪资不会比你拿的其他 offer 低；</li><li>大小周，也就是周六不加班，每隔一周的周日会加班，加班工资为 1.2 倍；</li><li>全员 Mac + 4K 显示器，上班 10 点以后，下班根据自己的工作进度，如果不忙，吃个晚饭就可以美滋滋回去了，加班的话一般到 9、10 点（10 点以后打车报销）；</li><li>包三餐和下午茶（身边之前来自各互联网的小伙伴评价字节的食堂比 AL、WY、TX 等好吃多了，除此之外还会有大闸蟹、羊肉串、小龙虾等），零食、咖啡不限量；</li><li>步行 30分钟 以内到公司有房补；</li><li>扁平化管理，无需过多考虑上下级的关系，同事都很 nice；</li><li>想了解更多？欢迎优秀的你成为我的同事哈；</li></ul>\n\n<p> </p>',2,3,0,0,0,0,1,'2020-05-13 20:44:30','2020-05-13 20:44:30'),(75,'码农单词','码农单词本是开源的哟~欢迎大家star哟嘻嘻~','code-words','<p><span style=\"color:rgb(23,24,26);\">码农单词本是开源的哟~欢迎大家star哟嘻嘻~</span><img alt=\"https://github.com/ysm27/ProgrammerWords\" src=\"https://b-gold-cdn.xitu.io/v3/static/img/pin-url-link.3f843e8.svg\" /><br /></p>',2,3,0,0,0,0,1,'2020-05-13 20:48:14','2020-05-13 20:48:14'),(76,'一点感悟-当走完所有大厂的实习面试后','19年年底的时候从工作了两年半的公司离职，用了半个月的时看面试题及刷算法，半个月后开始投递简历，分别投了阿里、百度、快手和字节跳动，除了阿里一面匆匆忙忙电话面试把我咔掉了之外，百度、快手和字节跳动都是现...','a-little-insight-after-all-the-internship-interviews-in-large-factories','<p>19年年底的时候从工作了两年半的公司离职，用了半个月的时看面试题及刷算法，半个月后开始投递简历，分别投了阿里、百度、快手和字节跳动，除了阿里一面匆匆忙忙电话面试把我咔掉了之外，百度、快手和字节跳动都是现场面，三家offer全都拿到，最终选择了字节跳动</p>\n\n<p>三家面试，都是三轮技术面加一轮hr面，实际上，无论是哪家的面试，问的东西都是很相似的，都可以在网上搜到答案，都一定存在于某篇面试题汇总文章内，因为技术就是那个技术，就算是问出花来，本质或原理还是一样的，想看详细的真实面试题，掘金、牛客网、知乎都有很多，随便找下都看不完</p>\n\n<p>授人以鱼不如授人以渔，这篇文章还有其他我觉得更值得分享的东西，所以为了避免篇幅过长，我就不详细一一列举我在这些公司中都碰到过什么题目了，每家各提两句我印象比较深刻的</p>\n\n<h2>百度</h2>\n\n<p>百度是我被阿里咔了之后面试的第一家公司，年前北京还是可以现场面试的，所以我也是去百度现场面</p>\n\n<p>一面问的基本上都是基本功了，值得一提的是，百度是三家中唯一一个问我 CSS 问题的，大概就是面试官现场从他正在做的业务中拿了一个布局场景，让我写样式做好布局（不是圣杯布局或者双飞翼布局之类的），主要考察对 CSS 的灵活运用，需要稍微动点脑筋</p>\n\n<p>二面也问了一点基础，主要还是考察了一些场景解决方案或设计方案，算法的话，就问了一个原理是二叉树后序遍历的题目，比较简单，没费什么事就做出来了</p>\n\n<p>三面应该是经理面，就问了一个场景设计题，然后就开始谈人生理想，为什么离职啊，有什么规划啊，在之前团队做过什么有贡献的事情啊，碰到过什么难题啊最后又是怎么解决的啊，加入百度后你想做什么啊，等等，反正我感觉我回答这些问题比我回答技术题难多了，因为有些问题太抽象了，我都不知道想问什么，但又不好一直追问他到底想问什么，我只能根据我的理解来回答，一边回答一边还要察言观色，直到面试官感觉差不多了才能停，说得我口干舌燥，我宁愿多问我几个技术问题</p>\n\n<p>总结一下，百度的这场面试，更倾向于考察实际做事能力，问的都是很实际的问题，如果恰好曾经在实际工作中碰到过这些问题，或者看过相关的文章，回答起来基本是问题不大的</p>\n\n<p>百度的部门是百度APP，算是主航道吧，也挺想去的，但最后因为一些原因还是拒了</p>\n\n<h2>快手</h2>\n\n<p>一面同样还是考察基础，面试官的工作技术栈是 React，我的是 Vue，面试官也没有为难我，就从 Vue问起，问了一些面试题常见的什么响应式什么diff算法什么观察者模式之类的，因为我之前系统性地看过 Vue源码，所以回答起来也没什么难度，并且回答完了之后，顺便给他额外讲了下 Vue的执行流程和相关源码原理之类的，说得比较多，面试官还是挺满意的</p>\n\n<p>二面问了原型链等比较高级抽象的东西，然后问的其中一个算法是洗牌算法，我感觉问这个题目其实不太好，因为洗牌算法这个算法有点太独立了，不是什么回溯啊动态规划啊分治啊这些，是无法举一反三的一个题目，如果你恰好看过洗牌算法的实现，就那几行代码，你闭着眼睛都能写出来，如果你没看过，可能你想破脑袋都不知道该怎么写，当然，换个角度，运气也是实力的一部分</p>\n\n<p>三面应该是团队的前端负责人吧，和百度三面问得差不多的问题，都是先来一道场景设计题考察一下技能运用能力，然后开始问规划之类的人生理想</p>\n\n<p>总结一下，快手的这场面试考察得更加全面，同时和三面的前端负责人挺能聊得来，感觉挺合适的，而且快手也是我主动投递的最后一家公司，面完之后第二天我就回家过年了，就等着年后入职了，只不过还是没去成，因为我跳车字节跳动了</p>\n\n<h2>字节跳动</h2>\n\n<p>其实我没打算投字节跳动的，是过年在家玩耍的时候字节的hr 把我从简历库捞出来给我打电话让我投一下，说可以年后视频面试，我想了下，投就投吧，反正也没事，万一快手那边出了什么岔子我还有后路可走，然后就约了视频面试，结果没成想就过了</p>\n\n<p>三面面试官就是我现在的leader，聊完后觉得也很对眼，再加上我一年前和半年前其实投过字节跳动两次，第一次过了，但因为某些原因我没去，第二次没过，现在是第三次，过了，比较纠结，因为已经接了快手的电子offer，反悔不太好，但又想了下，可能这就是缘分吧，我感觉就算我这次不进字节，将来早晚也要进，晚进不如早进，所以就只好对不住快手那边了</p>\n\n<h2>成功面试的几个经验</h2>\n\n<p>经过这些面试，加上我看过的一些面经，我稍微总结了一下大厂面试成功的几个经验</p>\n\n<h3>学历</h3>\n\n<p>这很好理解，无论你工作了几年，hr或面试官看简历第一眼想看的就是学历，这是一个很直观地给简历打分的点，好的学历不一定能让你通过面试，但却可以让你的简历通过初筛，很多人可能就因为学历这一关，导致连面试流程都进不去，可能空有一身本事却无法施展</p>\n\n<p>但这也是可以理解的，大厂简历太多了，hr不可能给所有人面试机会的，否则面试官其他的啥也不干加上24小时连抽转也面试不过来啊，学历是一个很直观的筛简历的方式</p>\n\n<h3>工作经历</h3>\n\n<p>学历这种事情既然发生了就没法改变了，只能认了，但学历最大的作用其实还是让简历通过初筛，如果你的学历不足以让你的简历通过筛选，那么你还可以将希望放在一个好的工作经历上</p>\n\n<p>你的学历不够让你立刻进大厂，但可以先进一些二三线厂或者小型的独角兽啊，那这可选择的范围就很多了，在这个层次的公司老老实实待个两年，期间别忘了修炼好基本功，别荒废了</p>\n\n<p>两年后你的标签就是一个学历不是太好，但工作经历还不错，并且比较沉得住气的一个候选人，一般情况下，大厂给你个面试机会肯定还是没问题的，进入面试流程后，那就是你真正凭本事的时候了</p>\n\n<p>这里有三点需要注意：</p>\n\n<ol><li>作为跳板的公司不能太小了</li></ol>\n\n<p>最起码是二三线或者独角兽，公司太小了也不可能给你太好的项目经历，另外，面试官和hr大概率得听说过你这个公司</p>\n\n<ol><li>不要频繁跳槽</li></ol>\n\n<p>如果你是从腾讯跳到阿里再跳到微软谷歌，哪怕你半年一跳都没有任何问题，但如果你是从一个不知名小厂跳到另外一个不知名小厂，这种一年一跳hr都嫌你跳得太频繁了，觉得你不稳定，半年一跳就没法看了，如果你在小厂，然后将来想去大厂，那么就要稳住，别把简历搞花了</p>\n\n<ol><li>不要闷头搬砖</li></ol>\n\n<p>无论在哪工作，肯定都是以写业务代码居多，也就是搬砖了，但既然你打定了主意将来要去大厂，那么就绝对不能真的局限于搬砖，要把砖搬出花来</p>\n\n<p>比如发现项目中有个结构不太合理，但凑合着用问题也不是太大，那么你就得想我不能凑合，我得把它整舒服了才行，然后说干就干直到真的把它搞定，比如你觉得工作流程中有些步骤是重复工作，那你可以考虑下是不是可以造个轮子解决这个问题</p>\n\n<p>我经历的面试，很多情况下就是让你给出解决方案，考得就是技术的实际运用能力，几乎每一轮面试我都会碰到这种题目，这就要求你在平时工作中要有意识的积累，光搬砖你是说不出来完整的解决方案的，当然，一些常见的基础知识比如原型链、闭包、diff算法等也都是会问的，所以你不能因为平时搬砖很少用到这些就不管了，有些知识点你可能知道是怎么回事，但就是说不明白，那也是不行的，一定要真的弄明白了</p>\n\n<p>总而言之，就是要有自己的思考，不能光顾着搬砖，因为搬砖谁都会，大家都一样，都是搬砖的，凭什么你能去大厂我不能去？所以你就得比他们强才行，没条件创造条件也要上</p>\n\n<h3>个人修炼</h3>\n\n<p>如果你因为实在太倒霉，去的公司接连倒闭或者领导们都太xx，你没办法不频繁跳槽，自然也没有可以拿出手的好项目，然后把简历搞花了，也不是就无法补救了的，外界条件靠不住，你还可以纯靠自己啊</p>\n\n<p>比如写博客，记录自己平日的技术思考，倒腾出的解决方案，创建或者参与开源项目，把自己的博客和 Github整得有模有样，各种分析、源码、解决方案、开源项目，面试官点进去看了后笑容满面，你还愁你没有面试机会吗？</p>\n\n<p>个人修炼也有助于我上面提到过的面试官喜欢问的场景设计题</p>\n\n<p>比如，现在需要你重构百度app首页的feed流，feed流的展示的每一条数据，它的功能、样式会根据这条数据不同归属有不同的效果，比如广告、百家号、小视频等，点击数据流会有一些操作，比如打开一个modal或者播放一个小视频或者跳转一个页面，那么请你说下当你接到这个需求时你想要怎么设计？</p>\n\n<p>这是一种考查知识点很多，并且问的问题范围比较大的题目？不会涉及到具体的问题点，考察的就是候选人的知识广度和深度，平时的积累，考虑问题的维度等方面，上面那个题，是没有明确答案的</p>\n\n<p>这个时候就是考验候选人个人修炼的时候了，有的人可能一脸懵逼随便说几句就不知道该继续说什么了，有的人则可以跟你说上几个小时还意犹未尽，如果我是候选人，我可能会从长列表的优化、跨域/跨页面通信、配置化（可维护性）、数据预加载、数据缓存、页面/组件无缝切换/转场动画、离线包/ssr等角度来回答这个问题，如果没有这些知识储备，是不可能想到这些的，场景设计题是一个可以让面试官全方位认知你，同时也是你自由发挥的一类题目，所以一般大厂面试都会问到这类题目</p>\n\n<p>然后也有几点需要注意：</p>\n\n<ul><li><p>高质量博客</p><p>博客既然是反映你自己技术水平的一个地方，那么首先就要保证原创，确实是你的东西，如果全是搬运的 API文档或者其他人的东西或者小白教学的无脑文，那么还不如没有，面试官看了后只会觉得你难道就这点水平？所以，博客的质量一定要保证</p></li><li><p>持之以恒</p><p>不能三天打鱼两天晒网，一定要坚持下去，形成一个连贯的体验，一是让人一看就觉得你这人确实是认真在做这件事情，二是只有这样你才能有足够多的积累，几十篇文章肯定比寥寥几篇文章更能让面试官全方面了解你</p></li></ul>\n\n<h3>亮点</h3>\n\n<p>这其实是一个在很多时候可以一招制胜的关键</p>\n\n<p>关于亮点这个东西，我在 <a href=\"https://juejin.im/post/5e534b7d6fb9a07cb83e20f2#comment\">前面一篇文章的最后</a> 其实已经说过了，这里我就知道照抄过来了：</p>\n\n<blockquote><p>最近参加了几场面试，发现面试官们都很喜欢问你有哪些亮点，不管是业务层面还是技术层面，并会按照你给出的答案深入下去，看看你这个亮点到底有多亮</p><p>一个追问你亮点的面试官，其实是比较愿意给你机会的，技术的范围太广，可能他问的你恰好不熟悉，这是很常见的事情，比如你熟悉 vue，他团队内用的都是 React，他追着你问 React可能很难问出结果来，另外一方面，你也无法保证在每场面试中都保持最佳状态，万一你跟面试官根本不在同一个频道上，你们之间相互听不懂对方在说什么，还怎么继续？所以把选择权交给你，给你机会让你自己选，那么这就引出另外一个问题，如果你真的没做过什么有亮点的事情怎么办？给你机会你都抓不住，这可怪不到别人了</p><p>所以，如果你有一个较高的追求，那么在平时的工作中，哪怕是天天写业务代码，你也要有自己的思考，这个组件可不可以换一种写法，那个需求是不是可以简化一下，项目里的webpack需不需要升级到最新版，这个问题可不可以造个轮子来一劳永逸地搞定它？</p><p>无关问题大小，都可以引发思考，实际上，一般情况下也不太可能有什么大问题等着你去解决，大部分情况下都是小问题，但问题再小，解决得多了那也是一种可观的积累，通过这种积累，在团队内部，你就有了可以拿出来说的输出贡献，离开了团队，你也能以此抓住面试官给你的机会</p><p>有时候，这种亮点比你背面试题刷算法还好用，毕竟，面试题或者算法题会就是会，不会就是不会，但是亮点这种东西可没有标准答案，能说的可多了去了</p></blockquote>\n\n<p>需要注意的是，你的这个亮点一定要足够亮，不能就亮一秒就没了，容易闪着眼，必须要足够坚挺</p>\n\n<p>也就是你必须要在你这个亮点上有足够的深入和见解，上下游和细枝末节都要搞清楚，足以应对面试官展开而来的提问，这样面试官才会觉得你确实是擅长这方面</p>\n\n<h3>软素质</h3>\n\n<ul><li>简历用点心</li></ul>\n\n<p>简历是招聘流程开始的第一步，首先最起码找个好点的模板，网上很多</p>\n\n<p>然后就是内容要好好写，切忌罗列毫无意义的技术点，什么jq/vue/vuex/react/redux/http/cdn/vim/git，不是不能写，而是你别占用太多篇幅煞有其事地介绍这些，一句话完事就行了，要突出重点</p>\n\n<p>不要写<strong>精通</strong>什么什么东西，精通这个东西每个人理解得都不一样，你觉得精通就是能在任意场景下熟悉运用。面试官可能觉得你既然精通 <code>js</code>，怎么 <code>vue</code>是 <code>Evan You</code>写的而不是你呢？搞不好要为难你一把，所以尽量避免这些可能引起争论的东西</p>\n\n<p>重点写你做过的项目，<strong>项目用到的技术栈，大概功能是什么，你在其中扮演了什么角色</strong>，写重点就行了，别写得跟文档一样又多又长，细枝末节的东西等到面试的时候会问你的，三年以内工作经验的简历最好不要超过两页</p>\n\n<p>如果你博客或 github上有点东西，最好把链接带上，如果就是一个空壳子，没什么内容，就别放上去了</p>\n\n<p>另外，个人建议，简历上最好放张照片，相当于给简历增添特定的主语，有明确的个人属性，跟长得好不好看关系不大，除非你实在是觉得自己长得有点对不住全国观众那就算了</p>\n\n<ul><li>一定要会表现自己</li></ul>\n\n<p>面试官的初衷肯定是想尽可能多地了解你，这样才能更好地评估你的能力，但问的问题可能就一两句话，那么作为候选人，你不能就因为面试官只问你1+1等于几然后你回答个2就完事了，这种回答虽然合格，但不是面试官最想得到的答案</p>\n\n<p>给出了标准答案后，你应该根据主动面试官问的问题继续发散开来，比如为什么等于2，有什么实际运用的场景，以往有没有等于3的情况？</p>\n\n<p>具体点话，比如面试官给你出了个原型链的题目，那么你要做的就不仅仅是把这个道题做出来，除此之外，最好还要主动说一下原型链的相关原理，最好现场画个关系图出来，然后说下有哪些应用场景，比如原型链继承，如果你说了这个，那么其实还可以继续往继承上延伸（尽管面试官根本没问你这个），总之就是要把你的知识点全都体现出来，尽可能多地给面试官透露你的能力</p>\n\n<p>这不是偷奸耍滑，这恰恰是面试官想要看到的，他不需要绞尽脑汁地刻意引导，你就自己主动坦白了，面试官肯定高兴啊，最起码说明你懂得确实多，因为知识点掌握的不咋滴的人，他也说不出这么多来</p>\n\n<p>你通过在某个知识上深入或发散的表现，一定程度上，也可以触发<strong>晕轮效应</strong>，某一方面的突出会给面试官留下深刻的印象，就像是月亮的光晕，导致面试官下意识地就忽略了你其他方面的不足</p>\n\n<p>很多的程序猿可能就是不善于言辞，但这又不是让你搞社交，技术方面的东西我觉得还是可以开口多说两句的</p>\n\n<ul><li>第一印象</li></ul>\n\n<p>面试有时候也要看眼缘，有的面试官，在你刚看到他的时候，你就知道这场面试肯定过不了，同样的，有的面试官，在刚看到你的时候，就决定不给你过了</p>\n\n<p>所以第一印象很重要，程序猿不需要西装革履，但也别太懒散，特别是个人的精气神方面，决不能弱了，一定要有精神，不要因为担心面试过不了而一副诚惶诚恐的样子，你越这样反而越过不了</p>\n\n<p>面试你的人，基本是就是你将来的同事、leader或者隔壁组的同事，换做是你，你肯定也不想招个看着就邋遢，性格太负面的人进来当同事，所以一定要自信，需要注意的是，自信和狂妄是两回事，自信和谦虚也并不冲突</p>\n\n<h2>小结</h2>\n\n<p>作为技术人，最重要的就是自己的技术能力，很多人在刚毕业的时候一腔热血，每天打鸡血一般通宵工作也不嫌累，但是后来被社会毒打的次数多了，很容易就疲倦了，可能有的人喊着喊着就放弃了，开始安于现状，这是很危险的事情，技术这条路不进则退，只有持续学习才能在技术这条路上越走越远</p>\n\n<p>而另外一方面，客观的困难确实又是存在的，比如工作量太大没时间，前端技术发展太快学不完等，这就需要你找到一条可持续发展的道路，比如每周仔细研读一篇高质量技术文章，或者定期地进行总结，不要给自己太大的压力，但又必须要保持学习和进步</p>\n\n<p>无论你选择的方法是什么，最终最重要的还是要落到实处，收藏了一大堆优秀文章的链接放在收藏夹吃灰是没用的</p>\n\n<p> </p>',2,4,0,0,0,0,1,'2020-05-13 20:51:05','2020-05-13 20:51:05'),(77,'我就发个帖吐槽一下','  这里说一下我传奇的经历 楼主4.6号进的流程，4.27hr面的阿里巴巴某部门（姑且称之为C），前后拖了一个月，之后一直在等OC和意向书 等了10天实在忍不住了，5.7问了一下部门的招聘负责人，说是已经没有HC了，告诉我...','i-make-complaints-about-tucao','<p> </p>\n\n<h3>这里说一下我传奇的经历</h3>\n\n<ol><li>楼主4.6号进的流程，4.27hr面的阿里巴巴某部门（姑且称之为C），前后拖了一个月，之后一直在等OC和意向书 </li><li>等了10天实在忍不住了，5.7问了一下部门的招聘负责人，说是已经没有HC了，告诉我秋招再来吧，推荐我进去的师兄也说了B+评级不高，再加上HC没了，所以没什么机会了 </li><li>好吧，我就暂且不提你们没HC了为什么还面我，逛逛牛客发现阿里巴巴的某部门正在补招（这里称之为T），我心想我好像还可以再试一次，发了邮件过去给T的hr，也发了转部门意向 </li><li><strong>重点来了！！！</strong>今天收到补招的T部门hr的通知，原部门C的hr说还在考虑我，不想放流程？？？人间迷惑行为！！！没HC了你还考虑什么？？？部门招聘的人和师兄都说了HC满了没机会了等秋招吧！！！什么意思？？？备胎？？？等别人拒吗？？？还不放人？？？你挂了我也行啊？？？ </li></ol>\n\n<hr />\n\n<p>5.11 更新</p>\n\n<ul><li>在我找阿里小蜜主动要求释放流程，加上找面试官释放之后，终于变成了已拒绝 </li><li>最重要的！<strong>阿里在一个部门评级后，就算挂了，别的部门也无法更改评级</strong>，除非等到秋招重新来 </li><li><strong>每个部门评级的标准不同，请大家一定要擦亮眼睛</strong>，某些硬性要求有XXX才有A的部门就不要去了</li></ul>',9,5,0,0,0,0,1,'2020-05-13 20:55:59','2020-05-13 20:55:59'),(78,'每一个编程从业者都应该是「终身编程者」','每一个编程从业者对自己的定位，都应该是 终身编程者。 程序员是很棒的职业 世界是由软件构成的，而程序员是撰写软件的人。 在未来，很多职位会消失，这是因为计算机和软件可以取代它们。但是从另一个角度看，因为我...',NULL,'<blockquote>\n<p>每一个编程从业者对自己的定位，都应该是 <strong>终身编程者</strong>。</p>\n</blockquote>\n<h2>程序员是很棒的职业</h2>\n<p>世界是由软件构成的，而程序员是撰写软件的人。</p>\n<p>在未来，很多职位会消失，这是因为计算机和软件可以取代它们。但是从另一个角度看，因为我们需要不断开发和维护这些程序，所以这么一想，程序员的前景还是很美好的。</p>\n<p>即便你不把编程当成职业，也可以拿编程来解决生活中的问题，以工程师的思维来思考这个世界，并尝试去优化自己的生活。</p>\n<h2>编程是一辈子的</h2>\n<p>从决定把编程作为职业开始，我就告诉自己，编程应该搞一辈子。为啥？因为这个职业对经验和学习能力要求太高了，隔语言如隔行，得无时不刻地学习，没有经验还找不到工作。如果决心不够坚定，自己肯定会很难混下去。所以只要入这个行，不管十年后是否从事编程的工作，编码都应该是一辈子的。</p>\n<p>有了这个定位，就不怕自己学的东西太广太泛了，脑子里会想：「我这是在打地基」。遇到编程问题时，也会去寻找最佳实践，会带着长久发展的思维去思考。例如说不把自己的专业当成 <strong>PHP Web 开发</strong> ，而是 <strong>计算机科学</strong>，会主动去学习 <strong>软件工程</strong>。</p>\n<p>把编程当成终身职业时，工作也会变成学习进步的途径，而不是艰苦地讨生活。业余时间用来学习和编码，也会变得名正言顺。随着而来的好处是，同样几年过去了，你比身边的同事要经验丰富得多。</p>\n<h2>终身编程者社区</h2>\n<p>论坛里经常可以看到新人有这样的表现：</p>\n<ul><li>随意提问——不懂提问的智慧</li>\n<li>信息检索能力差——学会搜索</li>\n<li>没有养成自主动手解决问题的习惯——独立思考</li>\n<li>技术文章乱写——写作技能</li>\n<li>编程基础薄弱——计算机科学，软件工程相关知识</li>\n<li>缺乏培养学习力的意识——技术日新月异，学习力是安身立命之本</li>\n<li>抱怨要学的东西太多——定位混乱</li>\n<li>职业规划混乱——对行业不了解</li>\n</ul>\n\n<p>在这个社区里，我们以「终身编程者」为目标，探讨程序员需要具备 <strong>程序员修养</strong>。并期望将讨论沉淀下来，让后面的编程新人，能在一开始就养成这些好的编程素养。</p>',1,6,0,101,0,1,1,'2020-05-13 21:20:25','2020-05-14 00:14:17'),(79,'软件学院致2019届毕业生的公开信','亲爱的各位同学： 为确保您2019年6月顺利毕业，特告知您如下事宜： 第一部分 毕业证颁发条件与标准 一、成绩核查 1、核查内容 （1）公共必修课(理论类科目)、专业必修课(理论类科目)、专业限选课(理论类科目)、课程...',NULL,'<div><div class=\"v_news_content\">\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">亲爱的各位同学：</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">为确保您</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2019</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">年</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">6</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">月顺利毕业，特告知您如下事宜：</span></span></p>\n<p><br /></p>\n<p style=\"text-align:center;\"><span style=\"font-family:\'方正黑体简体\';font-size:20px;\"><span style=\"font-family:\'方正黑体简体\';\">第一部分</span></span> <span style=\"font-family:\'方正黑体简体\';font-size:20px;\"><span style=\"font-family:\'方正黑体简体\';\">毕业证颁发条件与标准</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">一、成绩核查</span></span></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">1</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">、核查内容</span></span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）公共必修课</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">(</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">理论类科目</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">)</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、专业必修课</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">(</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">理论类科目</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">)</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、专业限选课</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">(</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">理论类科目</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">)</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、课程设计、实习、实训</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">(</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">实践类科目</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">)</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">的</span></span><strong><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">名称、门数和本班其他同学一致，同时查看成绩是否全部及格。</span></span></span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）因事、病、入伍复员等个人原因申请休学、留级又复学在</span></span><strong><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">同一专业（方向）</span></span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">的同学，复学前学期成绩比照复学前年级同学审核，复学后学期成绩比照复学后年级同学审核。这类同学如有重新修读的学期，应积极到教务办申请删除原学期成绩，否则会影响毕业审核。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">因事、病、入伍复员等个人原因申请休学、留级又复学在</span></span><strong><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">其他专业（方向）</span></span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">的同学，如有重新修读的学期，亦应积极到教务办申请删除原学期成绩，否则会影响毕业审核。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span>3）根据</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">南理工字〔</span>2017〕95 号</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">《</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">南阳理工学院学生转专业规定</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">》精神，</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">转专业的同学</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">应在在校期间参加下一级同学的期末考试，补齐之前没有学习过的转后</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">新专业</span>“专业类”核心课程，成绩按初修性质对待。而转前的“公共课”按原专业培养方案执行、审核，如转前的公共课有挂科，应跟随原专业重修，重修合格后，成绩按重修性质对待。</span></strong></p>\n<p><strong><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">同一专业内转方向</span></span></span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">同学的成绩审核，</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">转前学期成绩比照转前方向同学审核，转后学期成绩比照转后方向同学审核。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">4</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）专升本同学比照</span></span><strong><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">同一专业（方向）</span></span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">本科同学第五至七学期成绩。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）因学生未选课，造成学校教务管理系统成绩单上不显示该课程的，原则上按挂科处理。</span></span></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">2、问题及解决办法</span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）如有缺课、漏录成绩，积极向学习部或教务办反映解决。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）若有仍有科目不及格，持续关注学委、学习部、教务办发布的网络通知，积极参加</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2019</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">年上半年</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">最后一次重修考核</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">二、专业任选课核查</span></span></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">1、核查内容</span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">因条件限制，专业任选课未组织过同学们选课，所开课程均由教研室负责人指定，因此该类课程等同于必修、限选课程，所以要求每位同学该类课程的名称、门数和本班其他同学一致，同时查看成绩是否全部及格。</span></span></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">2、问题及解决办法</span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）如有缺课、漏录成绩，积极向学习部或教务办反映解决。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）若有仍有科目不及格，持续关注学委、学习部、教务办发布的网络通知，积极参加</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2019</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">年上半年</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">最后一次重修考核</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">三、</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">公共任选课达标核查</span></span></strong></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">1、本科标准</span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）南阳理工学院的公共任选课分为实体授课和网络授课两种形式，所开课程按门类分为：</span>“哲学、历史与心理学”；“ 文化、语言与文学”；“ 经济、管理及法律”；“ 理科（自然科学）”；“工科（自然科学）”；“艺术与体育、创业教育”等六大类。原则上，毕业时选修课程应不少于上述类别中的五类。</span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）公共任选课修读总学分</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">不低于</span></span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">10</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分，且不能</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">选修与本专业人才培养方案中设置的课程名称或内容相同或类似的课程</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">,</span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">亦不能</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">重复选修同一门公选课；</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span>3）必须修读《音乐鉴赏》、《美术鉴赏》、《书法鉴赏》、《影视鉴赏》、《舞蹈鉴赏》、《戏剧鉴赏》、《戏曲鉴赏》、《艺术导论》中的任一门课程，而且所选课程必须是2学分；</span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span>4）在校期间，至少选择一门实体授课形式的公共选修课</span></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">2、专升本标准</span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）公共任选课修读总学分</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">不低于</span></span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分，且不能</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">选修与本专业人才培养方案中设置的课程名称或内容相同或类似的课程</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">,</span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">亦不能重</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">复选修同一门公选课；</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">）必须修读《音乐鉴赏》、《美术鉴赏》、《书法鉴赏》、《影视鉴赏》、《舞蹈鉴赏》、《戏剧鉴赏》、《戏曲鉴赏》、《艺术导论》中的任一门课程，而且所选课程必须是</span>2学分；</span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">（</span>3）在校期间，至少选择一门实体授课形式的公共选修课</span></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">3、问题及解决办法</span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">若公共选修课学分不达标，本学期和下学期应关注南阳理工学院主页信息公告栏的选课通知，对照条件补选。公共选修课挂科不能重修，成绩审核时不按挂科对待，只能再选或另选。若选课名额已满，应积极向学习部或教务办反映解决。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">四、其它条件</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">通过毕业答辩；毕业前应缴清学费。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">五、其它说明</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">软件学院的各类考试安排，教务办、学习部将通过会议、</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">QQ</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">等网络形式告知各班学习委员，然后由学委通过</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">QQ</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">等网络形式向全班同学以公告的形式传达。若有学生以实习期间工作忙没时间回校考试、上不了网、把</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">QQ</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">群屏蔽了、不知道在哪看通知、没接到通知、看不懂通知等原因为借口不回校考试，由此造成的严重后果，由本人自负。</span></span></p>\n<p><br /></p>\n<p style=\"text-align:center;\"><span style=\"font-family:\'方正黑体简体\';font-size:20px;\"><span style=\"font-family:\'方正黑体简体\';\">第二部分</span> <span style=\"font-family:\'方正黑体简体\';\">学位证授予条件</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">一、学位证授予条件</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">取得毕业证；四年制本科生全学程</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">必修、限选课</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">累计重修</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">28</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">及以上，两年制专升本学生全学程</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">必修、限选课程</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">累计重修</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">16</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">及以上，申请第二学士学位学生全学程必修、限选课程累计重修</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">24</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分及以上，不授予该生学士学位。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">二、重修学分计算办法</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、因病或其他原因，经所在学院同意、学校教学管理部门批准备案而办理了缓考手续者，参加下一届学生期末考核合格的，</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">不计入重修学分总数。</span></span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、重修成绩百分制在</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">75</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">分（含</span></span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">75</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">分）以上者（五级制的在良好及以上者）</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">虽然按重修记载，</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">但做学位审核时可按初修成绩对待，不计入重修学分总数。</span></span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">三、重修学分冲抵条件</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、毕业当年考取硕士研究生、考取公务员</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、被国家大型企业或上市企业正式录用</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">或被省辖市及以上直属事业单位正式录用者，减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、个人单独或与他人合伙创办企业并成为企业董事者（提交学位异议复议申请时企业仍在有效运行），减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">3</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、在校学习期间，</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">以南阳理工学院学生名义在</span></span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">CN</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">以上期刊公开发表本学科领域的专业学术论文的（限前两名）减免重修学分</span></span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">3</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">；在中文核心期刊发表本学科领域的专业学术论文的（限前两名）减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；被</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">EI/SCI/ISTP/CSSCI</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">等索引收录的，减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">10</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">其中以第一作者或独著发表的在原减免重修学分基础上增加减免重修学分</span></span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span></strong><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；</span></span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">4</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、在校学习期间，</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">参与完成本校教师主持的本学科领域内的科研或工程项目（含纵向和横向），经学校科研处认定做出了实际贡献的，</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">其中：校级项目减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；市厅级项目减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">6</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；省级项目减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">8</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分。排名在课题组前七的在原减免重修学分基础上增加减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、在校学习期间，参加学校学科和专业竞赛主管部门主办或组织参与的学科、专业技能竞赛，获得省级二等奖或校级一等奖以上奖励的减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">4</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分，团体项目只减免前三名，分别减免</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">4</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"> 3</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"> 2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">个学分；获得相应竞赛省级一等奖及以上奖励的在原减免重修学分基础上增加减免重修学分</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">3</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">学分；</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">6</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、因考试作弊原因无法取得学位的，满足以上</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1——5</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">款中基本条件的，或全学程课程考核成绩百分制的均在</span></span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">80</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">分以上（五级制的均在良好以上）者，经本人申请，所在学院学位评定分委员会研究同意，经校学位评议委员会三分之二以上委员同意，可以授予相应学位；</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">四、其它说明</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">1</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、毕业前应缴清学费。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">2</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、以往受过处分者，在本学期和下学期应积极向团学办申请解除处分（</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">注意处分解除的条件</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">），否则不授予学位。</span></span></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\">3</span><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">、经努力依然达不到学士学位授予条件者，若想取得学位证，可考虑申请留级或休学。留级或休学手续办理可咨询团学办辅导员，</span></span><strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">留级或复学的一年内应达到学士学位授予条件，否则此举毫无意义。</span></span></strong><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">留级或休学手续应在五月份前办理完毕。</span></span></p>\n\n<p style=\"text-align:center;\"><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正黑体简体\';font-size:21px;\">   <span style=\"font-family:\'方正黑体简体\';\">特</span></span></span><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正黑体简体\';font-size:21px;\"><span style=\"font-family:\'方正黑体简体\';\">别</span></span></span><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正黑体简体\';font-size:21px;\"><span style=\"font-family:\'方正黑体简体\';\">提</span></span></span><span style=\"text-decoration:underline;\"><span style=\"font-family:\'方正黑体简体\';font-size:21px;\"><span style=\"font-family:\'方正黑体简体\';\">醒</span>   </span></span></p>\n\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">1</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">、南阳理工学院原则上不允许各教学院（部）毕业前组织清考，请同学们按时返校参加重修考试。</span></span></strong></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">2</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">、毕业当年</span></span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">7</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">月底以前因成绩审核不合格拿不到毕业证的同学，永久取消学位证。该类学生应在毕业后一年内积极申请补考，全部考核合格后，可申领毕业证。逾期不补考者，原则上只能取得结业证，永久取消毕业证。</span></span></strong></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">3</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">、毕业当年</span></span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">7</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">月底以前因学位审核不合格，被取消学位授予资格，只拿到毕业证的同学，永久取消学位证。</span></span></strong></p>\n<p><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">4</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">、证书效力：毕业证</span></span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\">+</span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">学位证</span></span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"> &gt; </span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">毕业证</span></span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"> &gt; </span></strong><strong><span style=\"font-family:\'方正楷体简体\';font-size:16px;\"><span style=\"font-family:\'方正楷体简体\';\">结业证。</span></span></strong></p>\n<p><span style=\"font-family:\'方正书宋简体\';font-size:16px;\"><span style=\"font-family:\'方正书宋简体\';\">实在看不懂本信的同学请咨询教务办，不要以讹传讹！！！</span></span></p></div></div>',1,6,0,101,0,1,1,'2020-05-13 21:47:06','2020-05-14 00:14:14');
/*!40000 ALTER TABLE `topics` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-05-13 16:15:56
